"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@peculiar";
exports.ids = ["vendor-chunks/@peculiar"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnConvert = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/../../node_modules/pvtsutils/build/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nclass AsnConvert {\n    static serialize(obj) {\n        return serializer_1.AsnSerializer.serialize(obj);\n    }\n    static parse(data, target) {\n        return parser_1.AsnParser.parse(data, target);\n    }\n    static toString(data) {\n        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data)\n            ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data)\n            : AsnConvert.serialize(data);\n        const asn = asn1js.fromBER(buf);\n        if (asn.offset === -1) {\n            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n        }\n        return asn.result.toString();\n    }\n}\nexports.AsnConvert = AsnConvert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsZUFBZSxtQkFBTyxDQUFDLDhEQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLG9FQUFXO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFVO0FBQ25DLHFCQUFxQixtQkFBTyxDQUFDLDRGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0LmpzPzhkZmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzbkNvbnZlcnQgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5jb25zdCBzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpO1xuY2xhc3MgQXNuQ29udmVydCB7XG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXJfMS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShvYmopO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZXJfMS5Bc25QYXJzZXIucGFyc2UoZGF0YSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgc3RhdGljIHRvU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgY29uc3QgYnVmID0gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGRhdGEpXG4gICAgICAgICAgICA/IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpXG4gICAgICAgICAgICA6IEFzbkNvbnZlcnQuc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICBjb25zdCBhc24gPSBhc24xanMuZnJvbUJFUihidWYpO1xuICAgICAgICBpZiAoYXNuLm9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlY29kZSBBU04uMSBkYXRhLiAke2Fzbi5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzbi5yZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkFzbkNvbnZlcnQgPSBBc25Db252ZXJ0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst index_1 = __webpack_require__(/*! ./types/index */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\");\nexports.AsnAnyConverter = {\n    fromASN: (value) => value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,\n    toASN: (value) => {\n        if (value === null) {\n            return new asn1js.Null();\n        }\n        const schema = asn1js.fromBER(value);\n        if (schema.result.error) {\n            throw new Error(schema.result.error);\n        }\n        return schema.result;\n    },\n};\nexports.AsnIntegerConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4\n        ? value.valueBlock.toString()\n        : value.valueBlock.valueDec,\n    toASN: (value) => new asn1js.Integer({ value: +value }),\n};\nexports.AsnEnumeratedConverter = {\n    fromASN: (value) => value.valueBlock.valueDec,\n    toASN: (value) => new asn1js.Enumerated({ value }),\n};\nexports.AsnIntegerArrayBufferConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.Integer({ valueHex: value }),\n};\nexports.AsnIntegerBigIntConverter = {\n    fromASN: (value) => value.toBigInt(),\n    toASN: (value) => asn1js.Integer.fromBigInt(value),\n};\nexports.AsnBitStringConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.BitString({ valueHex: value }),\n};\nexports.AsnObjectIdentifierConverter = {\n    fromASN: (value) => value.valueBlock.toString(),\n    toASN: (value) => new asn1js.ObjectIdentifier({ value }),\n};\nexports.AsnBooleanConverter = {\n    fromASN: (value) => value.valueBlock.value,\n    toASN: (value) => new asn1js.Boolean({ value }),\n};\nexports.AsnOctetStringConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.OctetString({ valueHex: value }),\n};\nexports.AsnConstructedOctetStringConverter = {\n    fromASN: (value) => new index_1.OctetString(value.getValue()),\n    toASN: (value) => value.toASN(),\n};\nfunction createStringConverter(Asn1Type) {\n    return {\n        fromASN: (value) => value.valueBlock.value,\n        toASN: (value) => new Asn1Type({ value }),\n    };\n}\nexports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);\nexports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);\nexports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);\nexports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);\nexports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);\nexports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);\nexports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);\nexports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);\nexports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);\nexports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);\nexports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);\nexports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);\nexports.AsnUTCTimeConverter = {\n    fromASN: (value) => value.toDate(),\n    toASN: (value) => new asn1js.UTCTime({ valueDate: value }),\n};\nexports.AsnGeneralizedTimeConverter = {\n    fromASN: (value) => value.toDate(),\n    toASN: (value) => new asn1js.GeneralizedTime({ valueDate: value }),\n};\nexports.AsnNullConverter = {\n    fromASN: () => null,\n    toASN: () => {\n        return new asn1js.Null();\n    },\n};\nfunction defaultConverter(type) {\n    switch (type) {\n        case enums_1.AsnPropTypes.Any:\n            return exports.AsnAnyConverter;\n        case enums_1.AsnPropTypes.BitString:\n            return exports.AsnBitStringConverter;\n        case enums_1.AsnPropTypes.BmpString:\n            return exports.AsnBmpStringConverter;\n        case enums_1.AsnPropTypes.Boolean:\n            return exports.AsnBooleanConverter;\n        case enums_1.AsnPropTypes.CharacterString:\n            return exports.AsnCharacterStringConverter;\n        case enums_1.AsnPropTypes.Enumerated:\n            return exports.AsnEnumeratedConverter;\n        case enums_1.AsnPropTypes.GeneralString:\n            return exports.AsnGeneralStringConverter;\n        case enums_1.AsnPropTypes.GeneralizedTime:\n            return exports.AsnGeneralizedTimeConverter;\n        case enums_1.AsnPropTypes.GraphicString:\n            return exports.AsnGraphicStringConverter;\n        case enums_1.AsnPropTypes.IA5String:\n            return exports.AsnIA5StringConverter;\n        case enums_1.AsnPropTypes.Integer:\n            return exports.AsnIntegerConverter;\n        case enums_1.AsnPropTypes.Null:\n            return exports.AsnNullConverter;\n        case enums_1.AsnPropTypes.NumericString:\n            return exports.AsnNumericStringConverter;\n        case enums_1.AsnPropTypes.ObjectIdentifier:\n            return exports.AsnObjectIdentifierConverter;\n        case enums_1.AsnPropTypes.OctetString:\n            return exports.AsnOctetStringConverter;\n        case enums_1.AsnPropTypes.PrintableString:\n            return exports.AsnPrintableStringConverter;\n        case enums_1.AsnPropTypes.TeletexString:\n            return exports.AsnTeletexStringConverter;\n        case enums_1.AsnPropTypes.UTCTime:\n            return exports.AsnUTCTimeConverter;\n        case enums_1.AsnPropTypes.UniversalString:\n            return exports.AsnUniversalStringConverter;\n        case enums_1.AsnPropTypes.Utf8String:\n            return exports.AsnUtf8StringConverter;\n        case enums_1.AsnPropTypes.VideotexString:\n            return exports.AsnVideotexStringConverter;\n        case enums_1.AsnPropTypes.VisibleString:\n            return exports.AsnVisibleStringConverter;\n        default:\n            return null;\n    }\n}\nexports.defaultConverter = defaultConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyxtQ0FBbUMsR0FBRywyQkFBMkIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxpQ0FBaUMsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRyxpQ0FBaUMsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxtQ0FBbUMsR0FBRyw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRywwQ0FBMEMsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRyxvQ0FBb0MsR0FBRyw2QkFBNkIsR0FBRyxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyw4QkFBOEIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUI7QUFDNzNCLGVBQWUsbUJBQU8sQ0FBQyw4REFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBZTtBQUN2Qyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQywyQkFBMkI7QUFDM0I7QUFDQSwyQ0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2NvbnZlcnRlcnMuanM/OGQxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdENvbnZlcnRlciA9IGV4cG9ydHMuQXNuTnVsbENvbnZlcnRlciA9IGV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyID0gZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyID0gZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkNvbnN0cnVjdGVkT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25Cb29sZWFuQ29udmVydGVyID0gZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyID0gZXhwb3J0cy5Bc25CaXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuRW51bWVyYXRlZENvbnZlcnRlciA9IGV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQW55Q29udmVydGVyID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi90eXBlcy9pbmRleFwiKTtcbmV4cG9ydHMuQXNuQW55Q29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBhc24xanMuTnVsbCA/IG51bGwgOiB2YWx1ZS52YWx1ZUJlZm9yZURlY29kZVZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk51bGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWEgPSBhc24xanMuZnJvbUJFUih2YWx1ZSk7XG4gICAgICAgIGlmIChzY2hlbWEucmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2NoZW1hLnJlc3VsdC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZXN1bHQ7XG4gICAgfSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoID49IDRcbiAgICAgICAgPyB2YWx1ZS52YWx1ZUJsb2NrLnRvU3RyaW5nKClcbiAgICAgICAgOiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlRGVjLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuSW50ZWdlcih7IHZhbHVlOiArdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25FbnVtZXJhdGVkQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZURlYyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkVudW1lcmF0ZWQoeyB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuSW50ZWdlcih7IHZhbHVlSGV4OiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0JpZ0ludCgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IGFzbjFqcy5JbnRlZ2VyLmZyb21CaWdJbnQodmFsdWUpLFxufTtcbmV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay50b1N0cmluZygpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuT2JqZWN0SWRlbnRpZmllcih7IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5Cb29sZWFuKHsgdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuT2N0ZXRTdHJpbmcoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25Db25zdHJ1Y3RlZE9jdGV0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gbmV3IGluZGV4XzEuT2N0ZXRTdHJpbmcodmFsdWUuZ2V0VmFsdWUoKSksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9BU04oKSxcbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoQXNuMVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBBc24xVHlwZSh7IHZhbHVlIH0pLFxuICAgIH07XG59XG5leHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlV0ZjhTdHJpbmcpO1xuZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkJtcFN0cmluZyk7XG5leHBvcnRzLkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVW5pdmVyc2FsU3RyaW5nKTtcbmV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuTnVtZXJpY1N0cmluZyk7XG5leHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuUHJpbnRhYmxlU3RyaW5nKTtcbmV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVGVsZXRleFN0cmluZyk7XG5leHBvcnRzLkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5WaWRlb3RleFN0cmluZyk7XG5leHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuSUE1U3RyaW5nKTtcbmV4cG9ydHMuQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuR3JhcGhpY1N0cmluZyk7XG5leHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlZpc2libGVTdHJpbmcpO1xuZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5HZW5lcmFsU3RyaW5nKTtcbmV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5DaGFyYWN0ZXJTdHJpbmcpO1xuZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9EYXRlKCksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5VVENUaW1lKHsgdmFsdWVEYXRlOiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvRGF0ZSgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuR2VuZXJhbGl6ZWRUaW1lKHsgdmFsdWVEYXRlOiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbk51bGxDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKCkgPT4gbnVsbCxcbiAgICB0b0FTTjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5OdWxsKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Bbnk6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25BbnlDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkJtcFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJtcFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Cb29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5DaGFyYWN0ZXJTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuRW51bWVyYXRlZDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR2VuZXJhbFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR2VuZXJhbGl6ZWRUaW1lOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdyYXBoaWNTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25HcmFwaGljU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLklBNVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5JbnRlZ2VyOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5OdWxsOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuTnVsbENvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5OdW1lcmljU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5PY3RldFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlByaW50YWJsZVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5UZWxldGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5VVENUaW1lOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Vbml2ZXJzYWxTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVXRmOFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVmlkZW90ZXhTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5WaXNpYmxlU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVmlzaWJsZVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdENvbnZlcnRlciA9IGRlZmF1bHRDb252ZXJ0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nconst AsnType = (options) => (target) => {\n    let schema;\n    if (!storage_1.schemaStorage.has(target)) {\n        schema = storage_1.schemaStorage.createDefault(target);\n        storage_1.schemaStorage.set(target, schema);\n    }\n    else {\n        schema = storage_1.schemaStorage.get(target);\n    }\n    Object.assign(schema, options);\n};\nexports.AsnType = AsnType;\nconst AsnChoiceType = () => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Choice });\nexports.AsnChoiceType = AsnChoiceType;\nconst AsnSetType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Set, ...options });\nexports.AsnSetType = AsnSetType;\nconst AsnSequenceType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Sequence, ...options });\nexports.AsnSequenceType = AsnSequenceType;\nconst AsnProp = (options) => (target, propertyKey) => {\n    let schema;\n    if (!storage_1.schemaStorage.has(target.constructor)) {\n        schema = storage_1.schemaStorage.createDefault(target.constructor);\n        storage_1.schemaStorage.set(target.constructor, schema);\n    }\n    else {\n        schema = storage_1.schemaStorage.get(target.constructor);\n    }\n    const copyOptions = Object.assign({}, options);\n    if (typeof copyOptions.type === \"number\" && !copyOptions.converter) {\n        const defaultConverter = converters.defaultConverter(options.type);\n        if (!defaultConverter) {\n            throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);\n        }\n        copyOptions.converter = defaultConverter;\n    }\n    schema.items[propertyKey] = copyOptions;\n};\nexports.AsnProp = AsnProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZGVjb3JhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUcsZUFBZTtBQUN4RyxtQkFBbUIsbUJBQU8sQ0FBQyw0RkFBYztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG1EQUFtRCxtQ0FBbUM7QUFDdEYscUJBQXFCO0FBQ3JCLHVEQUF1RCw0Q0FBNEM7QUFDbkcsa0JBQWtCO0FBQ2xCLDREQUE0RCxpREFBaUQ7QUFDN0csdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWSxPQUFPLHdCQUF3QjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9kZWNvcmF0b3JzLmpzP2E5MjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblByb3AgPSBleHBvcnRzLkFzblNlcXVlbmNlVHlwZSA9IGV4cG9ydHMuQXNuU2V0VHlwZSA9IGV4cG9ydHMuQXNuQ2hvaWNlVHlwZSA9IGV4cG9ydHMuQXNuVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGNvbnZlcnRlcnMgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNvbnN0IEFzblR5cGUgPSAob3B0aW9ucykgPT4gKHRhcmdldCkgPT4ge1xuICAgIGxldCBzY2hlbWE7XG4gICAgaWYgKCFzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0KSkge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jcmVhdGVEZWZhdWx0KHRhcmdldCk7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQsIHNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIG9wdGlvbnMpO1xufTtcbmV4cG9ydHMuQXNuVHlwZSA9IEFzblR5cGU7XG5jb25zdCBBc25DaG9pY2VUeXBlID0gKCkgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UgfSk7XG5leHBvcnRzLkFzbkNob2ljZVR5cGUgPSBBc25DaG9pY2VUeXBlO1xuY29uc3QgQXNuU2V0VHlwZSA9IChvcHRpb25zKSA9PiAoMCwgZXhwb3J0cy5Bc25UeXBlKSh7IHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldCwgLi4ub3B0aW9ucyB9KTtcbmV4cG9ydHMuQXNuU2V0VHlwZSA9IEFzblNldFR5cGU7XG5jb25zdCBBc25TZXF1ZW5jZVR5cGUgPSAob3B0aW9ucykgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZSwgLi4ub3B0aW9ucyB9KTtcbmV4cG9ydHMuQXNuU2VxdWVuY2VUeXBlID0gQXNuU2VxdWVuY2VUeXBlO1xuY29uc3QgQXNuUHJvcCA9IChvcHRpb25zKSA9PiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgIGxldCBzY2hlbWE7XG4gICAgaWYgKCFzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jcmVhdGVEZWZhdWx0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgY29weU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIGNvcHlPcHRpb25zLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWNvcHlPcHRpb25zLmNvbnZlcnRlcikge1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29udmVydGVyID0gY29udmVydGVycy5kZWZhdWx0Q29udmVydGVyKG9wdGlvbnMudHlwZSk7XG4gICAgICAgIGlmICghZGVmYXVsdENvbnZlcnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBwcm9wZXJ0eSAnJHtwcm9wZXJ0eUtleX0nIG9mICR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29weU9wdGlvbnMuY29udmVydGVyID0gZGVmYXVsdENvbnZlcnRlcjtcbiAgICB9XG4gICAgc2NoZW1hLml0ZW1zW3Byb3BlcnR5S2V5XSA9IGNvcHlPcHRpb25zO1xufTtcbmV4cG9ydHMuQXNuUHJvcCA9IEFzblByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnPropTypes = exports.AsnTypeTypes = void 0;\nvar AsnTypeTypes;\n(function (AsnTypeTypes) {\n    AsnTypeTypes[AsnTypeTypes[\"Sequence\"] = 0] = \"Sequence\";\n    AsnTypeTypes[AsnTypeTypes[\"Set\"] = 1] = \"Set\";\n    AsnTypeTypes[AsnTypeTypes[\"Choice\"] = 2] = \"Choice\";\n})(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function (AsnPropTypes) {\n    AsnPropTypes[AsnPropTypes[\"Any\"] = 1] = \"Any\";\n    AsnPropTypes[AsnPropTypes[\"Boolean\"] = 2] = \"Boolean\";\n    AsnPropTypes[AsnPropTypes[\"OctetString\"] = 3] = \"OctetString\";\n    AsnPropTypes[AsnPropTypes[\"BitString\"] = 4] = \"BitString\";\n    AsnPropTypes[AsnPropTypes[\"Integer\"] = 5] = \"Integer\";\n    AsnPropTypes[AsnPropTypes[\"Enumerated\"] = 6] = \"Enumerated\";\n    AsnPropTypes[AsnPropTypes[\"ObjectIdentifier\"] = 7] = \"ObjectIdentifier\";\n    AsnPropTypes[AsnPropTypes[\"Utf8String\"] = 8] = \"Utf8String\";\n    AsnPropTypes[AsnPropTypes[\"BmpString\"] = 9] = \"BmpString\";\n    AsnPropTypes[AsnPropTypes[\"UniversalString\"] = 10] = \"UniversalString\";\n    AsnPropTypes[AsnPropTypes[\"NumericString\"] = 11] = \"NumericString\";\n    AsnPropTypes[AsnPropTypes[\"PrintableString\"] = 12] = \"PrintableString\";\n    AsnPropTypes[AsnPropTypes[\"TeletexString\"] = 13] = \"TeletexString\";\n    AsnPropTypes[AsnPropTypes[\"VideotexString\"] = 14] = \"VideotexString\";\n    AsnPropTypes[AsnPropTypes[\"IA5String\"] = 15] = \"IA5String\";\n    AsnPropTypes[AsnPropTypes[\"GraphicString\"] = 16] = \"GraphicString\";\n    AsnPropTypes[AsnPropTypes[\"VisibleString\"] = 17] = \"VisibleString\";\n    AsnPropTypes[AsnPropTypes[\"GeneralString\"] = 18] = \"GeneralString\";\n    AsnPropTypes[AsnPropTypes[\"CharacterString\"] = 19] = \"CharacterString\";\n    AsnPropTypes[AsnPropTypes[\"UTCTime\"] = 20] = \"UTCTime\";\n    AsnPropTypes[AsnPropTypes[\"GeneralizedTime\"] = 21] = \"GeneralizedTime\";\n    AsnPropTypes[AsnPropTypes[\"DATE\"] = 22] = \"DATE\";\n    AsnPropTypes[AsnPropTypes[\"TimeOfDay\"] = 23] = \"TimeOfDay\";\n    AsnPropTypes[AsnPropTypes[\"DateTime\"] = 24] = \"DateTime\";\n    AsnPropTypes[AsnPropTypes[\"Duration\"] = 25] = \"Duration\";\n    AsnPropTypes[AsnPropTypes[\"TIME\"] = 26] = \"TIME\";\n    AsnPropTypes[AsnPropTypes[\"Null\"] = 27] = \"Null\";\n})(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZW51bXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQyxvQkFBb0IsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEMsb0JBQW9CLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZW51bXMuanM/NjU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuUHJvcFR5cGVzID0gZXhwb3J0cy5Bc25UeXBlVHlwZXMgPSB2b2lkIDA7XG52YXIgQXNuVHlwZVR5cGVzO1xuKGZ1bmN0aW9uIChBc25UeXBlVHlwZXMpIHtcbiAgICBBc25UeXBlVHlwZXNbQXNuVHlwZVR5cGVzW1wiU2VxdWVuY2VcIl0gPSAwXSA9IFwiU2VxdWVuY2VcIjtcbiAgICBBc25UeXBlVHlwZXNbQXNuVHlwZVR5cGVzW1wiU2V0XCJdID0gMV0gPSBcIlNldFwiO1xuICAgIEFzblR5cGVUeXBlc1tBc25UeXBlVHlwZXNbXCJDaG9pY2VcIl0gPSAyXSA9IFwiQ2hvaWNlXCI7XG59KShBc25UeXBlVHlwZXMgPSBleHBvcnRzLkFzblR5cGVUeXBlcyB8fCAoZXhwb3J0cy5Bc25UeXBlVHlwZXMgPSB7fSkpO1xudmFyIEFzblByb3BUeXBlcztcbihmdW5jdGlvbiAoQXNuUHJvcFR5cGVzKSB7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkFueVwiXSA9IDFdID0gXCJBbnlcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDJdID0gXCJCb29sZWFuXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk9jdGV0U3RyaW5nXCJdID0gM10gPSBcIk9jdGV0U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJpdFN0cmluZ1wiXSA9IDRdID0gXCJCaXRTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiSW50ZWdlclwiXSA9IDVdID0gXCJJbnRlZ2VyXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkVudW1lcmF0ZWRcIl0gPSA2XSA9IFwiRW51bWVyYXRlZFwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJPYmplY3RJZGVudGlmaWVyXCJdID0gN10gPSBcIk9iamVjdElkZW50aWZpZXJcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVXRmOFN0cmluZ1wiXSA9IDhdID0gXCJVdGY4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJtcFN0cmluZ1wiXSA9IDldID0gXCJCbXBTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVW5pdmVyc2FsU3RyaW5nXCJdID0gMTBdID0gXCJVbml2ZXJzYWxTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiTnVtZXJpY1N0cmluZ1wiXSA9IDExXSA9IFwiTnVtZXJpY1N0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJQcmludGFibGVTdHJpbmdcIl0gPSAxMl0gPSBcIlByaW50YWJsZVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUZWxldGV4U3RyaW5nXCJdID0gMTNdID0gXCJUZWxldGV4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlZpZGVvdGV4U3RyaW5nXCJdID0gMTRdID0gXCJWaWRlb3RleFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJJQTVTdHJpbmdcIl0gPSAxNV0gPSBcIklBNVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJHcmFwaGljU3RyaW5nXCJdID0gMTZdID0gXCJHcmFwaGljU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlZpc2libGVTdHJpbmdcIl0gPSAxN10gPSBcIlZpc2libGVTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiR2VuZXJhbFN0cmluZ1wiXSA9IDE4XSA9IFwiR2VuZXJhbFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJDaGFyYWN0ZXJTdHJpbmdcIl0gPSAxOV0gPSBcIkNoYXJhY3RlclN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVVENUaW1lXCJdID0gMjBdID0gXCJVVENUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkdlbmVyYWxpemVkVGltZVwiXSA9IDIxXSA9IFwiR2VuZXJhbGl6ZWRUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkRBVEVcIl0gPSAyMl0gPSBcIkRBVEVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVGltZU9mRGF5XCJdID0gMjNdID0gXCJUaW1lT2ZEYXlcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRGF0ZVRpbWVcIl0gPSAyNF0gPSBcIkRhdGVUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkR1cmF0aW9uXCJdID0gMjVdID0gXCJEdXJhdGlvblwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUSU1FXCJdID0gMjZdID0gXCJUSU1FXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk51bGxcIl0gPSAyN10gPSBcIk51bGxcIjtcbn0pKEFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuUHJvcFR5cGVzIHx8IChleHBvcnRzLkFzblByb3BUeXBlcyA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/../../node_modules/tslib/tslib.es6.js\");\ntslib_1.__exportStar(__webpack_require__(/*! ./schema_validation */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDBEQUFPO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLGlIQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvaW5kZXguanM/YThjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFfdmFsaWRhdGlvblwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSchemaValidationError = void 0;\nclass AsnSchemaValidationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.schemas = [];\n    }\n}\nexports.AsnSchemaValidationError = AsnSchemaValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL3NjaGVtYV92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL3NjaGVtYV92YWxpZGF0aW9uLmpzPzUzNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvciA9IHZvaWQgMDtcbmNsYXNzIEFzblNjaGVtYVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gW107XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgPSBBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;\nfunction isConvertible(target) {\n    if (typeof target === \"function\" && target.prototype) {\n        if (target.prototype.toASN && target.prototype.fromASN) {\n            return true;\n        }\n        else {\n            return isConvertible(target.prototype);\n        }\n    }\n    else {\n        return !!(target && typeof target === \"object\" && \"toASN\" in target && \"fromASN\" in target);\n    }\n}\nexports.isConvertible = isConvertible;\nfunction isTypeOfArray(target) {\n    var _a;\n    if (target) {\n        const proto = Object.getPrototypeOf(target);\n        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {\n            return true;\n        }\n        return isTypeOfArray(proto);\n    }\n    return false;\n}\nexports.isTypeOfArray = isTypeOfArray;\nfunction isArrayEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2hlbHBlci5qcz85MzlkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBleHBvcnRzLmlzVHlwZU9mQXJyYXkgPSBleHBvcnRzLmlzQ29udmVydGlibGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc0NvbnZlcnRpYmxlKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0FTTiAmJiB0YXJnZXQucHJvdG90eXBlLmZyb21BU04pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29udmVydGlibGUodGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIiAmJiBcInRvQVNOXCIgaW4gdGFyZ2V0ICYmIFwiZnJvbUFTTlwiIGluIHRhcmdldCk7XG4gICAgfVxufVxuZXhwb3J0cy5pc0NvbnZlcnRpYmxlID0gaXNDb252ZXJ0aWJsZTtcbmZ1bmN0aW9uIGlzVHlwZU9mQXJyYXkodGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgaWYgKCgoX2EgPSBwcm90byA9PT0gbnVsbCB8fCBwcm90byA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdG8ucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3RydWN0b3IpID09PSBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVHlwZU9mQXJyYXkocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVHlwZU9mQXJyYXkgPSBpc1R5cGVPZkFycmF5O1xuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGJ5dGVzMSwgYnl0ZXMyKSB7XG4gICAgaWYgKCEoYnl0ZXMxICYmIGJ5dGVzMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYnl0ZXMxLmJ5dGVMZW5ndGggIT09IGJ5dGVzMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYjEgPSBuZXcgVWludDhBcnJheShieXRlczEpO1xuICAgIGNvbnN0IGIyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzMS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBpc0FycmF5RXF1YWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/../../node_modules/tslib/tslib.es6.js\");\ntslib_1.__exportStar(__webpack_require__(/*! ./converters */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./types/index */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\"), exports);\nvar decorators_1 = __webpack_require__(/*! ./decorators */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\");\nObject.defineProperty(exports, \"AsnProp\", ({ enumerable: true, get: function () { return decorators_1.AsnProp; } }));\nObject.defineProperty(exports, \"AsnType\", ({ enumerable: true, get: function () { return decorators_1.AsnType; } }));\nObject.defineProperty(exports, \"AsnChoiceType\", ({ enumerable: true, get: function () { return decorators_1.AsnChoiceType; } }));\nObject.defineProperty(exports, \"AsnSequenceType\", ({ enumerable: true, get: function () { return decorators_1.AsnSequenceType; } }));\nObject.defineProperty(exports, \"AsnSetType\", ({ enumerable: true, get: function () { return decorators_1.AsnSetType; } }));\nvar enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nObject.defineProperty(exports, \"AsnTypeTypes\", ({ enumerable: true, get: function () { return enums_1.AsnTypeTypes; } }));\nObject.defineProperty(exports, \"AsnPropTypes\", ({ enumerable: true, get: function () { return enums_1.AsnPropTypes; } }));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nObject.defineProperty(exports, \"AsnParser\", ({ enumerable: true, get: function () { return parser_1.AsnParser; } }));\nvar serializer_1 = __webpack_require__(/*! ./serializer */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nObject.defineProperty(exports, \"AsnSerializer\", ({ enumerable: true, get: function () { return serializer_1.AsnSerializer; } }));\ntslib_1.__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./objects */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./convert */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLGVBQWU7QUFDbE0sZ0JBQWdCLG1CQUFPLENBQUMsMERBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsNEZBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsOEZBQWU7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsNEZBQWM7QUFDekMsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILDJDQUEwQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNsSCxpREFBZ0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDOUgsbURBQWtELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ2xJLDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxjQUFjLG1CQUFPLENBQUMsa0ZBQVM7QUFDL0IsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZILGdEQUErQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN2SCxlQUFlLG1CQUFPLENBQUMsb0ZBQVU7QUFDakMsNkNBQTRDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2xILG1CQUFtQixtQkFBTyxDQUFDLDRGQUFjO0FBQ3pDLGlEQUFnRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM5SCxxQkFBcUIsbUJBQU8sQ0FBQywwRkFBVTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBVztBQUN4QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9pbmRleC5qcz9mYjBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gZXhwb3J0cy5Bc25QYXJzZXIgPSBleHBvcnRzLkFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuVHlwZVR5cGVzID0gZXhwb3J0cy5Bc25TZXRUeXBlID0gZXhwb3J0cy5Bc25TZXF1ZW5jZVR5cGUgPSBleHBvcnRzLkFzbkNob2ljZVR5cGUgPSBleHBvcnRzLkFzblR5cGUgPSBleHBvcnRzLkFzblByb3AgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydGVyc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9pbmRleFwiKSwgZXhwb3J0cyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblByb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25Qcm9wOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25DaG9pY2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuQ2hvaWNlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNlcXVlbmNlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblNlcXVlbmNlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNldFR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25TZXRUeXBlOyB9IH0pO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblR5cGVUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5Bc25UeXBlVHlwZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25Qcm9wVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuQXNuUHJvcFR5cGVzOyB9IH0pO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuUGFyc2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXJfMS5Bc25QYXJzZXI7IH0gfSk7XG52YXIgc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNlcmlhbGl6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZXJfMS5Bc25TZXJpYWxpemVyOyB9IH0pO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdHNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnArray = void 0;\nclass AsnArray extends Array {\n    constructor(items = []) {\n        if (typeof items === \"number\") {\n            super(items);\n        }\n        else {\n            super();\n            for (const item of items) {\n                this.push(item);\n            }\n        }\n    }\n}\nexports.AsnArray = AsnArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvb2JqZWN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvb2JqZWN0cy5qcz80NjA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25BcnJheSA9IHZvaWQgMDtcbmNsYXNzIEFzbkFycmF5IGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3VwZXIoaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXNuQXJyYXkgPSBBc25BcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnParser = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if ((0, helper_1.isConvertible)(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = storage_1.schemaStorage.get(target);\n            storage_1.schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber,\n                    },\n                    value: schema.schema.valueBlock.value,\n                });\n                for (const key in schema.items) {\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if ((0, helper_1.isTypeOfArray)(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));\n                }\n                else {\n                    return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));\n                }\n            }\n            for (const key in schema.items) {\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || (0, helper_1.isConvertible)(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : ((0, helper_1.isConvertible)(schemaItemType)\n                        ? new schemaItemType()\n                        : null);\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\"\n                                ? asn1js.Sequence\n                                : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element) => converter.fromASN(element));\n                        }\n                        else {\n                            res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));\n                        }\n                    }\n                    else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if ((0, helper_1.isConvertible)(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            }\n                            else {\n                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                }\n                else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));\n                    }\n                    else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        }\n        catch (error) {\n            if (error instanceof errors_1.AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\nexports.AsnParser = AsnParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixlQUFlLG1CQUFPLENBQUMsOERBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsNEZBQWM7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMEZBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esc0ZBQXNGLGFBQWEsZUFBZSxnQ0FBZ0M7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysd0JBQXdCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvcGFyc2VyLmpzP2UzYTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5jb25zdCBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlXCIpO1xuY2xhc3MgQXNuUGFyc2VyIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGFzbjFQYXJzZWQgPSBhc24xanMuZnJvbUJFUihkYXRhKTtcbiAgICAgICAgaWYgKGFzbjFQYXJzZWQucmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXNuMVBhcnNlZC5yZXN1bHQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZnJvbUFTTihhc24xUGFyc2VkLnJlc3VsdCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21BU04oYXNuMVNjaGVtYSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5mcm9tQVNOKGFzbjFTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jYWNoZSh0YXJnZXQpO1xuICAgICAgICAgICAgbGV0IHRhcmdldFNjaGVtYSA9IHNjaGVtYS5zY2hlbWE7XG4gICAgICAgICAgICBpZiAoYXNuMVNjaGVtYS5jb25zdHJ1Y3RvciA9PT0gYXNuMWpzLkNvbnN0cnVjdGVkICYmIHNjaGVtYS50eXBlICE9PSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTY2hlbWEgPSBuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGFzbjFTY2hlbWEuaWRCbG9jay50YWdOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEuc2NoZW1hLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhc24xU2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXNuMUNvbXBhcmVkU2NoZW1hID0gYXNuMWpzLmNvbXBhcmVTY2hlbWEoe30sIGFzbjFTY2hlbWEsIHRhcmdldFNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIWFzbjFDb21wYXJlZFNjaGVtYS52ZXJpZmllZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IoYERhdGEgZG9lcyBub3QgbWF0Y2ggdG8gJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWEuICR7YXNuMUNvbXBhcmVkU2NoZW1hLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyB0YXJnZXQoKTtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNUeXBlT2ZBcnJheSkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmICghKFwidmFsdWVcIiBpbiBhc24xU2NoZW1hLnZhbHVlQmxvY2sgJiYgQXJyYXkuaXNBcnJheShhc24xU2NoZW1hLnZhbHVlQmxvY2sudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSBvYmplY3QgaXMgbm90IGNvbnN0cnVjdGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHNjaGVtYS5pdGVtVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlcnMuZGVmYXVsdENvbnZlcnRlcihpdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIGFycmF5IGl0ZW0gb2YgJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWFgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmZyb20oYXNuMVNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5mcm9tKGFzbjFTY2hlbWEudmFsdWVCbG9jay52YWx1ZSwgKGVsZW1lbnQpID0+IHRoaXMuZnJvbUFTTihlbGVtZW50LCBpdGVtVHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzbjFTY2hlbWFWYWx1ZSA9IGFzbjFDb21wYXJlZFNjaGVtYS5yZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzbjFTY2hlbWFWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUl0ZW1UeXBlID0gc2NoZW1hSXRlbS50eXBlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSXRlbVR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW1UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSAoX2EgPSBzY2hlbWFJdGVtLmNvbnZlcnRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IHNjaGVtYUl0ZW1UeXBlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXJ0ZXIgaXMgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gbmV3IENvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0udmFsdWVCbG9jayA9IGFzbjFTY2hlbWFWYWx1ZS52YWx1ZUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1Bc24gPSBhc24xanMuZnJvbUJFUihuZXdJdGVtLnRvQkVSKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW1Bc24ub2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgY2hpbGQgaXRlbS4gJHtuZXdJdGVtQXNuLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJ2YWx1ZVwiIGluIG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sgJiYgQXJyYXkuaXNBcnJheShuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBpdGVtcyBmcm9tIHRoZSBBU04uMSBwYXJzZWQgdmFsdWUuIEFTTi4xIG9iamVjdCBpcyBub3QgY29uc3RydWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKHZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKGFzbjFTY2hlbWFWYWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGFzbjFTY2hlbWFWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IG5ldyBzY2hlbWFJdGVtVHlwZSgpLnRvU2NoZW1hKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGVOYW1lID0gZW51bXNfMS5Bc25Qcm9wVHlwZXNbc2NoZW1hSXRlbVR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZSA9IGFzbjFqc1tBc24xVHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFzbjFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgJyR7QXNuMVR5cGVOYW1lfScgY2xhc3MgZnJvbSBhc24xanMgbW9kdWxlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IG5ldyBBc24xVHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLnZhbHVlQmxvY2sgPSB2YWx1ZS52YWx1ZUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXNuMWpzLmZyb21CRVIobmV3SXRlbS50b0JFUihmYWxzZSkpLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gY29udmVydGVyLmZyb21BU04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzbjFTY2hlbWFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGxpc3Qgb2YgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSB2YWx1ZSBzaG91bGQgYmUgaXRlcmFibGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKGFzbjFTY2hlbWFWYWx1ZSwgKGVsZW1lbnQpID0+IHRoaXMuZnJvbUFTTihlbGVtZW50LCBzY2hlbWFJdGVtVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSB0aGlzLmZyb21BU04oYXNuMVNjaGVtYVZhbHVlLCBzY2hlbWFJdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzXzEuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2NoZW1hcy5wdXNoKHRhcmdldC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bc25QYXJzZXIgPSBBc25QYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSchemaStorage = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nclass AsnSchemaStorage {\n    constructor() {\n        this.items = new WeakMap();\n    }\n    has(target) {\n        return this.items.has(target);\n    }\n    get(target, checkSchema = false) {\n        const schema = this.items.get(target);\n        if (!schema) {\n            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n        }\n        if (checkSchema && !schema.schema) {\n            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n        }\n        return schema;\n    }\n    cache(target) {\n        const schema = this.get(target);\n        if (!schema.schema) {\n            schema.schema = this.create(target, true);\n        }\n    }\n    createDefault(target) {\n        const schema = {\n            type: enums_1.AsnTypeTypes.Sequence,\n            items: {},\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.items = Object.assign({}, schema.items, parentSchema.items);\n        }\n        return schema;\n    }\n    create(target, useNames) {\n        const schema = this.items.get(target) || this.createDefault(target);\n        const asn1Value = [];\n        for (const key in schema.items) {\n            const item = schema.items[key];\n            const name = useNames ? key : \"\";\n            let asn1Item;\n            if (typeof (item.type) === \"number\") {\n                const Asn1TypeName = enums_1.AsnPropTypes[item.type];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n                }\n                asn1Item = new Asn1Type({ name });\n            }\n            else if ((0, helper_1.isConvertible)(item.type)) {\n                const instance = new item.type();\n                asn1Item = instance.toSchema(name);\n            }\n            else if (item.optional) {\n                const itemSchema = this.get(item.type);\n                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {\n                    asn1Item = new asn1js.Any({ name });\n                }\n                else {\n                    asn1Item = this.create(item.type, false);\n                    asn1Item.name = name;\n                }\n            }\n            else {\n                asn1Item = new asn1js.Any({ name });\n            }\n            const optional = !!item.optional || item.defaultValue !== undefined;\n            if (item.repeated) {\n                asn1Item.name = \"\";\n                const Container = item.repeated === \"set\"\n                    ? asn1js.Set\n                    : asn1js.Sequence;\n                asn1Item = new Container({\n                    name: \"\",\n                    value: [\n                        new asn1js.Repeated({\n                            name,\n                            value: asn1Item,\n                        }),\n                    ],\n                });\n            }\n            if (item.context !== null && item.context !== undefined) {\n                if (item.implicit) {\n                    if (typeof item.type === \"number\" || (0, helper_1.isConvertible)(item.type)) {\n                        const Container = item.repeated\n                            ? asn1js.Constructed\n                            : asn1js.Primitive;\n                        asn1Value.push(new Container({\n                            name,\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context,\n                            },\n                        }));\n                    }\n                    else {\n                        this.cache(item.type);\n                        const isRepeated = !!item.repeated;\n                        let value = !isRepeated\n                            ? this.get(item.type, true).schema\n                            : asn1Item;\n                        value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n                        asn1Value.push(new asn1js.Constructed({\n                            name: !isRepeated ? name : \"\",\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context,\n                            },\n                            value: value,\n                        }));\n                    }\n                }\n                else {\n                    asn1Value.push(new asn1js.Constructed({\n                        optional,\n                        idBlock: {\n                            tagClass: 3,\n                            tagNumber: item.context,\n                        },\n                        value: [asn1Item],\n                    }));\n                }\n            }\n            else {\n                asn1Item.optional = optional;\n                asn1Value.push(asn1Item);\n            }\n        }\n        switch (schema.type) {\n            case enums_1.AsnTypeTypes.Sequence:\n                return new asn1js.Sequence({ value: asn1Value, name: \"\" });\n            case enums_1.AsnTypeTypes.Set:\n                return new asn1js.Set({ value: asn1Value, name: \"\" });\n            case enums_1.AsnTypeTypes.Choice:\n                return new asn1js.Choice({ value: asn1Value, name: \"\" });\n            default:\n                throw new Error(`Unsupported ASN1 type in use`);\n        }\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nexports.AsnSchemaStorage = AsnSchemaStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixlQUFlLG1CQUFPLENBQUMsOERBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0NBQWtDO0FBQ3hGO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NjaGVtYS5qcz9iYWIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TY2hlbWFTdG9yYWdlID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY2xhc3MgQXNuU2NoZW1hU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBoYXModGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyh0YXJnZXQpO1xuICAgIH1cbiAgICBnZXQodGFyZ2V0LCBjaGVja1NjaGVtYSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgc2NoZW1hIGZvciAnJHt0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWV9JyB0YXJnZXRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTY2hlbWEgJiYgIXNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hICcke3RhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZX0nIGRvZXNuJ3QgY29udGFpbiBBU04uMSBzY2hlbWEuIENhbGwgJ0FzblNjaGVtYVN0b3JhZ2UuY2FjaGUnLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNhY2hlKHRhcmdldCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYS5zY2hlbWEgPSB0aGlzLmNyZWF0ZSh0YXJnZXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZURlZmF1bHQodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlLFxuICAgICAgICAgICAgaXRlbXM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBzY2hlbWEuaXRlbXMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEuaXRlbXMsIHBhcmVudFNjaGVtYS5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY3JlYXRlKHRhcmdldCwgdXNlTmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQodGFyZ2V0KSB8fCB0aGlzLmNyZWF0ZURlZmF1bHQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYXNuMVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHVzZU5hbWVzID8ga2V5IDogXCJcIjtcbiAgICAgICAgICAgIGxldCBhc24xSXRlbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZU5hbWUgPSBlbnVtc18xLkFzblByb3BUeXBlc1tpdGVtLnR5cGVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlID0gYXNuMWpzW0FzbjFUeXBlTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFBc24xVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgQVNOMSBjbGFzcyBieSBuYW1lICcke0FzbjFUeXBlTmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IEFzbjFUeXBlKHsgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgaXRlbS50eXBlKCk7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBpbnN0YW5jZS50b1NjaGVtYShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gdGhpcy5nZXQoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVNjaGVtYS50eXBlID09PSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgYXNuMWpzLkFueSh7IG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbSA9IHRoaXMuY3JlYXRlKGl0ZW0udHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBhc24xanMuQW55KHsgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbmFsID0gISFpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IGl0ZW0ucmVwZWF0ZWQgPT09IFwic2V0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2V0XG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNlcXVlbmNlO1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgYXNuMWpzLlJlcGVhdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhc24xSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uY29udGV4dCAhPT0gbnVsbCAmJiBpdGVtLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS50eXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBpdGVtLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuQ29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5QcmltaXRpdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlKGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1JlcGVhdGVkID0gISFpdGVtLnJlcGVhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gIWlzUmVwZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0KGl0ZW0udHlwZSwgdHJ1ZSkuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhc24xSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJ2YWx1ZUJsb2NrXCIgaW4gdmFsdWUgPyB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlIDogdmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAhaXNSZXBlYXRlZCA/IG5hbWUgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbYXNuMUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0ub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChhc24xSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzY2hlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5TZXF1ZW5jZSh7IHZhbHVlOiBhc24xVmFsdWUsIG5hbWU6IFwiXCIgfSk7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5TZXQoeyB2YWx1ZTogYXNuMVZhbHVlLCBuYW1lOiBcIlwiIH0pO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuQ2hvaWNlKHsgdmFsdWU6IGFzbjFWYWx1ZSwgbmFtZTogXCJcIiB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBBU04xIHR5cGUgaW4gdXNlYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHRhcmdldCwgc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYSB8fCB0aGlzLmZpbmRQYXJlbnRTY2hlbWEocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkFzblNjaGVtYVN0b3JhZ2UgPSBBc25TY2hlbWFTdG9yYWdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSerializer = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && (0, helper_1.isConvertible)(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = storage_1.schemaStorage.get(target);\n        storage_1.schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o) => converter.toASN(o));\n            }\n            else {\n                asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, \"[]\", target, o));\n            }\n        }\n        else {\n            for (const key in schema.items) {\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined\n                    || schemaItem.defaultValue === objProp\n                    || (typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\"\n                        && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp)))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated\n                            && (typeof schemaItem.type === \"number\" || (0, helper_1.isConvertible)(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                ...value,\n                            }));\n                        }\n                        else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                value: asn1Item.valueBlock.value,\n                            }));\n                        }\n                    }\n                    else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context,\n                            },\n                            value: [asn1Item],\n                        }));\n                    }\n                }\n                else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                }\n                else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch (schema.type) {\n            case enums_1.AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({ value: asn1Value });\n                break;\n            case enums_1.AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({ value: asn1Value });\n                break;\n            case enums_1.AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof (schemaItem.type) === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = converter.toASN(objProp);\n            }\n        }\n        else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\nexports.AsnSerializer = AsnSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc2VyaWFsaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsZUFBZSxtQkFBTyxDQUFDLDhEQUFRO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLDRGQUFjO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFVO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsdUJBQXVCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUksb0NBQW9DLHVDQUF1QyxhQUFhLFlBQVk7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NlcmlhbGl6ZXIuanM/Y2I5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNsYXNzIEFzblNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBhc24xanMuQmFzZUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvQkVSKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b0FTTihvYmopLnRvQkVSKGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQVNOKG9iaikge1xuICAgICAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9BU04oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgMSBzaG91bGQgYmUgdHlwZSBvZiBPYmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmNhY2hlKHRhcmdldCk7XG4gICAgICAgIGxldCBhc24xVmFsdWUgPSBbXTtcbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtVHlwZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyIDEgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuaXRlbVR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzLmRlZmF1bHRDb252ZXJ0ZXIoc2NoZW1hLml0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIGFycmF5IGl0ZW0gb2YgJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gb2JqLm1hcCgobykgPT4gY29udmVydGVyLnRvQVNOKG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IG9iai5tYXAoKG8pID0+IHRoaXMudG9Bc25JdGVtKHsgdHlwZTogc2NoZW1hLml0ZW1UeXBlIH0sIFwiW11cIiwgdGFyZ2V0LCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gc2NoZW1hLml0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqUHJvcCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvYmpQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfHwgc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUgPT09IG9ialByb3BcbiAgICAgICAgICAgICAgICAgICAgfHwgKHR5cGVvZiBzY2hlbWFJdGVtLmRlZmF1bHRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqUHJvcCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKDAsIGhlbHBlcl8xLmlzQXJyYXlFcXVhbCkodGhpcy5zZXJpYWxpemUoc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUpLCB0aGlzLnNlcmlhbGl6ZShvYmpQcm9wKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhc24xSXRlbSA9IEFzblNlcmlhbGl6ZXIudG9Bc25JdGVtKHNjaGVtYUl0ZW0sIGtleSwgdGFyZ2V0LCBvYmpQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUl0ZW0uY29udGV4dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFJdGVtLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW0udHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZUhleCA9IGFzbjFJdGVtIGluc3RhbmNlb2YgYXNuMWpzLk51bGwgPyBhc24xSXRlbS52YWx1ZUJlZm9yZURlY29kZVZpZXcgOiBhc24xSXRlbS52YWx1ZUJsb2NrLnRvQkVSKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5QcmltaXRpdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzY2hlbWFJdGVtLm9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogc2NoZW1hSXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXNuMUl0ZW0udmFsdWVCbG9jay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbYXNuMUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gYXNuMVZhbHVlLmNvbmNhdChhc24xSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChhc24xSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhc25TY2hlbWE7XG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gbmV3IGFzbjFqcy5TZXF1ZW5jZSh7IHZhbHVlOiBhc24xVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldDpcbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBuZXcgYXNuMWpzLlNldCh7IHZhbHVlOiBhc24xVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZTpcbiAgICAgICAgICAgICAgICBpZiAoIWFzbjFWYWx1ZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSAnJHt0YXJnZXQubmFtZX0nIGhhcyB3cm9uZyBkYXRhLiBDaG9pY2UgY2Fubm90IGJlIGVtcHR5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBhc24xVmFsdWVbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzblNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIHRvQXNuSXRlbShzY2hlbWFJdGVtLCBrZXksIHRhcmdldCwgb2JqUHJvcCkge1xuICAgICAgICBsZXQgYXNuMUl0ZW07XG4gICAgICAgIGlmICh0eXBlb2YgKHNjaGVtYUl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IHNjaGVtYUl0ZW0uY29udmVydGVyO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICcke2tleX0nIGRvZXNuJ3QgaGF2ZSBjb252ZXJ0ZXIgZm9yIHR5cGUgJHtlbnVtc18xLkFzblByb3BUeXBlc1tzY2hlbWFJdGVtLnR5cGVdfSBpbiBzY2hlbWEgJyR7dGFyZ2V0Lm5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqUHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAnb2JqUHJvcCcgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20ob2JqUHJvcCwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci50b0FTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IGNvbnZlcnRlci50b0FTTihvYmpQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ29ialByb3AnIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG9ialByb3AsIChlbGVtZW50KSA9PiB0aGlzLnRvQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBzY2hlbWFJdGVtLnJlcGVhdGVkID09PSBcInNlcXVlbmNlXCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuU2V0O1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gdGhpcy50b0FTTihvYmpQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNuMUl0ZW07XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gQXNuU2VyaWFsaXplcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaStorage = void 0;\nconst schema_1 = __webpack_require__(/*! ./schema */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js\");\nexports.schemaStorage = new schema_1.AsnSchemaStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7QUFDbkMscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3N0b3JhZ2UuanM/MWI4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZW1hU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IHNjaGVtYV8xID0gcmVxdWlyZShcIi4vc2NoZW1hXCIpO1xuZXhwb3J0cy5zY2hlbWFTdG9yYWdlID0gbmV3IHNjaGVtYV8xLkFzblNjaGVtYVN0b3JhZ2UoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BitString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/../../node_modules/pvtsutils/build/index.js\");\nclass BitString {\n    constructor(params, unusedBits = 0) {\n        this.unusedBits = 0;\n        this.value = new ArrayBuffer(0);\n        if (params) {\n            if (typeof params === \"number\") {\n                this.fromNumber(params);\n            }\n            else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {\n                this.unusedBits = unusedBits;\n                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);\n            }\n            else {\n                throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.BitString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n        }\n        this.unusedBits = asn.valueBlock.unusedBits;\n        this.value = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.BitString({ unusedBits: this.unusedBits, valueHex: this.value });\n    }\n    toSchema(name) {\n        return new asn1js.BitString({ name });\n    }\n    toNumber() {\n        let res = \"\";\n        const uintArray = new Uint8Array(this.value);\n        for (const octet of uintArray) {\n            res += octet.toString(2).padStart(8, \"0\");\n        }\n        res = res.split(\"\").reverse().join(\"\");\n        if (this.unusedBits) {\n            res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n        }\n        return parseInt(res, 2);\n    }\n    fromNumber(value) {\n        let bits = value.toString(2);\n        const octetSize = (bits.length + 7) >> 3;\n        this.unusedBits = (octetSize << 3) - bits.length;\n        const octets = new Uint8Array(octetSize);\n        bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n        let index = 0;\n        while (index < octetSize) {\n            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n            index++;\n        }\n        this.value = octets.buffer;\n    }\n}\nexports.BitString = BitString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvYml0X3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsZUFBZSxtQkFBTyxDQUFDLDhEQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLG9FQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbURBQW1EO0FBQ3pGO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvYml0X3N0cmluZy5qcz9jZWM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY2xhc3MgQml0U3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIHVudXNlZEJpdHMgPSAwKSB7XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW51c2VkQml0cyA9IHVudXNlZEJpdHM7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mICdwYXJhbXMnIGFyZ3VtZW50IGZvciBCaXRTdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbUFTTihhc24pIHtcbiAgICAgICAgaWYgKCEoYXNuIGluc3RhbmNlb2YgYXNuMWpzLkJpdFN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYXNuJyBpcyBub3QgaW5zdGFuY2Ugb2YgQVNOLjEgQml0U3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IGFzbi52YWx1ZUJsb2NrLnVudXNlZEJpdHM7XG4gICAgICAgIHRoaXMudmFsdWUgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvQVNOKCkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyB1bnVzZWRCaXRzOiB0aGlzLnVudXNlZEJpdHMsIHZhbHVlSGV4OiB0aGlzLnZhbHVlIH0pO1xuICAgIH1cbiAgICB0b1NjaGVtYShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLkJpdFN0cmluZyh7IG5hbWUgfSk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgY29uc3QgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgb2N0ZXQgb2YgdWludEFycmF5KSB7XG4gICAgICAgICAgICByZXMgKz0gb2N0ZXQudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IHJlcy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgaWYgKHRoaXMudW51c2VkQml0cykge1xuICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKHRoaXMudW51c2VkQml0cykucGFkU3RhcnQodGhpcy51bnVzZWRCaXRzLCBcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJlcywgMik7XG4gICAgfVxuICAgIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGJpdHMgPSB2YWx1ZS50b1N0cmluZygyKTtcbiAgICAgICAgY29uc3Qgb2N0ZXRTaXplID0gKGJpdHMubGVuZ3RoICsgNykgPj4gMztcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gKG9jdGV0U2l6ZSA8PCAzKSAtIGJpdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBvY3RldHMgPSBuZXcgVWludDhBcnJheShvY3RldFNpemUpO1xuICAgICAgICBiaXRzID0gYml0cy5wYWRTdGFydChvY3RldFNpemUgPDwgMywgXCIwXCIpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBvY3RldFNpemUpIHtcbiAgICAgICAgICAgIG9jdGV0c1tpbmRleF0gPSBwYXJzZUludChiaXRzLnNsaWNlKGluZGV4IDw8IDMsIChpbmRleCA8PCAzKSArIDgpLCAyKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IG9jdGV0cy5idWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRTdHJpbmcgPSBCaXRTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/../../node_modules/tslib/tslib.es6.js\");\ntslib_1.__exportStar(__webpack_require__(/*! ./bit_string */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./octet_string */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsMERBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsa0dBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsc0dBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2luZGV4LmpzP2U1YWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYml0X3N0cmluZ1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vY3RldF9zdHJpbmdcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OctetString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/../../node_modules/pvtsutils/build/index.js\");\nclass OctetString {\n    constructor(param) {\n        if (typeof param === \"number\") {\n            this.buffer = new ArrayBuffer(param);\n        }\n        else {\n            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {\n                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);\n            }\n            else if (Array.isArray(param)) {\n                this.buffer = new Uint8Array(param);\n            }\n            else {\n                this.buffer = new ArrayBuffer(0);\n            }\n        }\n    }\n    get byteLength() {\n        return this.buffer.byteLength;\n    }\n    get byteOffset() {\n        return 0;\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.OctetString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 OctetString\");\n        }\n        this.buffer = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.OctetString({ valueHex: this.buffer });\n    }\n    toSchema(name) {\n        return new asn1js.OctetString({ name });\n    }\n}\nexports.OctetString = OctetString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvb2N0ZXRfc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixlQUFlLG1CQUFPLENBQUMsOERBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsb0VBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL29jdGV0X3N0cmluZy5qcz8wMjFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PY3RldFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBwdnRzdXRpbHNfMSA9IHJlcXVpcmUoXCJwdnRzdXRpbHNcIik7XG5jbGFzcyBPY3RldFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGdldCBieXRlT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnJvbUFTTihhc24pIHtcbiAgICAgICAgaWYgKCEoYXNuIGluc3RhbmNlb2YgYXNuMWpzLk9jdGV0U3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50ICdhc24nIGlzIG5vdCBpbnN0YW5jZSBvZiBBU04uMSBPY3RldFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGFzbi52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9BU04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgdmFsdWVIZXg6IHRoaXMuYnVmZmVyIH0pO1xuICAgIH1cbiAgICB0b1NjaGVtYShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgbmFtZSB9KTtcbiAgICB9XG59XG5leHBvcnRzLk9jdGV0U3RyaW5nID0gT2N0ZXRTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/json-schema/build/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@peculiar/json-schema/build/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nclass JsonError extends Error {\r\n    constructor(message, innerError) {\r\n        super(innerError\r\n            ? `${message}. See the inner exception for more details.`\r\n            : message);\r\n        this.message = message;\r\n        this.innerError = innerError;\r\n    }\r\n}\n\nclass TransformError extends JsonError {\r\n    constructor(schema, message, innerError) {\r\n        super(message, innerError);\r\n        this.schema = schema;\r\n    }\r\n}\n\nclass ParserError extends TransformError {\r\n    constructor(schema, message, innerError) {\r\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\r\n    }\r\n}\n\nclass ValidationError extends JsonError {\r\n}\n\nclass SerializerError extends JsonError {\r\n    constructor(schemaName, message, innerError) {\r\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\r\n        this.schemaName = schemaName;\r\n    }\r\n}\n\nclass KeyError extends ParserError {\r\n    constructor(schema, keys, errors = {}) {\r\n        super(schema, \"Some keys doesn't match to schema\");\r\n        this.keys = keys;\r\n        this.errors = errors;\r\n    }\r\n}\n\n(function (JsonPropTypes) {\r\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\r\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\r\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\r\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\r\n})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));\n\nfunction checkType(value, type) {\r\n    switch (type) {\r\n        case exports.JsonPropTypes.Boolean:\r\n            return typeof value === \"boolean\";\r\n        case exports.JsonPropTypes.Number:\r\n            return typeof value === \"number\";\r\n        case exports.JsonPropTypes.String:\r\n            return typeof value === \"string\";\r\n    }\r\n    return true;\r\n}\r\nfunction throwIfTypeIsWrong(value, type) {\r\n    if (!checkType(value, type)) {\r\n        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);\r\n    }\r\n}\r\nfunction isConvertible(target) {\r\n    if (target && target.prototype) {\r\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isConvertible(target.prototype);\r\n        }\r\n    }\r\n    else {\r\n        return !!(target && target.toJSON && target.fromJSON);\r\n    }\r\n}\n\nclass JsonSchemaStorage {\r\n    constructor() {\r\n        this.items = new Map();\r\n    }\r\n    has(target) {\r\n        return this.items.has(target) || !!this.findParentSchema(target);\r\n    }\r\n    get(target) {\r\n        const schema = this.items.get(target) || this.findParentSchema(target);\r\n        if (!schema) {\r\n            throw new Error(\"Cannot get schema for current target\");\r\n        }\r\n        return schema;\r\n    }\r\n    create(target) {\r\n        const schema = { names: {} };\r\n        const parentSchema = this.findParentSchema(target);\r\n        if (parentSchema) {\r\n            Object.assign(schema, parentSchema);\r\n            schema.names = {};\r\n            for (const name in parentSchema.names) {\r\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\r\n            }\r\n        }\r\n        schema.target = target;\r\n        return schema;\r\n    }\r\n    set(target, schema) {\r\n        this.items.set(target, schema);\r\n        return this;\r\n    }\r\n    findParentSchema(target) {\r\n        const parent = target.__proto__;\r\n        if (parent) {\r\n            const schema = this.items.get(parent);\r\n            return schema || this.findParentSchema(parent);\r\n        }\r\n        return null;\r\n    }\r\n}\n\nconst DEFAULT_SCHEMA = \"default\";\r\nconst schemaStorage = new JsonSchemaStorage();\n\nclass PatternValidation {\r\n    constructor(pattern) {\r\n        this.pattern = new RegExp(pattern);\r\n    }\r\n    validate(value) {\r\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\r\n        if (typeof value !== \"string\") {\r\n            throw new ValidationError(\"Incoming value must be string\");\r\n        }\r\n        if (!pattern.exec(value)) {\r\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\r\n        }\r\n    }\r\n}\n\nclass InclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\r\n        if (!(this.min <= value && value <= this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\r\n        }\r\n    }\r\n}\n\nclass ExclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\r\n        if (!(this.min < value && value < this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\r\n        }\r\n    }\r\n}\n\nclass LengthValidation {\r\n    constructor(length, minLength, maxLength) {\r\n        this.length = length;\r\n        this.minLength = minLength;\r\n        this.maxLength = maxLength;\r\n    }\r\n    validate(value) {\r\n        if (this.length !== undefined) {\r\n            if (value.length !== this.length) {\r\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\r\n            }\r\n            return;\r\n        }\r\n        if (this.minLength !== undefined) {\r\n            if (value.length < this.minLength) {\r\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\r\n            }\r\n        }\r\n        if (this.maxLength !== undefined) {\r\n            if (value.length > this.maxLength) {\r\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass EnumerationValidation {\r\n    constructor(enumeration) {\r\n        this.enumeration = enumeration;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);\r\n        if (!this.enumeration.includes(value)) {\r\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(\", \")}`);\r\n        }\r\n    }\r\n}\n\nclass JsonTransform {\r\n    static checkValues(data, schemaItem) {\r\n        const values = Array.isArray(data) ? data : [data];\r\n        for (const value of values) {\r\n            for (const validation of schemaItem.validations) {\r\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\r\n                    validation.validate(data);\r\n                }\r\n                else {\r\n                    validation.validate(value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static checkTypes(value, schemaItem) {\r\n        if (schemaItem.repeated && !Array.isArray(value)) {\r\n            throw new TypeError(\"Value must be Array\");\r\n        }\r\n        if (typeof schemaItem.type === \"number\") {\r\n            const values = Array.isArray(value) ? value : [value];\r\n            for (const v of values) {\r\n                throwIfTypeIsWrong(v, schemaItem.type);\r\n            }\r\n        }\r\n    }\r\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\r\n        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };\r\n    }\r\n}\n\nclass JsonSerializer extends JsonTransform {\r\n    static serialize(obj, options, replacer, space) {\r\n        const json = this.toJSON(obj, options);\r\n        return JSON.stringify(json, replacer, space);\r\n    }\r\n    static toJSON(obj, options = {}) {\r\n        let res;\r\n        let targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        if (isConvertible(obj)) {\r\n            return obj.toJSON();\r\n        }\r\n        if (Array.isArray(obj)) {\r\n            res = [];\r\n            for (const item of obj) {\r\n                res.push(this.toJSON(item, options));\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\r\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\r\n            }\r\n            targetSchema = (targetSchema || obj.constructor);\r\n            if (schemaStorage.has(targetSchema)) {\r\n                const schema = schemaStorage.get(targetSchema);\r\n                res = {};\r\n                const namedSchema = this.getSchemaByName(schema, schemaName);\r\n                for (const key in namedSchema) {\r\n                    try {\r\n                        const item = namedSchema[key];\r\n                        const objItem = obj[key];\r\n                        let value;\r\n                        if ((item.optional && objItem === undefined)\r\n                            || (item.defaultValue !== undefined && objItem === item.defaultValue)) {\r\n                            continue;\r\n                        }\r\n                        if (!item.optional && objItem === undefined) {\r\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\r\n                        }\r\n                        if (typeof item.type === \"number\") {\r\n                            if (item.converter) {\r\n                                if (item.repeated) {\r\n                                    value = objItem.map((el) => item.converter.toJSON(el, obj));\r\n                                }\r\n                                else {\r\n                                    value = item.converter.toJSON(objItem, obj);\r\n                                }\r\n                            }\r\n                            else {\r\n                                value = objItem;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (item.repeated) {\r\n                                value = objItem.map((el) => this.toJSON(el, { schemaName }));\r\n                            }\r\n                            else {\r\n                                value = this.toJSON(objItem, { schemaName });\r\n                            }\r\n                        }\r\n                        this.checkTypes(value, item);\r\n                        this.checkValues(value, item);\r\n                        res[item.name || key] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (e instanceof SerializerError) {\r\n                            throw e;\r\n                        }\r\n                        else {\r\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                res = {};\r\n                for (const key in obj) {\r\n                    res[key] = this.toJSON(obj[key], { schemaName });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res = obj;\r\n        }\r\n        return res;\r\n    }\r\n}\n\nclass JsonParser extends JsonTransform {\r\n    static parse(data, options) {\r\n        const obj = JSON.parse(data);\r\n        return this.fromJSON(obj, options);\r\n    }\r\n    static fromJSON(target, options) {\r\n        const targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        const obj = new targetSchema();\r\n        if (isConvertible(obj)) {\r\n            return obj.fromJSON(target);\r\n        }\r\n        const schema = schemaStorage.get(targetSchema);\r\n        const namedSchema = this.getSchemaByName(schema, schemaName);\r\n        const keyErrors = {};\r\n        if (options.strictProperty && !Array.isArray(target)) {\r\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\r\n        }\r\n        for (const key in namedSchema) {\r\n            try {\r\n                const item = namedSchema[key];\r\n                const name = item.name || key;\r\n                const value = target[name];\r\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\r\n                    continue;\r\n                }\r\n                if (!item.optional && value === undefined) {\r\n                    throw new ParserError(schema, `Property '${name}' is required.`);\r\n                }\r\n                this.checkTypes(value, item);\r\n                this.checkValues(value, item);\r\n                if (typeof (item.type) === \"number\") {\r\n                    if (item.converter) {\r\n                        if (item.repeated) {\r\n                            obj[key] = value.map((el) => item.converter.fromJSON(el, obj));\r\n                        }\r\n                        else {\r\n                            obj[key] = item.converter.fromJSON(value, obj);\r\n                        }\r\n                    }\r\n                    else {\r\n                        obj[key] = value;\r\n                    }\r\n                }\r\n                else {\r\n                    const newOptions = {\r\n                        ...options,\r\n                        targetSchema: item.type,\r\n                        schemaName,\r\n                    };\r\n                    if (item.repeated) {\r\n                        obj[key] = value.map((el) => this.fromJSON(el, newOptions));\r\n                    }\r\n                    else {\r\n                        obj[key] = this.fromJSON(value, newOptions);\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof ParserError)) {\r\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\r\n                }\r\n                if (options.strictAllKeys) {\r\n                    keyErrors[key] = e;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const keys = Object.keys(keyErrors);\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys, keyErrors);\r\n        }\r\n        return obj;\r\n    }\r\n    static checkStrictProperty(target, namedSchema, schema) {\r\n        const jsonProps = Object.keys(target);\r\n        const schemaProps = Object.keys(namedSchema);\r\n        const keys = [];\r\n        for (const key of jsonProps) {\r\n            if (schemaProps.indexOf(key) === -1) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys);\r\n        }\r\n    }\r\n}\n\nfunction getValidations(item) {\r\n    const validations = [];\r\n    if (item.pattern) {\r\n        validations.push(new PatternValidation(item.pattern));\r\n    }\r\n    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {\r\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\r\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\r\n        }\r\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\r\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\r\n        }\r\n        if (item.enumeration !== undefined) {\r\n            validations.push(new EnumerationValidation(item.enumeration));\r\n        }\r\n    }\r\n    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {\r\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\r\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\r\n        }\r\n    }\r\n    return validations;\r\n}\r\nconst JsonProp = (options = {}) => (target, propertyKey) => {\r\n    const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\r\n    let schema;\r\n    if (!schemaStorage.has(target.constructor)) {\r\n        schema = schemaStorage.create(target.constructor);\r\n        schemaStorage.set(target.constructor, schema);\r\n    }\r\n    else {\r\n        schema = schemaStorage.get(target.constructor);\r\n        if (schema.target !== target.constructor) {\r\n            schema = schemaStorage.create(target.constructor);\r\n            schemaStorage.set(target.constructor, schema);\r\n        }\r\n    }\r\n    const defaultSchema = {\r\n        type: exports.JsonPropTypes.Any,\r\n        validations: [],\r\n    };\r\n    const copyOptions = Object.assign(defaultSchema, options);\r\n    copyOptions.validations = getValidations(copyOptions);\r\n    if (typeof copyOptions.type !== \"number\") {\r\n        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\r\n            throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\r\n        }\r\n    }\r\n    let schemaNames;\r\n    if (Array.isArray(options.schema)) {\r\n        schemaNames = options.schema;\r\n    }\r\n    else {\r\n        schemaNames = [options.schema || DEFAULT_SCHEMA];\r\n    }\r\n    for (const schemaName of schemaNames) {\r\n        if (!schema.names[schemaName]) {\r\n            schema.names[schemaName] = {};\r\n        }\r\n        const namedSchema = schema.names[schemaName];\r\n        namedSchema[propertyKey] = copyOptions;\r\n    }\r\n};\n\nexports.JsonError = JsonError;\nexports.JsonParser = JsonParser;\nexports.JsonProp = JsonProp;\nexports.JsonSerializer = JsonSerializer;\nexports.KeyError = KeyError;\nexports.ParserError = ParserError;\nexports.SerializerError = SerializerError;\nexports.TransformError = TransformError;\nexports.ValidationError = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9qc29uLXNjaGVtYS9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFtQixZQUFZLFFBQVE7QUFDdkY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVyxZQUFZLFFBQVE7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLHFCQUFxQixLQUFLOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qix1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9qc29uLXNjaGVtYS9idWlsZC9pbmRleC5qcz8xN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDIwLCBQZWN1bGlhciBWZW50dXJlcywgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIEpzb25FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihpbm5lckVycm9yXHJcbiAgICAgICAgICAgID8gYCR7bWVzc2FnZX0uIFNlZSB0aGUgaW5uZXIgZXhjZXB0aW9uIGZvciBtb3JlIGRldGFpbHMuYFxyXG4gICAgICAgICAgICA6IG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5pbm5lckVycm9yID0gaW5uZXJFcnJvcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBUcmFuc2Zvcm1FcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQYXJzZXJFcnJvciBleHRlbmRzIFRyYW5zZm9ybUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKHNjaGVtYSwgYEpTT04gZG9lc24ndCBtYXRjaCB0byAnJHtzY2hlbWEudGFyZ2V0Lm5hbWV9JyBzY2hlbWEuICR7bWVzc2FnZX1gLCBpbm5lckVycm9yKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG59XG5cbmNsYXNzIFNlcmlhbGl6ZXJFcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWFOYW1lLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoYENhbm5vdCBzZXJpYWxpemUgYnkgJyR7c2NoZW1hTmFtZX0nIHNjaGVtYS4gJHttZXNzYWdlfWAsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYU5hbWU7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgS2V5RXJyb3IgZXh0ZW5kcyBQYXJzZXJFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGtleXMsIGVycm9ycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoc2NoZW1hLCBcIlNvbWUga2V5cyBkb2Vzbid0IG1hdGNoIHRvIHNjaGVtYVwiKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG59XG5cbihmdW5jdGlvbiAoSnNvblByb3BUeXBlcykge1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQW55XCJdID0gMF0gPSBcIkFueVwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDFdID0gXCJCb29sZWFuXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJOdW1iZXJcIl0gPSAyXSA9IFwiTnVtYmVyXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XHJcbn0pKGV4cG9ydHMuSnNvblByb3BUeXBlcyB8fCAoZXhwb3J0cy5Kc29uUHJvcFR5cGVzID0ge30pKTtcblxuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5Cb29sZWFuOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXI6XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAoIWNoZWNrVHlwZSh2YWx1ZSwgdHlwZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBWYWx1ZSBtdXN0IGJlICR7ZXhwb3J0cy5Kc29uUHJvcFR5cGVzW3R5cGVdfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29udmVydGlibGUodGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0pTT04gJiYgdGFyZ2V0LnByb3RvdHlwZS5mcm9tSlNPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnZlcnRpYmxlKHRhcmdldC5wcm90b3R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdGFyZ2V0LnRvSlNPTiAmJiB0YXJnZXQuZnJvbUpTT04pO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TY2hlbWFTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBoYXModGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaGFzKHRhcmdldCkgfHwgISF0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGdldCh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghc2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgc2NoZW1hIGZvciBjdXJyZW50IHRhcmdldFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIGNyZWF0ZSh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB7IG5hbWVzOiB7fSB9O1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XHJcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcGFyZW50U2NoZW1hLm5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBzY2hlbWEubmFtZXNbbmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRTY2hlbWEubmFtZXNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjaGVtYS50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIHNldCh0YXJnZXQsIHNjaGVtYSkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0Ll9fcHJvdG9fXztcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHBhcmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfU0NIRU1BID0gXCJkZWZhdWx0XCI7XHJcbmNvbnN0IHNjaGVtYVN0b3JhZ2UgPSBuZXcgSnNvblNjaGVtYVN0b3JhZ2UoKTtcblxuY2xhc3MgUGF0dGVyblZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xyXG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybi5zb3VyY2UsIHRoaXMucGF0dGVybi5mbGFncyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiSW5jb21pbmcgdmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGF0dGVybi5leGVjKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIHBhdHRlcm4gJyR7cGF0dGVybi50b1N0cmluZygpfSdgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSW5jbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcik7XHJcbiAgICAgICAgaWYgKCEodGhpcy5taW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gdGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gXCJNSU5cIiA6IHRoaXMubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLm1heCA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/IFwiTUFYXCIgOiB0aGlzLm1heDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBkaWFwYXNvbiBbJHttaW59LCR7bWF4fV1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRXhjbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcik7XHJcbiAgICAgICAgaWYgKCEodGhpcy5taW4gPCB2YWx1ZSAmJiB2YWx1ZSA8IHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSA/IFwiTUlOXCIgOiB0aGlzLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXggPT09IE51bWJlci5NQVhfVkFMVUUgPyBcIk1BWFwiIDogdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gZGlhcGFzb24gKCR7bWlufSwke21heH0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIExlbmd0aFZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBtaW5MZW5ndGgsIG1heExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gbWluTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgZXhhY3RseSAke3RoaXMubGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgbW9yZSB0aGFuICR7dGhpcy5taW5MZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0aGlzLm1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuICR7dGhpcy5tYXhMZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVudW1lcmF0aW9uVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnVtZXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuZW51bWVyYXRpb24gPSBlbnVtZXJhdGlvbjtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nKTtcclxuICAgICAgICBpZiAoIXRoaXMuZW51bWVyYXRpb24uaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIG11c3QgYmUgb25lIG9mICR7dGhpcy5lbnVtZXJhdGlvbi5tYXAoKHYpID0+IGAnJHt2fSdgKS5qb2luKFwiLCBcIil9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIGNoZWNrVmFsdWVzKGRhdGEsIHNjaGVtYUl0ZW0pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb24gb2Ygc2NoZW1hSXRlbS52YWxpZGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gaW5zdGFuY2VvZiBMZW5ndGhWYWxpZGF0aW9uICYmIHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnZhbGlkYXRlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbi52YWxpZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tUeXBlcyh2YWx1ZSwgc2NoZW1hSXRlbSkge1xyXG4gICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsdWUgbXVzdCBiZSBBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2LCBzY2hlbWFJdGVtLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIG5hbWUgPSBERUZBVUxUX1NDSEVNQSkge1xyXG4gICAgICAgIHJldHVybiB7IC4uLnNjaGVtYS5uYW1lc1tERUZBVUxUX1NDSEVNQV0sIC4uLnNjaGVtYS5uYW1lc1tuYW1lXSB9O1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TZXJpYWxpemVyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgb3B0aW9ucywgcmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHRoaXMudG9KU09OKG9iaiwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24sIHJlcGxhY2VyLCBzcGFjZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdG9KU09OKG9iaiwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgbGV0IHJlcztcclxuICAgICAgICBsZXQgdGFyZ2V0U2NoZW1hID0gb3B0aW9ucy50YXJnZXRTY2hlbWE7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IG9wdGlvbnMuc2NoZW1hTmFtZSB8fCBERUZBVUxUX1NDSEVNQTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9KU09OKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgcmVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMudG9KU09OKGl0ZW0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRTY2hlbWEgJiYgIXNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldFNjaGVtYSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uRXJyb3IoXCJDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgYHRhcmdldFNjaGVtYWAgcGFyYW1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0U2NoZW1hID0gKHRhcmdldFNjaGVtYSB8fCBvYmouY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0U2NoZW1hKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSB0aGlzLmdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIHNjaGVtYU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmFtZWRTY2hlbWFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqSXRlbSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoaXRlbS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmpJdGVtID09PSBpdGVtLmRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3IodGFyZ2V0U2NoZW1hLm5hbWUsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyByZXF1aXJlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLnRvSlNPTihlbCwgb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW0uY29udmVydGVyLnRvSlNPTihvYmpJdGVtLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IHRoaXMudG9KU09OKGVsLCB7IHNjaGVtYU5hbWUgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRvSlNPTihvYmpJdGVtLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpdGVtLm5hbWUgfHwga2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3Ioc2NoZW1hLnRhcmdldC5uYW1lLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgd3JvbmcuICR7ZS5tZXNzYWdlfWAsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IHRoaXMudG9KU09OKG9ialtrZXldLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcyA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uUGFyc2VyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUpTT04ob2JqLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSlNPTih0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTY2hlbWEgPSBvcHRpb25zLnRhcmdldFNjaGVtYTtcclxuICAgICAgICBjb25zdCBzY2hlbWFOYW1lID0gb3B0aW9ucy5zY2hlbWFOYW1lIHx8IERFRkFVTFRfU0NIRU1BO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG5ldyB0YXJnZXRTY2hlbWEoKTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouZnJvbUpTT04odGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHRoaXMuZ2V0U2NoZW1hQnlOYW1lKHNjaGVtYSwgc2NoZW1hTmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5RXJyb3JzID0ge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0UHJvcGVydHkgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBKc29uUGFyc2VyLmNoZWNrU3RyaWN0UHJvcGVydHkodGFyZ2V0LCBuYW1lZFNjaGVtYSwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuYW1lZFNjaGVtYVtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ubmFtZSB8fCBrZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIChpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ub3B0aW9uYWwgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtuYW1lfScgaXMgcmVxdWlyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVHlwZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLmZyb21KU09OKGVsLCBvYmopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gaXRlbS5jb252ZXJ0ZXIuZnJvbUpTT04odmFsdWUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hOiBpdGVtLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IHRoaXMuZnJvbUpTT04oZWwsIG5ld09wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdGhpcy5mcm9tSlNPTih2YWx1ZSwgbmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgUGFyc2VyRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyB3cm9uZy4gJHtlLm1lc3NhZ2V9YCwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3RBbGxLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5RXJyb3JzW2tleV0gPSBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoa2V5RXJyb3JzKTtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKHNjaGVtYSwga2V5cywga2V5RXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja1N0cmljdFByb3BlcnR5KHRhcmdldCwgbmFtZWRTY2hlbWEsIHNjaGVtYSkge1xyXG4gICAgICAgIGNvbnN0IGpzb25Qcm9wcyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hUHJvcHMgPSBPYmplY3Qua2V5cyhuYW1lZFNjaGVtYSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGpzb25Qcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hUHJvcHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihzY2hlbWEsIGtleXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9ucyhpdGVtKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9ucyA9IFtdO1xyXG4gICAgaWYgKGl0ZW0ucGF0dGVybikge1xyXG4gICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IFBhdHRlcm5WYWxpZGF0aW9uKGl0ZW0ucGF0dGVybikpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlciB8fCBpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnkpIHtcclxuICAgICAgICBpZiAoaXRlbS5taW5JbmNsdXNpdmUgIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heEluY2x1c2l2ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEluY2x1c2l2ZVZhbGlkYXRpb24oaXRlbS5taW5JbmNsdXNpdmUsIGl0ZW0ubWF4SW5jbHVzaXZlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLm1pbkV4Y2x1c2l2ZSAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4RXhjbHVzaXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgRXhjbHVzaXZlVmFsaWRhdGlvbihpdGVtLm1pbkV4Y2x1c2l2ZSwgaXRlbS5tYXhFeGNsdXNpdmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZW51bWVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBFbnVtZXJhdGlvblZhbGlkYXRpb24oaXRlbS5lbnVtZXJhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5TdHJpbmcgfHwgaXRlbS5yZXBlYXRlZCB8fCBpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnkpIHtcclxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgTGVuZ3RoVmFsaWRhdGlvbihpdGVtLmxlbmd0aCwgaXRlbS5taW5MZW5ndGgsIGl0ZW0ubWF4TGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkYXRpb25zO1xyXG59XHJcbmNvbnN0IEpzb25Qcm9wID0gKG9wdGlvbnMgPSB7fSkgPT4gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcclxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBDYW5ub3Qgc2V0IHR5cGUgZm9yICR7cHJvcGVydHlLZXl9IHByb3BlcnR5IG9mICR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IHNjaGVtYWA7XHJcbiAgICBsZXQgc2NoZW1hO1xyXG4gICAgaWYgKCFzY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXQuY29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5jcmVhdGUodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBzY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIGlmIChzY2hlbWEudGFyZ2V0ICE9PSB0YXJnZXQuY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5jcmVhdGUodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRTY2hlbWEgPSB7XHJcbiAgICAgICAgdHlwZTogZXhwb3J0cy5Kc29uUHJvcFR5cGVzLkFueSxcclxuICAgICAgICB2YWxpZGF0aW9uczogW10sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29weU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRTY2hlbWEsIG9wdGlvbnMpO1xyXG4gICAgY29weU9wdGlvbnMudmFsaWRhdGlvbnMgPSBnZXRWYWxpZGF0aW9ucyhjb3B5T3B0aW9ucyk7XHJcbiAgICBpZiAodHlwZW9mIGNvcHlPcHRpb25zLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYVN0b3JhZ2UuaGFzKGNvcHlPcHRpb25zLnR5cGUpICYmICFpc0NvbnZlcnRpYmxlKGNvcHlPcHRpb25zLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2V9LiBBc3NpZ25pbmcgdHlwZSBkb2Vzbid0IGhhdmUgc2NoZW1hLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBzY2hlbWFOYW1lcztcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuc2NoZW1hKSkge1xyXG4gICAgICAgIHNjaGVtYU5hbWVzID0gb3B0aW9ucy5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY2hlbWFOYW1lcyA9IFtvcHRpb25zLnNjaGVtYSB8fCBERUZBVUxUX1NDSEVNQV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNjaGVtYU5hbWUgb2Ygc2NoZW1hTmFtZXMpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXSkge1xyXG4gICAgICAgICAgICBzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSBzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV07XHJcbiAgICAgICAgbmFtZWRTY2hlbWFbcHJvcGVydHlLZXldID0gY29weU9wdGlvbnM7XHJcbiAgICB9XHJcbn07XG5cbmV4cG9ydHMuSnNvbkVycm9yID0gSnNvbkVycm9yO1xuZXhwb3J0cy5Kc29uUGFyc2VyID0gSnNvblBhcnNlcjtcbmV4cG9ydHMuSnNvblByb3AgPSBKc29uUHJvcDtcbmV4cG9ydHMuSnNvblNlcmlhbGl6ZXIgPSBKc29uU2VyaWFsaXplcjtcbmV4cG9ydHMuS2V5RXJyb3IgPSBLZXlFcnJvcjtcbmV4cG9ydHMuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcbmV4cG9ydHMuU2VyaWFsaXplckVycm9yID0gU2VyaWFsaXplckVycm9yO1xuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvciA9IFRyYW5zZm9ybUVycm9yO1xuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/json-schema/build/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@peculiar/webcrypto/build/webcrypto.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@peculiar/webcrypto/build/webcrypto.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\n\n\nvar core = __webpack_require__(/*! webcrypto-core */ \"(ssr)/../../node_modules/webcrypto-core/build/webcrypto-core.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar process = __webpack_require__(/*! process */ \"process\");\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/../../node_modules/tslib/tslib.es6.js\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(ssr)/../../node_modules/@peculiar/json-schema/build/index.js\");\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(ssr)/../../node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar core__namespace = /*#__PURE__*/_interopNamespaceDefault(core);\nvar crypto__namespace = /*#__PURE__*/_interopNamespaceDefault(crypto);\nvar process__namespace = /*#__PURE__*/_interopNamespaceDefault(process);\n\nconst JsonBase64UrlConverter = {\r\n    fromJSON: (value) => Buffer.from(pvtsutils.Convert.FromBase64Url(value)),\r\n    toJSON: (value) => pvtsutils.Convert.ToBase64Url(value),\r\n};\n\nclass CryptoKey extends core__namespace.CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.data = Buffer.alloc(0);\r\n        this.algorithm = { name: \"\" };\r\n        this.extractable = false;\r\n        this.type = \"secret\";\r\n        this.usages = [];\r\n        this.kty = \"oct\";\r\n        this.alg = \"\";\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"ext\", type: jsonSchema.JsonPropTypes.Boolean, optional: true })\r\n], CryptoKey.prototype, \"extractable\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"key_ops\", type: jsonSchema.JsonPropTypes.String, repeated: true, optional: true })\r\n], CryptoKey.prototype, \"usages\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String })\r\n], CryptoKey.prototype, \"kty\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, optional: true })\r\n], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.kty = \"oct\";\r\n        this.type = \"secret\";\r\n    }\r\n}\n\nclass AsymmetricKey extends CryptoKey {\r\n}\n\nclass AesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return `A${this.algorithm.length}CBC`;\r\n            case \"AES-CTR\":\r\n                return `A${this.algorithm.length}CTR`;\r\n            case \"AES-GCM\":\r\n                return `A${this.algorithm.length}GCM`;\r\n            case \"AES-KW\":\r\n                return `A${this.algorithm.length}KW`;\r\n            case \"AES-CMAC\":\r\n                return `A${this.algorithm.length}CMAC`;\r\n            case \"AES-ECB\":\r\n                return `A${this.algorithm.length}ECB`;\r\n            default:\r\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], AesCryptoKey.prototype, \"data\", void 0);\n\nconst keyStorage = new WeakMap();\r\nfunction getCryptoKey(key) {\r\n    const res = keyStorage.get(key);\r\n    if (!res) {\r\n        throw new core__namespace.OperationError(\"Cannot get CryptoKey from secure storage\");\r\n    }\r\n    return res;\r\n}\r\nfunction setCryptoKey(value) {\r\n    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\r\n    Object.freeze(key);\r\n    keyStorage.set(key, value);\r\n    return key;\r\n}\n\nclass AesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new AesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new AesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.algorithm.length = key.data.length << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        switch (key.algorithm.length) {\r\n            case 128:\r\n            case 192:\r\n            case 256:\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"keyData: Is wrong key length\");\r\n        }\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptAesCBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesCTR(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCTR(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesGCM(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\r\n            authTagLength: (algorithm.tagLength || 128) >> 3,\r\n        });\r\n        if (algorithm.additionalData) {\r\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesGCM(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\r\n        const tagLength = (algorithm.tagLength || 128) >> 3;\r\n        const enc = data.slice(0, data.length - tagLength);\r\n        const tag = data.slice(data.length - tagLength);\r\n        if (algorithm.additionalData) {\r\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        decipher.setAuthTag(tag);\r\n        let dec = decipher.update(enc);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesKW(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    static async decryptAesKW(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesECB(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesECB(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\r\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nclass AesCbcProvider extends core__namespace.AesCbcProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nconst zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\nconst rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\r\nconst blockSize = 16;\r\nfunction bitShiftLeft(buffer) {\r\n    const shifted = Buffer.alloc(buffer.length);\r\n    const last = buffer.length - 1;\r\n    for (let index = 0; index < last; index++) {\r\n        shifted[index] = buffer[index] << 1;\r\n        if (buffer[index + 1] & 0x80) {\r\n            shifted[index] += 0x01;\r\n        }\r\n    }\r\n    shifted[last] = buffer[last] << 1;\r\n    return shifted;\r\n}\r\nfunction xor(a, b) {\r\n    const length = Math.min(a.length, b.length);\r\n    const output = Buffer.alloc(length);\r\n    for (let index = 0; index < length; index++) {\r\n        output[index] = a[index] ^ b[index];\r\n    }\r\n    return output;\r\n}\r\nfunction aes(key, message) {\r\n    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);\r\n    const result = cipher.update(message);\r\n    cipher.final();\r\n    return result;\r\n}\r\nfunction getMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = start + blockSize;\r\n    message.copy(block, 0, start, end);\r\n    return block;\r\n}\r\nfunction getPaddedMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = message.length;\r\n    block.fill(0);\r\n    message.copy(block, 0, start, end);\r\n    block[end - start] = 0x80;\r\n    return block;\r\n}\r\nfunction generateSubkeys(key) {\r\n    const l = aes(key, zero);\r\n    let subkey1 = bitShiftLeft(l);\r\n    if (l[0] & 0x80) {\r\n        subkey1 = xor(subkey1, rb);\r\n    }\r\n    let subkey2 = bitShiftLeft(subkey1);\r\n    if (subkey1[0] & 0x80) {\r\n        subkey2 = xor(subkey2, rb);\r\n    }\r\n    return { subkey1, subkey2 };\r\n}\r\nfunction aesCmac(key, message) {\r\n    const subkeys = generateSubkeys(key);\r\n    let blockCount = Math.ceil(message.length / blockSize);\r\n    let lastBlockCompleteFlag;\r\n    let lastBlock;\r\n    if (blockCount === 0) {\r\n        blockCount = 1;\r\n        lastBlockCompleteFlag = false;\r\n    }\r\n    else {\r\n        lastBlockCompleteFlag = (message.length % blockSize === 0);\r\n    }\r\n    const lastBlockIndex = blockCount - 1;\r\n    if (lastBlockCompleteFlag) {\r\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\r\n    }\r\n    else {\r\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\r\n    }\r\n    let x = zero;\r\n    let y;\r\n    for (let index = 0; index < lastBlockIndex; index++) {\r\n        y = xor(x, getMessageBlock(message, index));\r\n        x = aes(key, y);\r\n    }\r\n    y = xor(lastBlock, x);\r\n    return aes(key, y);\r\n}\r\nclass AesCmacProvider extends core__namespace.AesCmacProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\r\n        return new Uint8Array(result).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const signature2 = await this.sign(algorithm, key, data);\r\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesCtrProvider extends core__namespace.AesCtrProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesGcmProvider extends core__namespace.AesGcmProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesKwProvider extends core__namespace.AesKwProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesEcbProvider extends core__namespace.AesEcbProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return `DES-CBC`;\r\n            case \"DES-EDE3-CBC\":\r\n                return `3DES-CBC`;\r\n            default:\r\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new DesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new DesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof DesCryptoKey)) {\r\n            throw new Error(\"key: Is not DesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptDesCBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesCBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptDesEDE3CBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesEDE3CBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\n\nclass DesCbcProvider extends core__namespace.DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 64;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesEde3CbcProvider extends core__namespace.DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 192;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-EDE3-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nfunction getJwkAlgorithm(algorithm) {\r\n    switch (algorithm.name.toUpperCase()) {\r\n        case \"RSA-OAEP\": {\r\n            const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\r\n            return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\r\n        }\r\n        case \"RSASSA-PKCS1-V1_5\":\r\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PSS\":\r\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PKCS1\":\r\n            return `RS1`;\r\n        default:\r\n            throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n    }\r\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPrivateKey });\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPublicKey });\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new RsaPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new RsaPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const publicExponent = Buffer.concat([\r\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\r\n            Buffer.from(algorithm.publicExponent),\r\n        ]).readInt32BE(0);\r\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\r\n            modulusLength: algorithm.modulusLength,\r\n            publicExponent,\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.signRsa(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.verifySSA(algorithm, key, data, signature);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.encryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.decryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPrivateKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPublicKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getCryptoAlgorithm(alg) {\r\n        switch (alg.hash.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"RSA-SHA1\";\r\n            case \"SHA-256\":\r\n                return \"RSA-SHA256\";\r\n            case \"SHA-384\":\r\n                return \"RSA-SHA384\";\r\n            case \"SHA-512\":\r\n                return \"RSA-SHA512\";\r\n            case \"SHA3-256\":\r\n                return \"RSA-SHA3-256\";\r\n            case \"SHA3-384\":\r\n                return \"RSA-SHA3-384\";\r\n            case \"SHA3-512\":\r\n                return \"RSA-SHA3-512\";\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm.hash: Is not recognized\");\r\n        }\r\n    }\r\n    static signRsa(algorithm, key, data) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const signature = signer.sign(options);\r\n        return new Uint8Array(signature).buffer;\r\n    }\r\n    static verifySSA(algorithm, key, data, signature) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const ok = signer.verify(options, signature);\r\n        return ok;\r\n    }\r\n    static encryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\r\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\r\n    }\r\n    static decryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\r\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\r\n    }\r\n}\r\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\r\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends core__namespace.RsaSsaProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass RsaPssProvider extends core__namespace.RsaPssProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShaCrypto {\r\n    static size(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return 160;\r\n            case \"SHA-256\":\r\n            case \"SHA3-256\":\r\n                return 256;\r\n            case \"SHA-384\":\r\n            case \"SHA3-384\":\r\n                return 384;\r\n            case \"SHA-512\":\r\n            case \"SHA3-512\":\r\n                return 512;\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static getAlgorithmName(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"sha1\";\r\n            case \"SHA-256\":\r\n                return \"sha256\";\r\n            case \"SHA-384\":\r\n                return \"sha384\";\r\n            case \"SHA-512\":\r\n                return \"sha512\";\r\n            case \"SHA3-256\":\r\n                return \"sha3-256\";\r\n            case \"SHA3-384\":\r\n                return \"sha3-384\";\r\n            case \"SHA3-512\":\r\n                return \"sha3-512\";\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static digest(algorithm, data) {\r\n        const hashAlg = this.getAlgorithmName(algorithm);\r\n        const hash = crypto.createHash(hashAlg)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass RsaOaepProvider extends core__namespace.RsaOaepProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const dataView = new Uint8Array(data);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = dataView.byteLength;\r\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\r\n        if (dataLength > keySize - 2 * hashSize - 2) {\r\n            throw new Error(\"Data too large\");\r\n        }\r\n        const message = new Uint8Array(keySize);\r\n        const seed = message.subarray(1, hashSize + 1);\r\n        const dataBlock = message.subarray(hashSize + 1);\r\n        dataBlock.set(dataView, hashSize + psLength + 1);\r\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        dataBlock.set(labelHash, 0);\r\n        dataBlock[hashSize + psLength] = 1;\r\n        crypto.randomFillSync(seed);\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const pkcs0 = crypto.publicEncrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(message));\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = data.byteLength;\r\n        if (dataLength !== keySize) {\r\n            throw new Error(\"Bad data\");\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        let pkcs0 = crypto.privateDecrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(data));\r\n        const z = pkcs0[0];\r\n        const seed = pkcs0.subarray(1, hashSize + 1);\r\n        const dataBlock = pkcs0.subarray(hashSize + 1);\r\n        if (z !== 0) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        for (let i = 0; i < hashSize; i++) {\r\n            if (labelHash[i] !== dataBlock[i]) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        let psEnd = hashSize;\r\n        for (; psEnd < dataBlock.length; psEnd++) {\r\n            const psz = dataBlock[psEnd];\r\n            if (psz === 1) {\r\n                break;\r\n            }\r\n            if (psz !== 0) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        if (psEnd === dataBlock.length) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        pkcs0 = dataBlock.subarray(psEnd + 1);\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    mgf1(algorithm, seed, length = 0) {\r\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\r\n        const mask = new Uint8Array(length);\r\n        const counter = new Uint8Array(4);\r\n        const chunks = Math.ceil(length / hashSize);\r\n        for (let i = 0; i < chunks; i++) {\r\n            counter[0] = i >>> 24;\r\n            counter[1] = (i >>> 16) & 255;\r\n            counter[2] = (i >>> 8) & 255;\r\n            counter[3] = i & 255;\r\n            const submask = mask.subarray(i * hashSize);\r\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\"))\r\n                .update(seed)\r\n                .update(counter)\r\n                .digest();\r\n            if (chunk.length > submask.length) {\r\n                chunk = chunk.subarray(0, submask.length);\r\n            }\r\n            submask.set(chunk);\r\n        }\r\n        return mask;\r\n    }\r\n}\n\nclass RsaEsProvider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"RSAES-PKCS1-v1_5\";\r\n        this.usages = {\r\n            publicKey: [\"encrypt\", \"wrapKey\"],\r\n            privateKey: [\"decrypt\", \"unwrapKey\"],\r\n        };\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    checkGenerateKeyParams(algorithm) {\r\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\r\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\r\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\r\n        }\r\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\r\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\r\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\r\n        }\r\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\r\n        switch (algorithm.modulusLength) {\r\n            case 1024:\r\n            case 2048:\r\n            case 4096:\r\n                break;\r\n            default:\r\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\r\n        }\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    toCryptoOptions(key) {\r\n        const type = key.type.toUpperCase();\r\n        return {\r\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\r\n            padding: crypto__namespace.constants.RSA_PKCS1_PADDING,\r\n        };\r\n    }\r\n}\n\nconst namedOIDs = {\r\n    \"1.2.840.10045.3.1.7\": \"P-256\",\r\n    \"P-256\": \"1.2.840.10045.3.1.7\",\r\n    \"1.3.132.0.34\": \"P-384\",\r\n    \"P-384\": \"1.3.132.0.34\",\r\n    \"1.3.132.0.35\": \"P-521\",\r\n    \"P-521\": \"1.3.132.0.35\",\r\n    \"1.3.132.0.10\": \"K-256\",\r\n    \"K-256\": \"1.3.132.0.10\",\r\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\r\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\r\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\r\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\r\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\r\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\r\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\r\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\r\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\r\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\r\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\r\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\r\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\r\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\r\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\r\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\r\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\r\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\r\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\r\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\r\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\r\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\r\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\r\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\r\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\r\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\r\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\r\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\",\r\n};\r\nfunction getOidByNamedCurve$1(namedCurve) {\r\n    const oid = namedOIDs[namedCurve];\r\n    if (!oid) {\r\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EcPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPrivateKey });\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EcPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPublicKey });\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass Sha1Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-1\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha256Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha384Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha512Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3256Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3384Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3512Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass EcCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EcPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EcPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const keys = crypto.generateKeyPairSync(\"ec\", {\r\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\r\n        const signer = crypto.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = signer.sign(options);\r\n        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);\r\n        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);\r\n        return signatureRaw.buffer;\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\r\n        const signer = crypto.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ecSignature = new core__namespace.asn1.EcDsaSignature();\r\n        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);\r\n        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);\r\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\r\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\r\n        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));\r\n        const ok = signer.verify(options, ecSignatureRaw);\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\r\n        const ecdh = crypto.createECDH(cryptoAlg);\r\n        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);\r\n        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);\r\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\r\n        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);\r\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\r\n        if (length === null) {\r\n            return bits;\r\n        }\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                const asnKey = new core__namespace.asn1.EcPublicKey(keyData);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\r\n                this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\r\n                this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static assertKeyParameters(parameters, namedCurve) {\r\n        if (!parameters) {\r\n            throw new core__namespace.CryptoError(\"Key info doesn't have required parameters\");\r\n        }\r\n        let namedCurveIdentifier = \"\";\r\n        try {\r\n            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;\r\n        }\r\n        catch (e) {\r\n            throw new core__namespace.CryptoError(\"Cannot read key info parameters\");\r\n        }\r\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\r\n            throw new core__namespace.CryptoError(\"Key info parameter doesn't match to named curve\");\r\n        }\r\n    }\r\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new EcPrivateKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\r\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));\r\n        keyInfo.publicKey = asnKey.value;\r\n        const key = new EcPublicKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getOpenSSLNamedCurve(curve) {\r\n        switch (curve.toUpperCase()) {\r\n            case \"P-256\":\r\n                return \"prime256v1\";\r\n            case \"K-256\":\r\n                return \"secp256k1\";\r\n            case \"P-384\":\r\n                return \"secp384r1\";\r\n            case \"P-521\":\r\n                return \"secp521r1\";\r\n            default:\r\n                return curve;\r\n        }\r\n    }\r\n}\r\nEcCrypto.publicKeyUsages = [\"verify\"];\r\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends core__namespace.EcdsaProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = core__namespace.EcCurves.names;\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass EcdhProvider extends core__namespace.EcdhProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = core__namespace.EcCurves.names;\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n}\n\nconst edOIDs = {\r\n    [core__namespace.asn1.idEd448]: \"Ed448\",\r\n    \"ed448\": core__namespace.asn1.idEd448,\r\n    [core__namespace.asn1.idX448]: \"X448\",\r\n    \"x448\": core__namespace.asn1.idX448,\r\n    [core__namespace.asn1.idEd25519]: \"Ed25519\",\r\n    \"ed25519\": core__namespace.asn1.idEd25519,\r\n    [core__namespace.asn1.idX25519]: \"X25519\",\r\n    \"x25519\": core__namespace.asn1.idX25519,\r\n};\r\nfunction getOidByNamedCurve(namedCurve) {\r\n    const oid = edOIDs[namedCurve.toLowerCase()];\r\n    if (!oid) {\r\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EdPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"OKP\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.CurvePrivateKey });\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EdPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return keyInfo.publicKey;\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"OKP\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, {\r\n            x: pvtsutils.Convert.ToBase64Url(key)\r\n        });\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        if (!json.x) {\r\n            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\r\n        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EdCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EdPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EdPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const type = algorithm.namedCurve.toLowerCase();\r\n        const keys = crypto.generateKeyPairSync(type, {\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = crypto.sign(null, Buffer.from(data), options);\r\n        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const publicKey = crypto.createPublicKey({\r\n            key: algorithm.public.data,\r\n            format: \"der\",\r\n            type: \"spki\",\r\n        });\r\n        const privateKey = crypto.createPrivateKey({\r\n            key: baseKey.data,\r\n            format: \"der\",\r\n            type: \"pkcs8\",\r\n        });\r\n        const bits = crypto.diffieHellman({\r\n            publicKey,\r\n            privateKey,\r\n        });\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.CurvePrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    if (!jwk.x) {\r\n                        throw new TypeError(\"keyData: Cannot get required 'x' filed\");\r\n                    }\r\n                    return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const key = new EdPrivateKey();\r\n        key.fromJSON({\r\n            crv: algorithm.namedCurve,\r\n            d: pvtsutils.Convert.ToBase64Url(asnKey.d),\r\n        });\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const key = new EdPublicKey();\r\n        key.fromJSON({\r\n            crv: algorithm.namedCurve,\r\n            x: pvtsutils.Convert.ToBase64Url(asnKey),\r\n        });\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n}\r\nEdCrypto.publicKeyUsages = [\"verify\"];\r\nEdCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EdDsaProvider extends core__namespace.EdDsaProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EdCrypto.generateKey({\r\n            name: this.name,\r\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\"),\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EdCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n}\n\nclass EcdhEsProvider extends core__namespace.EcdhEsProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EdCrypto.generateKey({\r\n            name: this.name,\r\n            namedCurve: algorithm.namedCurve.toUpperCase(),\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EdCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n}\n\nclass PbkdfCryptoKey extends CryptoKey {\r\n}\n\nclass Pbkdf2Provider extends core__namespace.Pbkdf2Provider {\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        return new Promise((resolve, reject) => {\r\n            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);\r\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\r\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(new Uint8Array(derivedBits).buffer);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format === \"raw\") {\r\n            const key = new PbkdfCryptoKey();\r\n            key.data = Buffer.from(keyData);\r\n            key.algorithm = { name: this.name };\r\n            key.extractable = false;\r\n            key.usages = keyUsages;\r\n            return setCryptoKey(key);\r\n        }\r\n        throw new core__namespace.OperationError(\"format: Must be 'raw'\");\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HmacCryptoKey extends CryptoKey {\r\n    get alg() {\r\n        const hash = this.algorithm.hash.name.toUpperCase();\r\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends core__namespace.HmacProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\r\n        const key = new HmacCryptoKey();\r\n        key.algorithm = {\r\n            ...algorithm,\r\n            length,\r\n            name: this.name,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(length >> 3);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\r\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hmac).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\r\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return hmac.compare(Buffer.from(signature)) === 0;\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new HmacCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = {\r\n            hash: { name: algorithm.hash.name },\r\n            name: this.name,\r\n            length: key.data.length << 3,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onExportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));\r\n            case \"raw\":\r\n                return new Uint8Array(getCryptoKey(key).data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HkdfCryptoKey extends CryptoKey {\r\n}\n\nclass HkdfProvider extends core__namespace.HkdfProvider {\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format.toLowerCase() !== \"raw\") {\r\n            throw new core__namespace.OperationError(\"Operation not supported\");\r\n        }\r\n        const key = new HkdfCryptoKey();\r\n        key.data = Buffer.from(keyData);\r\n        key.algorithm = { name: this.name };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onDeriveBits(params, baseKey, length) {\r\n        const hash = params.hash.name.replace(\"-\", \"\");\r\n        const hashLength = crypto.createHash(hash).digest().length;\r\n        const byteLength = length / 8;\r\n        const info = core.BufferSourceConverter.toUint8Array(params.info);\r\n        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt))\r\n            .update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data))\r\n            .digest();\r\n        const blocks = [Buffer.alloc(0)];\r\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\r\n        for (let i = 1; i < blockCount; ++i) {\r\n            blocks.push(crypto.createHmac(hash, PRK)\r\n                .update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])]))\r\n                .digest());\r\n        }\r\n        return Buffer.concat(blocks).slice(0, byteLength);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShakeCrypto {\r\n    static digest(algorithm, data) {\r\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass Shake128Provider extends core__namespace.Shake128Provider {\r\n    async onDigest(algorithm, data) {\r\n        return ShakeCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Shake256Provider extends core__namespace.Shake256Provider {\r\n    async onDigest(algorithm, data) {\r\n        return ShakeCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass SubtleCrypto extends core__namespace.SubtleCrypto {\r\n    constructor() {\r\n        var _a;\r\n        super();\r\n        this.providers.set(new AesCbcProvider());\r\n        this.providers.set(new AesCtrProvider());\r\n        this.providers.set(new AesGcmProvider());\r\n        this.providers.set(new AesCmacProvider());\r\n        this.providers.set(new AesKwProvider());\r\n        this.providers.set(new AesEcbProvider());\r\n        this.providers.set(new DesCbcProvider());\r\n        this.providers.set(new DesEde3CbcProvider());\r\n        this.providers.set(new RsaSsaProvider());\r\n        this.providers.set(new RsaPssProvider());\r\n        this.providers.set(new RsaOaepProvider());\r\n        this.providers.set(new RsaEsProvider());\r\n        this.providers.set(new EcdsaProvider());\r\n        this.providers.set(new EcdhProvider());\r\n        this.providers.set(new Sha1Provider());\r\n        this.providers.set(new Sha256Provider());\r\n        this.providers.set(new Sha384Provider());\r\n        this.providers.set(new Sha512Provider());\r\n        this.providers.set(new Pbkdf2Provider());\r\n        this.providers.set(new HmacProvider());\r\n        this.providers.set(new HkdfProvider());\r\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];\r\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\r\n            this.providers.set(new Shake128Provider());\r\n            this.providers.set(new Shake256Provider());\r\n        }\r\n        const hashes = crypto__namespace.getHashes();\r\n        if (hashes.includes(\"sha3-256\")) {\r\n            this.providers.set(new Sha3256Provider());\r\n        }\r\n        if (hashes.includes(\"sha3-384\")) {\r\n            this.providers.set(new Sha3384Provider());\r\n        }\r\n        if (hashes.includes(\"sha3-512\")) {\r\n            this.providers.set(new Sha3512Provider());\r\n        }\r\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\r\n            this.providers.set(new EdDsaProvider());\r\n            this.providers.set(new EcdhEsProvider());\r\n        }\r\n    }\r\n}\n\nclass Crypto extends core__namespace.Crypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.subtle = new SubtleCrypto();\r\n    }\r\n    getRandomValues(array) {\r\n        if (!ArrayBuffer.isView(array)) {\r\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\r\n        }\r\n        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);\r\n        crypto.randomFillSync(buffer);\r\n        return array;\r\n    }\r\n}\n\nObject.defineProperty(exports, \"CryptoKey\", ({\n  enumerable: true,\n  get: function () { return core.CryptoKey; }\n}));\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci93ZWJjcnlwdG8vYnVpbGQvd2ViY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsdUZBQWdCO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsd0JBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDBEQUFPO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBVztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBdUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFFQUFxRTtBQUMvRjtBQUNBO0FBQ0EsMEJBQTBCLHdGQUF3RjtBQUNsSDtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUF1RDtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaURBQWlEO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0QkFBNEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsaURBQWlEO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxnREFBZ0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNEQUFzRDtBQUN2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVztBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0RBQW9EO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFLGdDQUFnQztBQUN2RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQyxFQUFDO0FBQ0YsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uanM/ZjNjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiBDb3B5cmlnaHQgKGMpIFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvcmUgPSByZXF1aXJlKCd3ZWJjcnlwdG8tY29yZScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzb25TY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvanNvbi1zY2hlbWEnKTtcbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBhc24xU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2FzbjEtc2NoZW1hJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGNvcmVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoY29yZSk7XG52YXIgY3J5cHRvX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGNyeXB0byk7XG52YXIgcHJvY2Vzc19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChwcm9jZXNzKTtcblxuY29uc3QgSnNvbkJhc2U2NFVybENvbnZlcnRlciA9IHtcclxuICAgIGZyb21KU09OOiAodmFsdWUpID0+IEJ1ZmZlci5mcm9tKHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwodmFsdWUpKSxcclxuICAgIHRvSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh2YWx1ZSksXHJcbn07XG5cbmNsYXNzIENyeXB0b0tleSBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5DcnlwdG9LZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSB7IG5hbWU6IFwiXCIgfTtcclxuICAgICAgICB0aGlzLmV4dHJhY3RhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWNyZXRcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcclxuICAgICAgICB0aGlzLmFsZyA9IFwiXCI7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJleHRcIiwgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLkJvb2xlYW4sIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiZXh0cmFjdGFibGVcIiwgdm9pZCAwKTtcclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrZXlfb3BzXCIsIHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIHJlcGVhdGVkOiB0cnVlLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcInVzYWdlc1wiLCB2b2lkIDApO1xyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwia3R5XCIsIHZvaWQgMCk7XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiYWxnXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFN5bW1ldHJpY0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInNlY3JldFwiO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFzeW1tZXRyaWNLZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG59XG5cbmNsYXNzIEFlc0NyeXB0b0tleSBleHRlbmRzIFN5bW1ldHJpY0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DQkNgO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q1RSYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUdDTWA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtS1dcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUtXYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DTUFDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DTUFDYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUVDQmA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkFsZ29yaXRobUVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIG5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IGFsZyh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia1wiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgfSlcclxuXSwgQWVzQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNvbnN0IGtleVN0b3JhZ2UgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBnZXRDcnlwdG9LZXkoa2V5KSB7XHJcbiAgICBjb25zdCByZXMgPSBrZXlTdG9yYWdlLmdldChrZXkpO1xyXG4gICAgaWYgKCFyZXMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiQ2Fubm90IGdldCBDcnlwdG9LZXkgZnJvbSBzZWN1cmUgc3RvcmFnZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0Q3J5cHRvS2V5KHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvS2V5LmNyZWF0ZSh2YWx1ZS5hbGdvcml0aG0sIHZhbHVlLnR5cGUsIHZhbHVlLmV4dHJhY3RhYmxlLCB2YWx1ZS51c2FnZXMpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShrZXkpO1xyXG4gICAga2V5U3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XG5cbmNsYXNzIEFlc0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEFlc0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhhbGdvcml0aG0ubGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogQWVzQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBBZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5sZW5ndGggPSBrZXkuZGF0YS5sZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAxMjg6XHJcbiAgICAgICAgICAgIGNhc2UgMTkyOlxyXG4gICAgICAgICAgICBjYXNlIDI1NjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IElzIHdyb25nIGtleSBsZW5ndGhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jdHJgLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLmNvdW50ZXIpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWN0cmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uY291bnRlcikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1nY21gLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLml2KSwge1xyXG4gICAgICAgICAgICBhdXRoVGFnTGVuZ3RoOiAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBjaXBoZXIuc2V0QUFEKEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpLCBjaXBoZXIuZ2V0QXV0aFRhZygpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWdjbWAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBjb25zdCB0YWdMZW5ndGggPSAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDM7XHJcbiAgICAgICAgY29uc3QgZW5jID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHRhZ0xlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgdGFnID0gZGF0YS5zbGljZShkYXRhLmxlbmd0aCAtIHRhZ0xlbmd0aCk7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBQUQoQnVmZmVyLmZyb20oYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGVuYyk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgaWQtYWVzJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0td3JhcGAsIGtleS5kYXRhLCB0aGlzLkFFU19LV19JVik7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBpZC1hZXMke2tleS5hbGdvcml0aG0ubGVuZ3RofS13cmFwYCwga2V5LmRhdGEsIHRoaXMuQUVTX0tXX0lWKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZWNiYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KDApKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWVjYmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheSgwKSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cclxuQWVzQ3J5cHRvLkFFU19LV19JViA9IEJ1ZmZlci5mcm9tKFwiQTZBNkE2QTZBNkE2QTZBNlwiLCBcImhleFwiKTtcblxuY2xhc3MgQWVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ2JjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCB6ZXJvID0gQnVmZmVyLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcclxuY29uc3QgcmIgPSBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTM1XSk7XHJcbmNvbnN0IGJsb2NrU2l6ZSA9IDE2O1xyXG5mdW5jdGlvbiBiaXRTaGlmdExlZnQoYnVmZmVyKSB7XHJcbiAgICBjb25zdCBzaGlmdGVkID0gQnVmZmVyLmFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgY29uc3QgbGFzdCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxhc3Q7IGluZGV4KyspIHtcclxuICAgICAgICBzaGlmdGVkW2luZGV4XSA9IGJ1ZmZlcltpbmRleF0gPDwgMTtcclxuICAgICAgICBpZiAoYnVmZmVyW2luZGV4ICsgMV0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgIHNoaWZ0ZWRbaW5kZXhdICs9IDB4MDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2hpZnRlZFtsYXN0XSA9IGJ1ZmZlcltsYXN0XSA8PCAxO1xyXG4gICAgcmV0dXJuIHNoaWZ0ZWQ7XHJcbn1cclxuZnVuY3Rpb24geG9yKGEsIGIpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBvdXRwdXRbaW5kZXhdID0gYVtpbmRleF0gXiBiW2luZGV4XTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuZnVuY3Rpb24gYWVzKGtleSwgbWVzc2FnZSkge1xyXG4gICAgY29uc3QgY2lwaGVyID0gY3J5cHRvX19uYW1lc3BhY2UuY3JlYXRlQ2lwaGVyaXYoYGFlcyR7a2V5Lmxlbmd0aCA8PCAzfWAsIGtleSwgemVybyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBjaXBoZXIudXBkYXRlKG1lc3NhZ2UpO1xyXG4gICAgY2lwaGVyLmZpbmFsKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XHJcbiAgICBjb25zdCBibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBibG9ja0luZGV4ICogYmxvY2tTaXplO1xyXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBibG9ja1NpemU7XHJcbiAgICBtZXNzYWdlLmNvcHkoYmxvY2ssIDAsIHN0YXJ0LCBlbmQpO1xyXG4gICAgcmV0dXJuIGJsb2NrO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XHJcbiAgICBjb25zdCBibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBibG9ja0luZGV4ICogYmxvY2tTaXplO1xyXG4gICAgY29uc3QgZW5kID0gbWVzc2FnZS5sZW5ndGg7XHJcbiAgICBibG9jay5maWxsKDApO1xyXG4gICAgbWVzc2FnZS5jb3B5KGJsb2NrLCAwLCBzdGFydCwgZW5kKTtcclxuICAgIGJsb2NrW2VuZCAtIHN0YXJ0XSA9IDB4ODA7XHJcbiAgICByZXR1cm4gYmxvY2s7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdWJrZXlzKGtleSkge1xyXG4gICAgY29uc3QgbCA9IGFlcyhrZXksIHplcm8pO1xyXG4gICAgbGV0IHN1YmtleTEgPSBiaXRTaGlmdExlZnQobCk7XHJcbiAgICBpZiAobFswXSAmIDB4ODApIHtcclxuICAgICAgICBzdWJrZXkxID0geG9yKHN1YmtleTEsIHJiKTtcclxuICAgIH1cclxuICAgIGxldCBzdWJrZXkyID0gYml0U2hpZnRMZWZ0KHN1YmtleTEpO1xyXG4gICAgaWYgKHN1YmtleTFbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgc3Via2V5MiA9IHhvcihzdWJrZXkyLCByYik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdWJrZXkxLCBzdWJrZXkyIH07XHJcbn1cclxuZnVuY3Rpb24gYWVzQ21hYyhrZXksIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IHN1YmtleXMgPSBnZW5lcmF0ZVN1YmtleXMoa2V5KTtcclxuICAgIGxldCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKG1lc3NhZ2UubGVuZ3RoIC8gYmxvY2tTaXplKTtcclxuICAgIGxldCBsYXN0QmxvY2tDb21wbGV0ZUZsYWc7XHJcbiAgICBsZXQgbGFzdEJsb2NrO1xyXG4gICAgaWYgKGJsb2NrQ291bnQgPT09IDApIHtcclxuICAgICAgICBibG9ja0NvdW50ID0gMTtcclxuICAgICAgICBsYXN0QmxvY2tDb21wbGV0ZUZsYWcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhc3RCbG9ja0NvbXBsZXRlRmxhZyA9IChtZXNzYWdlLmxlbmd0aCAlIGJsb2NrU2l6ZSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYXN0QmxvY2tJbmRleCA9IGJsb2NrQ291bnQgLSAxO1xyXG4gICAgaWYgKGxhc3RCbG9ja0NvbXBsZXRlRmxhZykge1xyXG4gICAgICAgIGxhc3RCbG9jayA9IHhvcihnZXRNZXNzYWdlQmxvY2sobWVzc2FnZSwgbGFzdEJsb2NrSW5kZXgpLCBzdWJrZXlzLnN1YmtleTEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGFzdEJsb2NrID0geG9yKGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBsYXN0QmxvY2tJbmRleCksIHN1YmtleXMuc3Via2V5Mik7XHJcbiAgICB9XHJcbiAgICBsZXQgeCA9IHplcm87XHJcbiAgICBsZXQgeTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsYXN0QmxvY2tJbmRleDsgaW5kZXgrKykge1xyXG4gICAgICAgIHkgPSB4b3IoeCwgZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGluZGV4KSk7XHJcbiAgICAgICAgeCA9IGFlcyhrZXksIHkpO1xyXG4gICAgfVxyXG4gICAgeSA9IHhvcihsYXN0QmxvY2ssIHgpO1xyXG4gICAgcmV0dXJuIGFlcyhrZXksIHkpO1xyXG59XHJcbmNsYXNzIEFlc0NtYWNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNDbWFjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhZXNDbWFjKGdldENyeXB0b0tleShrZXkpLmRhdGEsIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlMiA9IGF3YWl0IHRoaXMuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29tcGFyZShCdWZmZXIuZnJvbShzaWduYXR1cmUyKSkgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzQ3RyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ3RyUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNHY21Qcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNHY21Qcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0t3UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzS3dQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0VjYlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0VjYlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzQ3J5cHRvS2V5IGV4dGVuZHMgU3ltbWV0cmljS2V5IHtcclxuICAgIGdldCBhbGcoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgREVTLUNCQ2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgM0RFUy1DQkNgO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5BbGdvcml0aG1FcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobSBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBhbGcodmFsdWUpIHtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXHJcbl0sIERlc0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jbGFzcyBEZXNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAga2V5LmRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoYWxnb3JpdGhtLmxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogRGVzQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1FREUzLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBEZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1lZGUzLWNiY2AsIGtleS5kYXRhLCBCdWZmZXIuZnJvbShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1lZGUzLWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBEZXNDYmNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5EZXNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua2V5U2l6ZUJpdHMgPSA2NDtcclxuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJERVMtQ0JDXCI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogdGhpcy5uYW1lLCBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgaWYgKGtleS5kYXRhLmxlbmd0aCAhPT0gKHRoaXMua2V5U2l6ZUJpdHMgPj4gMykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IFdyb25nIGtleSBzaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIERlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzRWRlM0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkRlc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5rZXlTaXplQml0cyA9IDE5MjtcclxuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJERVMtRURFMy1DQkNcIjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiB0aGlzLm5hbWUsIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICBpZiAoa2V5LmRhdGEubGVuZ3RoICE9PSAodGhpcy5rZXlTaXplQml0cyA+PiAzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwia2V5RGF0YTogV3Jvbmcga2V5IHNpemVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIERlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgRGVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRKd2tBbGdvcml0aG0oYWxnb3JpdGhtKSB7XHJcbiAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjoge1xyXG4gICAgICAgICAgICBjb25zdCBtZFNpemUgPSAvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGBSU0EtT0FFUCR7bWRTaXplICE9PSBcIjFcIiA/IGAtJHttZFNpemV9YCA6IFwiXCJ9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUlMkey8oXFxkKykkLy5leGVjKGFsZ29yaXRobS5oYXNoLm5hbWUpWzFdfWA7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGBQUyR7LyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV19YDtcclxuICAgICAgICBjYXNlIFwiUlNBLVBLQ1MxXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUlMxYDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJSU0FcIixcclxuICAgICAgICAgICAgYWxnOiBnZXRKd2tBbGdvcml0aG0odGhpcy5hbGdvcml0aG0pLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHVibGljS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIlJTQVwiLFxyXG4gICAgICAgICAgICBhbGc6IGdldEp3a0FsZ29yaXRobSh0aGlzLmFsZ29yaXRobSksXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFJzYVB1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBCdWZmZXIuY29uY2F0KFtcclxuICAgICAgICAgICAgQnVmZmVyLmFsbG9jKDQgLSBhbGdvcml0aG0ucHVibGljRXhwb25lbnQuYnl0ZUxlbmd0aCwgMCksXHJcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCksXHJcbiAgICAgICAgXSkucmVhZEludDMyQkUoMCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwicnNhXCIsIHtcclxuICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGgsXHJcbiAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50LFxyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wdWJsaWNLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduUnNhKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLVBTU1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVNTQShhbGdvcml0aG0sIGtleSwgZGF0YSwgc2lnbmF0dXJlKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ucHVibGljRXhwb25lbnQgPSBuZXcgVWludDhBcnJheShhc25LZXkucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBSc2FQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ucHVibGljRXhwb25lbnQgPSBuZXcgVWludDhBcnJheShhc25LZXkucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0Q3J5cHRvQWxnb3JpdGhtKGFsZykge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnLmhhc2gubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEyNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEE1MTJcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0yNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0zODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy01MTJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG0uaGFzaDogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHNpZ25Sc2EoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlJTQS1QU1NcIikge1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcclxuICAgICAgICAgICAgb3B0aW9ucy5zYWx0TGVuZ3RoID0gYWxnb3JpdGhtLnNhbHRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyB2ZXJpZnlTU0EoYWxnb3JpdGhtLCBrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IHRoaXMuZ2V0Q3J5cHRvQWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUlNBLVBTU1wiKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucGFkZGluZyA9IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BTU19QQURESU5HO1xyXG4gICAgICAgICAgICBvcHRpb25zLnNhbHRMZW5ndGggPSBhbGdvcml0aG0uc2FsdExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2sgPSBzaWduZXIudmVyaWZ5KG9wdGlvbnMsIHNpZ25hdHVyZSk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVuY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgZGF0YSkpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cclxuUnNhQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiLCBcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdO1xyXG5Sc2FDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdO1xuXG5jbGFzcyBSc2FTc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FTc2FQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQc3NQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FQc3NQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFDcnlwdG8ge1xyXG4gICAgc3RhdGljIHNpemUoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2MDtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjU2O1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAzODQ7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDUxMjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGE1MTJcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy01MTJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBkaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaEFsZyA9IHRoaXMuZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChoYXNoQWxnKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYU9hZXBQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FPYWVwUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBNYXRoLmNlaWwoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPj4gMyk7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCkgPj4gMztcclxuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBwc0xlbmd0aCA9IGtleVNpemUgLSBkYXRhTGVuZ3RoIC0gMiAqIGhhc2hTaXplIC0gMjtcclxuICAgICAgICBpZiAoZGF0YUxlbmd0aCA+IGtleVNpemUgLSAyICogaGFzaFNpemUgLSAyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgdG9vIGxhcmdlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoa2V5U2l6ZSk7XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IG1lc3NhZ2Uuc3ViYXJyYXkoMSwgaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBtZXNzYWdlLnN1YmFycmF5KGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgZGF0YUJsb2NrLnNldChkYXRhVmlldywgaGFzaFNpemUgKyBwc0xlbmd0aCArIDEpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgIC51cGRhdGUoY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYWxnb3JpdGhtLmxhYmVsIHx8IG5ldyBVaW50OEFycmF5KDApKSlcclxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgIGRhdGFCbG9jay5zZXQobGFiZWxIYXNoLCAwKTtcclxuICAgICAgICBkYXRhQmxvY2tbaGFzaFNpemUgKyBwc0xlbmd0aF0gPSAxO1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhzZWVkKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2tNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBzZWVkLCBkYXRhQmxvY2subGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZE1hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIGRhdGFCbG9jaywgc2VlZC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xyXG4gICAgICAgICAgICBpbnRlcm5hbEtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2ludGVybmFsS2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGtjczAgPSBjcnlwdG8ucHVibGljRW5jcnlwdCh7XHJcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxLZXkucGVtLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxyXG4gICAgICAgIH0sIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGtjczApLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgY29uc3Qga2V5U2l6ZSA9IE1hdGguY2VpbChpbnRlcm5hbEtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA+PiAzKTtcclxuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IFNoYUNyeXB0by5zaXplKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoKSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGRhdGFMZW5ndGggIT09IGtleVNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGRhdGFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW50ZXJuYWxLZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGludGVybmFsS2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2ludGVybmFsS2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwa2NzMCA9IGNyeXB0by5wcml2YXRlRGVjcnlwdCh7XHJcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxLZXkucGVtLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxyXG4gICAgICAgIH0sIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBjb25zdCB6ID0gcGtjczBbMF07XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IHBrY3MwLnN1YmFycmF5KDEsIGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gcGtjczAuc3ViYXJyYXkoaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBpZiAoeiAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZE1hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIGRhdGFCbG9jaywgc2VlZC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhQmxvY2tNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBzZWVkLCBkYXRhQmxvY2subGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFiZWxIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcclxuICAgICAgICAgICAgLnVwZGF0ZShjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShhbGdvcml0aG0ubGFiZWwgfHwgbmV3IFVpbnQ4QXJyYXkoMCkpKVxyXG4gICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbEhhc2hbaV0gIT09IGRhdGFCbG9ja1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBzRW5kID0gaGFzaFNpemU7XHJcbiAgICAgICAgZm9yICg7IHBzRW5kIDwgZGF0YUJsb2NrLmxlbmd0aDsgcHNFbmQrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwc3ogPSBkYXRhQmxvY2tbcHNFbmRdO1xyXG4gICAgICAgICAgICBpZiAocHN6ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHN6ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHNFbmQgPT09IGRhdGFCbG9jay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBrY3MwID0gZGF0YUJsb2NrLnN1YmFycmF5KHBzRW5kICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBrY3MwKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1nZjEoYWxnb3JpdGhtLCBzZWVkLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShhbGdvcml0aG0pID4+IDM7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChsZW5ndGggLyBoYXNoU2l6ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyWzBdID0gaSA+Pj4gMjQ7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbMV0gPSAoaSA+Pj4gMTYpICYgMjU1O1xyXG4gICAgICAgICAgICBjb3VudGVyWzJdID0gKGkgPj4+IDgpICYgMjU1O1xyXG4gICAgICAgICAgICBjb3VudGVyWzNdID0gaSAmIDI1NTtcclxuICAgICAgICAgICAgY29uc3Qgc3VibWFzayA9IG1hc2suc3ViYXJyYXkoaSAqIGhhc2hTaXplKTtcclxuICAgICAgICAgICAgbGV0IGNodW5rID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKGNvdW50ZXIpXHJcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBzdWJtYXNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJhcnJheSgwLCBzdWJtYXNrLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VibWFzay5zZXQoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFzaztcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0FFUy1QS0NTMS12MV81XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1wiZW5jcnlwdFwiLCBcIndyYXBLZXlcIl0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcImRlY3J5cHRcIiwgXCJ1bndyYXBLZXlcIl0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInB1YmxpY0V4cG9uZW50XCIpO1xyXG4gICAgICAgIGlmICghKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCAmJiBhbGdvcml0aG0ucHVibGljRXhwb25lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE1pc3Npbmcgb3Igbm90IGEgVWludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChhbGdvcml0aG0ucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGlmICghKHB1YmxpY0V4cG9uZW50ID09PSBcIkF3PT1cIiB8fCBwdWJsaWNFeHBvbmVudCA9PT0gXCJBUUFCXCIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTXVzdCBiZSBbM10gb3IgWzEsMCwxXVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm1vZHVsdXNMZW5ndGhcIik7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDEwMjQ6XHJcbiAgICAgICAgICAgIGNhc2UgMjA0ODpcclxuICAgICAgICAgICAgY2FzZSA0MDk2OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibW9kdWx1c0xlbmd0aDogTXVzdCBiZSAxMDI0LCAyMDQ4LCBvciA0MDk2XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRvQ3J5cHRvT3B0aW9ucyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGVuYyA9IGNyeXB0b19fbmFtZXNwYWNlLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRvQ3J5cHRvT3B0aW9ucyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGRlYyA9IGNyeXB0b19fbmFtZXNwYWNlLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvQ3J5cHRvT3B0aW9ucyhrZXkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0ga2V5LnR5cGUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXk6IGAtLS0tLUJFR0lOICR7dHlwZX0gS0VZLS0tLS1cXG4ke2dldENyeXB0b0tleShrZXkpLmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgJHt0eXBlfSBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0b19fbmFtZXNwYWNlLmNvbnN0YW50cy5SU0FfUEtDUzFfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hbWVkT0lEcyA9IHtcclxuICAgIFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiOiBcIlAtMjU2XCIsXHJcbiAgICBcIlAtMjU2XCI6IFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiLFxyXG4gICAgXCIxLjMuMTMyLjAuMzRcIjogXCJQLTM4NFwiLFxyXG4gICAgXCJQLTM4NFwiOiBcIjEuMy4xMzIuMC4zNFwiLFxyXG4gICAgXCIxLjMuMTMyLjAuMzVcIjogXCJQLTUyMVwiLFxyXG4gICAgXCJQLTUyMVwiOiBcIjEuMy4xMzIuMC4zNVwiLFxyXG4gICAgXCIxLjMuMTMyLjAuMTBcIjogXCJLLTI1NlwiLFxyXG4gICAgXCJLLTI1NlwiOiBcIjEuMy4xMzIuMC4xMFwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTYwcjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMVwiOiBcImJyYWlucG9vbFAxNjByMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTYwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiOiBcImJyYWlucG9vbFAxNjB0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTkycjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiOiBcImJyYWlucG9vbFAxOTJyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTkydDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNFwiOiBcImJyYWlucG9vbFAxOTJ0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjI0cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiOiBcImJyYWlucG9vbFAyMjRyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjI0dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiOiBcImJyYWlucG9vbFAyMjR0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjU2cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuN1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuN1wiOiBcImJyYWlucG9vbFAyNTZyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjU2dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiOiBcImJyYWlucG9vbFAyNTZ0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzIwcjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiOiBcImJyYWlucG9vbFAzMjByMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzIwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTBcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEwXCI6IFwiYnJhaW5wb29sUDMyMHQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzODRyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTFcIjogXCJicmFpbnBvb2xQMzg0cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDM4NHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEyXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMlwiOiBcImJyYWlucG9vbFAzODR0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQNTEycjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTNcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEzXCI6IFwiYnJhaW5wb29sUDUxMnIxXCIsXHJcbiAgICBcImJyYWlucG9vbFA1MTJ0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xNFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTRcIjogXCJicmFpbnBvb2xQNTEydDFcIixcclxufTtcclxuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlJDEobmFtZWRDdXJ2ZSkge1xyXG4gICAgY29uc3Qgb2lkID0gbmFtZWRPSURzW25hbWVkQ3VydmVdO1xyXG4gICAgaWYgKCFvaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9pZDtcclxufVxuXG5jbGFzcyBFY1ByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiRUNcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoanNvbi5jcnYpKSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiRUNcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihnZXRPaWRCeU5hbWVkQ3VydmUkMShqc29uLmNydikpKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci50b0FTTihrZXkpLnZhbHVlSGV4O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTFQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTFcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTI1NlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTM4NFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtMzg0XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhNTEyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS01MTJcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtMjU2XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzM4NFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTM4NFwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTM1MTJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy01MTJcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoXCJlY1wiLCB7XHJcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6IHRoaXMuZ2V0T3BlblNTTE5hbWVkQ3VydmUoYWxnb3JpdGhtLm5hbWVkQ3VydmUpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVTaWduKGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24ob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShzaWduYXR1cmUsIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjRHNhU2lnbmF0dXJlKTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVSYXcgPSBjb3JlX19uYW1lc3BhY2UuRWNVdGlscy5lbmNvZGVTaWduYXR1cmUoZWNTaWduYXR1cmUsIGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5nZXQoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKS5zaXplKTtcclxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlUmF3LmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjRHNhU2lnbmF0dXJlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZWRDdXJ2ZSA9IGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5nZXQoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVQb2ludCA9IGNvcmVfX25hbWVzcGFjZS5FY1V0aWxzLmRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUsIG5hbWVkQ3VydmUuc2l6ZSk7XHJcbiAgICAgICAgZWNTaWduYXR1cmUuciA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmVQb2ludC5yKTtcclxuICAgICAgICBlY1NpZ25hdHVyZS5zID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZVBvaW50LnMpO1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlUmF3ID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShlY1NpZ25hdHVyZSkpO1xyXG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBlY1NpZ25hdHVyZVJhdyk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldE9wZW5TU0xOYW1lZEN1cnZlKGJhc2VLZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgIGNvbnN0IGVjZGggPSBjcnlwdG8uY3JlYXRlRUNESChjcnlwdG9BbGcpO1xyXG4gICAgICAgIGNvbnN0IGFzblByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShiYXNlS2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICBjb25zdCBhc25FY1ByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShhc25Qcml2YXRlS2V5LnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgZWNkaC5zZXRQcml2YXRlS2V5KEJ1ZmZlci5mcm9tKGFzbkVjUHJpdmF0ZUtleS5wcml2YXRlS2V5KSk7XHJcbiAgICAgICAgY29uc3QgYXNuUHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYWxnb3JpdGhtLnB1YmxpYy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICBjb25zdCBiaXRzID0gZWNkaC5jb21wdXRlU2VjcmV0KEJ1ZmZlci5mcm9tKGFzblB1YmxpY0tleS5wdWJsaWNLZXkpKTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYml0cykuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCA+PiAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXkuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVibGljS2V5SW5mby5wdWJsaWNLZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCBwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleUluZm8ucHVibGljS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0S2V5UGFyYW1ldGVycyhrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzLCBhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0S2V5UGFyYW1ldGVycyhrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycywgYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCAncGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXNzZXJ0S2V5UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBuYW1lZEN1cnZlKSB7XHJcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvRXJyb3IoXCJLZXkgaW5mbyBkb2Vzbid0IGhhdmUgcmVxdWlyZWQgcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5hbWVkQ3VydmVJZGVudGlmaWVyID0gXCJcIjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBuYW1lZEN1cnZlSWRlbnRpZmllciA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHBhcmFtZXRlcnMsIGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIpLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiQ2Fubm90IHJlYWQga2V5IGluZm8gcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKG5hbWVkQ3VydmUpICE9PSBuYW1lZEN1cnZlSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gcGFyYW1ldGVyIGRvZXNuJ3QgbWF0Y2ggdG8gbmFtZWQgY3VydmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoYWxnb3JpdGhtLm5hbWVkQ3VydmUpKSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAgY29uc3QgbmFtZWRDdXJ2ZSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihuYW1lZEN1cnZlKSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc25LZXkudmFsdWU7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0T3BlblNTTE5hbWVkQ3VydmUoY3VydmUpIHtcclxuICAgICAgICBzd2l0Y2ggKGN1cnZlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlAtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmltZTI1NnYxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJLLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDI1NmsxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDM4NHIxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTUyMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDUyMXIxXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VydmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkVjQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiXTtcclxuRWNDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuXG5jbGFzcyBFY2RzYVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZHNhUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLm5hbWVzO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVjQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1ByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1B1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNkaFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMubmFtZXM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFY0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgRUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBhd2FpdCBFY0NyeXB0by5kZXJpdmVCaXRzKHsgLi4uYWxnb3JpdGhtLCBwdWJsaWM6IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKSB9LCBnZXRDcnlwdG9LZXkoYmFzZUtleSksIGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgZWRPSURzID0ge1xyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQ0NDhdOiBcIkVkNDQ4XCIsXHJcbiAgICBcImVkNDQ4XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQ0NDgsXHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYNDQ4XTogXCJYNDQ4XCIsXHJcbiAgICBcIng0NDhcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYNDQ4LFxyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQyNTUxOV06IFwiRWQyNTUxOVwiLFxyXG4gICAgXCJlZDI1NTE5XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQyNTUxOSxcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFgyNTUxOV06IFwiWDI1NTE5XCIsXHJcbiAgICBcIngyNTUxOVwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFgyNTUxOSxcclxufTtcclxuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlKG5hbWVkQ3VydmUpIHtcclxuICAgIGNvbnN0IG9pZCA9IGVkT0lEc1tuYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgaWYgKCFvaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9pZDtcclxufVxuXG5jbGFzcyBFZFByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiT0tQXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBnZXRPaWRCeU5hbWVkQ3VydmUoanNvbi5jcnYpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFZFB1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBrZXlJbmZvLnB1YmxpY0tleTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJPS1BcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwge1xyXG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChrZXkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWpzb24ueCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IHByb3BlcnR5IGZyb20gSldLLiBQcm9wZXJ0eSAneCcgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gZ2V0T2lkQnlOYW1lZEN1cnZlKGpzb24uY3J2KTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFZENyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBFZFByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVkUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gYWxnb3JpdGhtLm5hbWVkQ3VydmUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmModHlwZSwge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gY3J5cHRvLnNpZ24obnVsbCwgQnVmZmVyLmZyb20oZGF0YSksIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvayA9IGNyeXB0by52ZXJpZnkobnVsbCwgQnVmZmVyLmZyb20oZGF0YSksIG9wdGlvbnMsIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XHJcbiAgICAgICAgICAgIGtleTogYWxnb3JpdGhtLnB1YmxpYy5kYXRhLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XHJcbiAgICAgICAgICAgIGtleTogYmFzZUtleS5kYXRhLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBiaXRzID0gY3J5cHRvLmRpZmZpZUhlbGxtYW4oe1xyXG4gICAgICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpdHMpLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGggPj4gMyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleUluZm8ucHVibGljS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgcGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghandrLngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IENhbm5vdCBnZXQgcmVxdWlyZWQgJ3gnIGZpbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkocHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqd2sueCksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoa2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGtleUluZm8ucHVibGljS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmZyb21KU09OKHtcclxuICAgICAgICAgICAgY3J2OiBhbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAgZDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYXNuS2V5LmQpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZnJvbUpTT04oe1xyXG4gICAgICAgICAgICBjcnY6IGFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChhc25LZXkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxufVxyXG5FZENyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIl07XHJcbkVkQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcblxuY2xhc3MgRWREc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FZERzYVByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBhbGdvcml0aG0ubmFtZWRDdXJ2ZS5yZXBsYWNlKC9eZWQvaSwgXCJFZFwiKSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjZGhFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZGhFc1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBhbGdvcml0aG0ubmFtZWRDdXJ2ZS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBhd2FpdCBFZENyeXB0by5kZXJpdmVCaXRzKHsgLi4uYWxnb3JpdGhtLCBwdWJsaWM6IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKSB9LCBnZXRDcnlwdG9LZXkoYmFzZUtleSksIGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBia2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBQYmtkZjJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5QYmtkZjJQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGFsZ29yaXRobS5zYWx0KTtcclxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIik7XHJcbiAgICAgICAgICAgIGNyeXB0by5wYmtkZjIoZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLmRhdGEsIEJ1ZmZlci5mcm9tKHNhbHQpLCBhbGdvcml0aG0uaXRlcmF0aW9ucywgbGVuZ3RoID4+IDMsIGhhc2gsIChlcnIsIGRlcml2ZWRCaXRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRlcml2ZWRCaXRzKS5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyYXdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgUGJrZGZDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAga2V5LmFsZ29yaXRobSA9IHsgbmFtZTogdGhpcy5uYW1lIH07XHJcbiAgICAgICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ3JhdydcIik7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBQYmtkZkNyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFBCS0RGIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSG1hY0NyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmFsZ29yaXRobS5oYXNoLm5hbWUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gYEhTJHtoYXNoLnJlcGxhY2UoXCJTSEEtXCIsIFwiXCIpfWA7XHJcbiAgICB9XHJcbiAgICBzZXQgYWxnKHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxyXG5dLCBIbWFjQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNsYXNzIEhtYWNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5IbWFjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSAoYWxnb3JpdGhtLmxlbmd0aCB8fCB0aGlzLmdldERlZmF1bHRMZW5ndGgoYWxnb3JpdGhtLmhhc2gubmFtZSkpID4+IDMgPDwgMztcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgSG1hY0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhjcnlwdG9BbGcsIGdldENyeXB0b0tleShrZXkpLmRhdGEpXHJcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLmRpZ2VzdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShobWFjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoY3J5cHRvQWxnLCBnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gaG1hYy5jb21wYXJlKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpID09PSAwO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBIbWFjQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBIbWFjQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0ge1xyXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6IGFsZ29yaXRobS5oYXNoLm5hbWUgfSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGtleS5kYXRhLmxlbmd0aCA8PCAzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGdldENyeXB0b0tleShrZXkpKTtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGdldENyeXB0b0tleShrZXkpLmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgSG1hY0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEhNQUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBIa2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBIa2RmUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuSGtkZlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdC50b0xvd2VyQ2FzZSgpICE9PSBcInJhd1wiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJPcGVyYXRpb24gbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEhrZGZDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7IG5hbWU6IHRoaXMubmFtZSB9O1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKHBhcmFtcywgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IHBhcmFtcy5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIik7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IGNyeXB0by5jcmVhdGVIYXNoKGhhc2gpLmRpZ2VzdCgpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbGVuZ3RoIC8gODtcclxuICAgICAgICBjb25zdCBpbmZvID0gY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBhcmFtcy5pbmZvKTtcclxuICAgICAgICBjb25zdCBQUksgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoLCBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1zLnNhbHQpKVxyXG4gICAgICAgICAgICAudXBkYXRlKGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShnZXRDcnlwdG9LZXkoYmFzZUtleSkuZGF0YSkpXHJcbiAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbQnVmZmVyLmFsbG9jKDApXTtcclxuICAgICAgICBjb25zdCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKGJ5dGVMZW5ndGggLyBoYXNoTGVuZ3RoKSArIDE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaCwgUFJLKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuY29uY2F0KFtibG9ja3NbaSAtIDFdLCBpbmZvLCBCdWZmZXIuZnJvbShbaV0pXSkpXHJcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChibG9ja3MpLnNsaWNlKDAsIGJ5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgSGtkZkNyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEhLREYgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFrZUNyeXB0byB7XHJcbiAgICBzdGF0aWMgZGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpLCB7IG91dHB1dExlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCB9KVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWtlMTI4UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU2hha2UxMjhQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hha2VDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hha2UyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5TaGFrZTI1NlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFrZUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTdWJ0bGVDcnlwdG8gZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU3VidGxlQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNDdHJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0djbVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ21hY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzS3dQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0VjYlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRGVzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBEZXNFZGUzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FTc2FQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYVBzc1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhT2FlcFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhRXNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVjZHNhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RoUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGExUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM4NFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhNTEyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBQYmtkZjJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEhtYWNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEhrZGZQcm92aWRlcigpKTtcclxuICAgICAgICBjb25zdCBub2RlTWFqb3JWZXJzaW9uID0gKF9hID0gL152KFxcZCspLy5leGVjKHByb2Nlc3NfX25hbWVzcGFjZS52ZXJzaW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xyXG4gICAgICAgIGlmIChub2RlTWFqb3JWZXJzaW9uICYmIHBhcnNlSW50KG5vZGVNYWpvclZlcnNpb24sIDEwKSA+PSAxMikge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMTI4UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hha2UyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFzaGVzID0gY3J5cHRvX19uYW1lc3BhY2UuZ2V0SGFzaGVzKCk7XHJcbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtMjU2XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzI1NlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy0zODRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzMzg0UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTUxMlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM1MTJQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGVNYWpvclZlcnNpb24gJiYgcGFyc2VJbnQobm9kZU1ham9yVmVyc2lvbiwgMTApID49IDE0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWREc2FQcm92aWRlcigpKTtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RoRXNQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQ3J5cHRvIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuc3VidGxlID0gbmV3IFN1YnRsZUNyeXB0bygpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmFuZG9tVmFsdWVzKGFycmF5KSB7XHJcbiAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UmFuZG9tVmFsdWVzJyBvbiAnQ3J5cHRvJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0FycmF5QnVmZmVyVmlldydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ3J5cHRvS2V5Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUuQ3J5cHRvS2V5OyB9XG59KTtcbmV4cG9ydHMuQ3J5cHRvID0gQ3J5cHRvO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@peculiar/webcrypto/build/webcrypto.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnConvert = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(rsc)/../../node_modules/pvtsutils/build/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nclass AsnConvert {\n    static serialize(obj) {\n        return serializer_1.AsnSerializer.serialize(obj);\n    }\n    static parse(data, target) {\n        return parser_1.AsnParser.parse(data, target);\n    }\n    static toString(data) {\n        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data) ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);\n        const asn = asn1js.fromBER(buf);\n        if (asn.offset === -1) {\n            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n        }\n        return asn.result.toString();\n    }\n}\nexports.AsnConvert = AsnConvert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUMvQixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxvRUFBVztBQUN2QyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxvRkFBVTtBQUNuQyxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyw0RkFBYztBQUMzQyxNQUFNRjtJQUNGLE9BQU9NLFVBQVVDLEdBQUcsRUFBRTtRQUNsQixPQUFPRixhQUFhRyxhQUFhLENBQUNGLFNBQVMsQ0FBQ0M7SUFDaEQ7SUFDQSxPQUFPRSxNQUFNQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtRQUN2QixPQUFPUCxTQUFTUSxTQUFTLENBQUNILEtBQUssQ0FBQ0MsTUFBTUM7SUFDMUM7SUFDQSxPQUFPRSxTQUFTSCxJQUFJLEVBQUU7UUFDbEIsTUFBTUksTUFBTVgsWUFBWVkscUJBQXFCLENBQUNDLGNBQWMsQ0FBQ04sUUFDdkRQLFlBQVlZLHFCQUFxQixDQUFDRSxhQUFhLENBQUNQLFFBQ2hEVixXQUFXTSxTQUFTLENBQUNJO1FBQzNCLE1BQU1RLE1BQU1qQixPQUFPa0IsT0FBTyxDQUFDTDtRQUMzQixJQUFJSSxJQUFJRSxNQUFNLEtBQUssQ0FBQyxHQUFHO1lBQ25CLE1BQU0sSUFBSUMsTUFBTSxDQUFDLDBCQUEwQixFQUFFSCxJQUFJSSxNQUFNLENBQUNDLEtBQUssQ0FBQyxDQUFDO1FBQ25FO1FBQ0EsT0FBT0wsSUFBSUksTUFBTSxDQUFDVCxRQUFRO0lBQzlCO0FBQ0o7QUFDQWYsa0JBQWtCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2NvbnZlcnQuanM/Y2VlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuQ29udmVydCA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBwdnRzdXRpbHNfMSA9IHJlcXVpcmUoXCJwdnRzdXRpbHNcIik7XG5jb25zdCBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKTtcbmNvbnN0IHNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIik7XG5jbGFzcyBBc25Db252ZXJ0IHtcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaikge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplcl8xLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG9iaik7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShkYXRhLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcl8xLkFzblBhcnNlci5wYXJzZShkYXRhLCB0YXJnZXQpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9TdHJpbmcoZGF0YSkge1xuICAgICAgICBjb25zdCBidWYgPSBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UoZGF0YSlcbiAgICAgICAgICAgID8gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSlcbiAgICAgICAgICAgIDogQXNuQ29udmVydC5zZXJpYWxpemUoZGF0YSk7XG4gICAgICAgIGNvbnN0IGFzbiA9IGFzbjFqcy5mcm9tQkVSKGJ1Zik7XG4gICAgICAgIGlmIChhc24ub2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVjb2RlIEFTTi4xIGRhdGEuICR7YXNuLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNuLnJlc3VsdC50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNuQ29udmVydCA9IEFzbkNvbnZlcnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25Db252ZXJ0IiwiYXNuMWpzIiwicmVxdWlyZSIsInB2dHN1dGlsc18xIiwicGFyc2VyXzEiLCJzZXJpYWxpemVyXzEiLCJzZXJpYWxpemUiLCJvYmoiLCJBc25TZXJpYWxpemVyIiwicGFyc2UiLCJkYXRhIiwidGFyZ2V0IiwiQXNuUGFyc2VyIiwidG9TdHJpbmciLCJidWYiLCJCdWZmZXJTb3VyY2VDb252ZXJ0ZXIiLCJpc0J1ZmZlclNvdXJjZSIsInRvQXJyYXlCdWZmZXIiLCJhc24iLCJmcm9tQkVSIiwib2Zmc2V0IiwiRXJyb3IiLCJyZXN1bHQiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst index_1 = __webpack_require__(/*! ./types/index */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\");\nexports.AsnAnyConverter = {\n    fromASN: (value)=>value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,\n    toASN: (value)=>{\n        if (value === null) {\n            return new asn1js.Null();\n        }\n        const schema = asn1js.fromBER(value);\n        if (schema.result.error) {\n            throw new Error(schema.result.error);\n        }\n        return schema.result;\n    }\n};\nexports.AsnIntegerConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,\n    toASN: (value)=>new asn1js.Integer({\n            value: +value\n        })\n};\nexports.AsnEnumeratedConverter = {\n    fromASN: (value)=>value.valueBlock.valueDec,\n    toASN: (value)=>new asn1js.Enumerated({\n            value\n        })\n};\nexports.AsnIntegerArrayBufferConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.Integer({\n            valueHex: value\n        })\n};\nexports.AsnIntegerBigIntConverter = {\n    fromASN: (value)=>value.toBigInt(),\n    toASN: (value)=>asn1js.Integer.fromBigInt(value)\n};\nexports.AsnBitStringConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.BitString({\n            valueHex: value\n        })\n};\nexports.AsnObjectIdentifierConverter = {\n    fromASN: (value)=>value.valueBlock.toString(),\n    toASN: (value)=>new asn1js.ObjectIdentifier({\n            value\n        })\n};\nexports.AsnBooleanConverter = {\n    fromASN: (value)=>value.valueBlock.value,\n    toASN: (value)=>new asn1js.Boolean({\n            value\n        })\n};\nexports.AsnOctetStringConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.OctetString({\n            valueHex: value\n        })\n};\nexports.AsnConstructedOctetStringConverter = {\n    fromASN: (value)=>new index_1.OctetString(value.getValue()),\n    toASN: (value)=>value.toASN()\n};\nfunction createStringConverter(Asn1Type) {\n    return {\n        fromASN: (value)=>value.valueBlock.value,\n        toASN: (value)=>new Asn1Type({\n                value\n            })\n    };\n}\nexports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);\nexports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);\nexports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);\nexports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);\nexports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);\nexports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);\nexports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);\nexports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);\nexports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);\nexports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);\nexports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);\nexports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);\nexports.AsnUTCTimeConverter = {\n    fromASN: (value)=>value.toDate(),\n    toASN: (value)=>new asn1js.UTCTime({\n            valueDate: value\n        })\n};\nexports.AsnGeneralizedTimeConverter = {\n    fromASN: (value)=>value.toDate(),\n    toASN: (value)=>new asn1js.GeneralizedTime({\n            valueDate: value\n        })\n};\nexports.AsnNullConverter = {\n    fromASN: ()=>null,\n    toASN: ()=>{\n        return new asn1js.Null();\n    }\n};\nfunction defaultConverter(type) {\n    switch(type){\n        case enums_1.AsnPropTypes.Any:\n            return exports.AsnAnyConverter;\n        case enums_1.AsnPropTypes.BitString:\n            return exports.AsnBitStringConverter;\n        case enums_1.AsnPropTypes.BmpString:\n            return exports.AsnBmpStringConverter;\n        case enums_1.AsnPropTypes.Boolean:\n            return exports.AsnBooleanConverter;\n        case enums_1.AsnPropTypes.CharacterString:\n            return exports.AsnCharacterStringConverter;\n        case enums_1.AsnPropTypes.Enumerated:\n            return exports.AsnEnumeratedConverter;\n        case enums_1.AsnPropTypes.GeneralString:\n            return exports.AsnGeneralStringConverter;\n        case enums_1.AsnPropTypes.GeneralizedTime:\n            return exports.AsnGeneralizedTimeConverter;\n        case enums_1.AsnPropTypes.GraphicString:\n            return exports.AsnGraphicStringConverter;\n        case enums_1.AsnPropTypes.IA5String:\n            return exports.AsnIA5StringConverter;\n        case enums_1.AsnPropTypes.Integer:\n            return exports.AsnIntegerConverter;\n        case enums_1.AsnPropTypes.Null:\n            return exports.AsnNullConverter;\n        case enums_1.AsnPropTypes.NumericString:\n            return exports.AsnNumericStringConverter;\n        case enums_1.AsnPropTypes.ObjectIdentifier:\n            return exports.AsnObjectIdentifierConverter;\n        case enums_1.AsnPropTypes.OctetString:\n            return exports.AsnOctetStringConverter;\n        case enums_1.AsnPropTypes.PrintableString:\n            return exports.AsnPrintableStringConverter;\n        case enums_1.AsnPropTypes.TeletexString:\n            return exports.AsnTeletexStringConverter;\n        case enums_1.AsnPropTypes.UTCTime:\n            return exports.AsnUTCTimeConverter;\n        case enums_1.AsnPropTypes.UniversalString:\n            return exports.AsnUniversalStringConverter;\n        case enums_1.AsnPropTypes.Utf8String:\n            return exports.AsnUtf8StringConverter;\n        case enums_1.AsnPropTypes.VideotexString:\n            return exports.AsnVideotexStringConverter;\n        case enums_1.AsnPropTypes.VisibleString:\n            return exports.AsnVisibleStringConverter;\n        default:\n            return null;\n    }\n}\nexports.defaultConverter = defaultConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLHdCQUF3QixHQUFHQSxtQ0FBbUMsR0FBR0EsMkJBQTJCLEdBQUdBLG1DQUFtQyxHQUFHQSxpQ0FBaUMsR0FBR0EsaUNBQWlDLEdBQUdBLGlDQUFpQyxHQUFHQSw2QkFBNkIsR0FBR0Esa0NBQWtDLEdBQUdBLGlDQUFpQyxHQUFHQSxtQ0FBbUMsR0FBR0EsaUNBQWlDLEdBQUdBLG1DQUFtQyxHQUFHQSw2QkFBNkIsR0FBR0EsOEJBQThCLEdBQUdBLDBDQUEwQyxHQUFHQSwrQkFBK0IsR0FBR0EsMkJBQTJCLEdBQUdBLG9DQUFvQyxHQUFHQSw2QkFBNkIsR0FBR0EsaUNBQWlDLEdBQUdBLHNDQUFzQyxHQUFHQSw4QkFBOEIsR0FBR0EsMkJBQTJCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDcjRCLE1BQU00QixTQUFTQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUMvQixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxrRkFBUztBQUNqQyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyw4RkFBZTtBQUN2QzdCLHVCQUF1QixHQUFHO0lBQ3RCZ0MsU0FBUyxDQUFDL0IsUUFBVUEsaUJBQWlCMkIsT0FBT0ssSUFBSSxHQUFHLE9BQU9oQyxNQUFNaUMscUJBQXFCO0lBQ3JGQyxPQUFPLENBQUNsQztRQUNKLElBQUlBLFVBQVUsTUFBTTtZQUNoQixPQUFPLElBQUkyQixPQUFPSyxJQUFJO1FBQzFCO1FBQ0EsTUFBTUcsU0FBU1IsT0FBT1MsT0FBTyxDQUFDcEM7UUFDOUIsSUFBSW1DLE9BQU9FLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTUosT0FBT0UsTUFBTSxDQUFDQyxLQUFLO1FBQ3ZD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UWlCLHNCQUFzQjtRQUN6QyxLQUFLYSxRQUFRNkMsWUFBWSxDQUFDWCxjQUFjO1lBQ3BDLE9BQU9oRSxRQUFRVywwQkFBMEI7UUFDN0MsS0FBS21CLFFBQVE2QyxZQUFZLENBQUNSLGFBQWE7WUFDbkMsT0FBT25FLFFBQVFRLHlCQUF5QjtRQUM1QztZQUNJLE9BQU87SUFDZjtBQUNKO0FBQ0FSLHdCQUF3QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0ZXJzLmpzPzJjZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk51bGxDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlciA9IGV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25WaXNpYmxlU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25HcmFwaGljU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25JQTVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25UZWxldGV4U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuQm1wU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25VdGY4U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25Db25zdHJ1Y3RlZE9jdGV0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlciA9IGV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25JbnRlZ2VyQmlnSW50Q29udmVydGVyID0gZXhwb3J0cy5Bc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkFueUNvbnZlcnRlciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vdHlwZXMvaW5kZXhcIik7XG5leHBvcnRzLkFzbkFueUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgYXNuMWpzLk51bGwgPyBudWxsIDogdmFsdWUudmFsdWVCZWZvcmVEZWNvZGVWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5OdWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gYXNuMWpzLmZyb21CRVIodmFsdWUpO1xuICAgICAgICBpZiAoc2NoZW1hLnJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNjaGVtYS5yZXN1bHQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEucmVzdWx0O1xuICAgIH0sXG59O1xuZXhwb3J0cy5Bc25JbnRlZ2VyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCA+PSA0XG4gICAgICAgID8gdmFsdWUudmFsdWVCbG9jay50b1N0cmluZygpXG4gICAgICAgIDogdmFsdWUudmFsdWVCbG9jay52YWx1ZURlYyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkludGVnZXIoeyB2YWx1ZTogK3ZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuRW51bWVyYXRlZENvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVEZWMsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5FbnVtZXJhdGVkKHsgdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkludGVnZXIoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25JbnRlZ2VyQmlnSW50Q29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9CaWdJbnQoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBhc24xanMuSW50ZWdlci5mcm9tQmlnSW50KHZhbHVlKSxcbn07XG5leHBvcnRzLkFzbkJpdFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuQml0U3RyaW5nKHsgdmFsdWVIZXg6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudG9TdHJpbmcoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLk9iamVjdElkZW50aWZpZXIoeyB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkJvb2xlYW5Db252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuQm9vbGVhbih7IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgdmFsdWVIZXg6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuQ29uc3RydWN0ZWRPY3RldFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IG5ldyBpbmRleF8xLk9jdGV0U3RyaW5nKHZhbHVlLmdldFZhbHVlKCkpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvQVNOKCksXG59O1xuZnVuY3Rpb24gY3JlYXRlU3RyaW5nQ29udmVydGVyKEFzbjFUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgICAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgQXNuMVR5cGUoeyB2YWx1ZSB9KSxcbiAgICB9O1xufVxuZXhwb3J0cy5Bc25VdGY4U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5VdGY4U3RyaW5nKTtcbmV4cG9ydHMuQXNuQm1wU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5CbXBTdHJpbmcpO1xuZXhwb3J0cy5Bc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlVuaXZlcnNhbFN0cmluZyk7XG5leHBvcnRzLkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLk51bWVyaWNTdHJpbmcpO1xuZXhwb3J0cy5Bc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlByaW50YWJsZVN0cmluZyk7XG5leHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlRlbGV0ZXhTdHJpbmcpO1xuZXhwb3J0cy5Bc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVmlkZW90ZXhTdHJpbmcpO1xuZXhwb3J0cy5Bc25JQTVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLklBNVN0cmluZyk7XG5leHBvcnRzLkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkdyYXBoaWNTdHJpbmcpO1xuZXhwb3J0cy5Bc25WaXNpYmxlU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5WaXNpYmxlU3RyaW5nKTtcbmV4cG9ydHMuQXNuR2VuZXJhbFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuR2VuZXJhbFN0cmluZyk7XG5leHBvcnRzLkFzbkNoYXJhY3RlclN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuQ2hhcmFjdGVyU3RyaW5nKTtcbmV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvRGF0ZSgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuVVRDVGltZSh7IHZhbHVlRGF0ZTogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25HZW5lcmFsaXplZFRpbWVDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0RhdGUoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkdlbmVyYWxpemVkVGltZSh7IHZhbHVlRGF0ZTogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25OdWxsQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICgpID0+IG51bGwsXG4gICAgdG9BU046ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuTnVsbCgpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZGVmYXVsdENvbnZlcnRlcih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQW55OlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQW55Q29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJpdFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5CbXBTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQm9vbGVhbjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJvb2xlYW5Db252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQ2hhcmFjdGVyU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkVudW1lcmF0ZWQ6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25FbnVtZXJhdGVkQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdlbmVyYWxTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdlbmVyYWxpemVkVGltZTpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5HcmFwaGljU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5JQTVTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25JQTVTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuSW50ZWdlcjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuTnVsbDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk51bGxDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuTnVtZXJpY1N0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuT2JqZWN0SWRlbnRpZmllcjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk9iamVjdElkZW50aWZpZXJDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5QcmludGFibGVTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVGVsZXRleFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVVRDVGltZTpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblVUQ1RpbWVDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVW5pdmVyc2FsU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlV0ZjhTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25VdGY4U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlZpZGVvdGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVmlzaWJsZVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRDb252ZXJ0ZXIgPSBkZWZhdWx0Q29udmVydGVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdENvbnZlcnRlciIsIkFzbk51bGxDb252ZXJ0ZXIiLCJBc25HZW5lcmFsaXplZFRpbWVDb252ZXJ0ZXIiLCJBc25VVENUaW1lQ29udmVydGVyIiwiQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyIiwiQXNuR2VuZXJhbFN0cmluZ0NvbnZlcnRlciIsIkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIiLCJBc25HcmFwaGljU3RyaW5nQ29udmVydGVyIiwiQXNuSUE1U3RyaW5nQ29udmVydGVyIiwiQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXIiLCJBc25UZWxldGV4U3RyaW5nQ29udmVydGVyIiwiQXNuUHJpbnRhYmxlU3RyaW5nQ29udmVydGVyIiwiQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciIsIkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlciIsIkFzbkJtcFN0cmluZ0NvbnZlcnRlciIsIkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIiLCJBc25Db25zdHJ1Y3RlZE9jdGV0U3RyaW5nQ29udmVydGVyIiwiQXNuT2N0ZXRTdHJpbmdDb252ZXJ0ZXIiLCJBc25Cb29sZWFuQ29udmVydGVyIiwiQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlciIsIkFzbkJpdFN0cmluZ0NvbnZlcnRlciIsIkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIiLCJBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIiLCJBc25FbnVtZXJhdGVkQ29udmVydGVyIiwiQXNuSW50ZWdlckNvbnZlcnRlciIsIkFzbkFueUNvbnZlcnRlciIsImFzbjFqcyIsInJlcXVpcmUiLCJlbnVtc18xIiwiaW5kZXhfMSIsImZyb21BU04iLCJOdWxsIiwidmFsdWVCZWZvcmVEZWNvZGVWaWV3IiwidG9BU04iLCJzY2hlbWEiLCJmcm9tQkVSIiwicmVzdWx0IiwiZXJyb3IiLCJFcnJvciIsInZhbHVlQmxvY2siLCJ2YWx1ZUhleFZpZXciLCJieXRlTGVuZ3RoIiwidG9TdHJpbmciLCJ2YWx1ZURlYyIsIkludGVnZXIiLCJFbnVtZXJhdGVkIiwidmFsdWVIZXgiLCJ0b0JpZ0ludCIsImZyb21CaWdJbnQiLCJCaXRTdHJpbmciLCJPYmplY3RJZGVudGlmaWVyIiwiQm9vbGVhbiIsIk9jdGV0U3RyaW5nIiwiZ2V0VmFsdWUiLCJjcmVhdGVTdHJpbmdDb252ZXJ0ZXIiLCJBc24xVHlwZSIsIlV0ZjhTdHJpbmciLCJCbXBTdHJpbmciLCJVbml2ZXJzYWxTdHJpbmciLCJOdW1lcmljU3RyaW5nIiwiUHJpbnRhYmxlU3RyaW5nIiwiVGVsZXRleFN0cmluZyIsIlZpZGVvdGV4U3RyaW5nIiwiSUE1U3RyaW5nIiwiR3JhcGhpY1N0cmluZyIsIlZpc2libGVTdHJpbmciLCJHZW5lcmFsU3RyaW5nIiwiQ2hhcmFjdGVyU3RyaW5nIiwidG9EYXRlIiwiVVRDVGltZSIsInZhbHVlRGF0ZSIsIkdlbmVyYWxpemVkVGltZSIsInR5cGUiLCJBc25Qcm9wVHlwZXMiLCJBbnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;\nconst converters = __webpack_require__(/*! ./converters */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nconst AsnType = (options)=>(target)=>{\n        let schema;\n        if (!storage_1.schemaStorage.has(target)) {\n            schema = storage_1.schemaStorage.createDefault(target);\n            storage_1.schemaStorage.set(target, schema);\n        } else {\n            schema = storage_1.schemaStorage.get(target);\n        }\n        Object.assign(schema, options);\n    };\nexports.AsnType = AsnType;\nconst AsnChoiceType = ()=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Choice\n    });\nexports.AsnChoiceType = AsnChoiceType;\nconst AsnSetType = (options)=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Set,\n        ...options\n    });\nexports.AsnSetType = AsnSetType;\nconst AsnSequenceType = (options)=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Sequence,\n        ...options\n    });\nexports.AsnSequenceType = AsnSequenceType;\nconst AsnProp = (options)=>(target, propertyKey)=>{\n        let schema;\n        if (!storage_1.schemaStorage.has(target.constructor)) {\n            schema = storage_1.schemaStorage.createDefault(target.constructor);\n            storage_1.schemaStorage.set(target.constructor, schema);\n        } else {\n            schema = storage_1.schemaStorage.get(target.constructor);\n        }\n        const copyOptions = Object.assign({}, options);\n        if (typeof copyOptions.type === \"number\" && !copyOptions.converter) {\n            const defaultConverter = converters.defaultConverter(options.type);\n            if (!defaultConverter) {\n                throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);\n            }\n            copyOptions.converter = defaultConverter;\n        }\n        schema.items[propertyKey] = copyOptions;\n    };\nexports.AsnProp = AsnProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZGVjb3JhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHQSx1QkFBdUIsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUNoSCxNQUFNTyxhQUFhQyxtQkFBT0EsQ0FBQyw0RkFBYztBQUN6QyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxrRkFBUztBQUNqQyxNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQyxzRkFBVztBQUNyQyxNQUFNRixVQUFVLENBQUNLLFVBQVksQ0FBQ0M7UUFDMUIsSUFBSUM7UUFDSixJQUFJLENBQUNILFVBQVVJLGFBQWEsQ0FBQ0MsR0FBRyxDQUFDSCxTQUFTO1lBQ3RDQyxTQUFTSCxVQUFVSSxhQUFhLENBQUNFLGFBQWEsQ0FBQ0o7WUFDL0NGLFVBQVVJLGFBQWEsQ0FBQ0csR0FBRyxDQUFDTCxRQUFRQztRQUN4QyxPQUNLO1lBQ0RBLFNBQVNILFVBQVVJLGFBQWEsQ0FBQ0ksR0FBRyxDQUFDTjtRQUN6QztRQUNBZCxPQUFPcUIsTUFBTSxDQUFDTixRQUFRRjtJQUMxQjtBQUNBWCxlQUFlLEdBQUdNO0FBQ2xCLE1BQU1ELGdCQUFnQixJQUFNLENBQUMsR0FBR0wsUUFBUU0sT0FBTyxFQUFFO1FBQUVjLE1BQU1YLFFBQVFZLFlBQVksQ0FBQ0MsTUFBTTtJQUFDO0FBQ3JGdEIscUJBQXFCLEdBQUdLO0FBQ3hCLE1BQU1ELGFBQWEsQ0FBQ08sVUFBWSxDQUFDLEdBQUdYLFFBQVFNLE9BQU8sRUFBRTtRQUFFYyxNQUFNWCxRQUFRWSxZQUFZLENBQUNFLEdBQUc7UUFBRSxHQUFHWixPQUFPO0lBQUM7QUFDbEdYLGtCQUFrQixHQUFHSTtBQUNyQixNQUFNRCxrQkFBa0IsQ0FBQ1EsVUFBWSxDQUFDLEdBQUdYLFFBQVFNLE9BQU8sRUFBRTtRQUFFYyxNQUFNWCxRQUFRWSxZQUFZLENBQUNHLFFBQVE7UUFBRSxHQUFHYixPQUFPO0lBQUM7QUFDNUdYLHVCQUF1QixHQUFHRztBQUMxQixNQUFNRCxVQUFVLENBQUNTLFVBQVksQ0FBQ0MsUUFBUWE7UUFDbEMsSUFBSVo7UUFDSixJQUFJLENBQUNILFVBQVVJLGFBQWEsQ0FBQ0MsR0FBRyxDQUFDSCxPQUFPYyxXQUFXLEdBQUc7WUFDbERiLFNBQVNILFVBQVVJLGFBQWEsQ0FBQ0UsYUFBYSxDQUFDSixPQUFPYyxXQUFXO1lBQ2pFaEIsVUFBVUksYUFBYSxDQUFDRyxHQUFHLENBQUNMLE9BQU9jLFdBQVcsRUFBRWI7UUFDcEQsT0FDSztZQUNEQSxTQUFTSCxVQUFVSSxhQUFhLENBQUNJLEdBQUcsQ0FBQ04sT0FBT2MsV0FBVztRQUMzRDtRQUNBLE1BQU1DLGNBQWM3QixPQUFPcUIsTUFBTSxDQUFDLENBQUMsR0FBR1I7UUFDdEMsSUFBSSxPQUFPZ0IsWUFBWVAsSUFBSSxLQUFLLFlBQVksQ0FBQ08sWUFBWUMsU0FBUyxFQUFFO1lBQ2hFLE1BQU1DLG1CQUFtQnRCLFdBQVdzQixnQkFBZ0IsQ0FBQ2xCLFFBQVFTLElBQUk7WUFDakUsSUFBSSxDQUFDUyxrQkFBa0I7Z0JBQ25CLE1BQU0sSUFBSUMsTUFBTSxDQUFDLDJDQUEyQyxFQUFFTCxZQUFZLEtBQUssRUFBRWIsT0FBT2MsV0FBVyxDQUFDSyxJQUFJLENBQUMsQ0FBQztZQUM5RztZQUNBSixZQUFZQyxTQUFTLEdBQUdDO1FBQzVCO1FBQ0FoQixPQUFPbUIsS0FBSyxDQUFDUCxZQUFZLEdBQUdFO0lBQ2hDO0FBQ0EzQixlQUFlLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2RlY29yYXRvcnMuanM/MzNjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuUHJvcCA9IGV4cG9ydHMuQXNuU2VxdWVuY2VUeXBlID0gZXhwb3J0cy5Bc25TZXRUeXBlID0gZXhwb3J0cy5Bc25DaG9pY2VUeXBlID0gZXhwb3J0cy5Bc25UeXBlID0gdm9pZCAwO1xuY29uc3QgY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlXCIpO1xuY29uc3QgQXNuVHlwZSA9IChvcHRpb25zKSA9PiAodGFyZ2V0KSA9PiB7XG4gICAgbGV0IHNjaGVtYTtcbiAgICBpZiAoIXN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXQpKSB7XG4gICAgICAgIHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmNyZWF0ZURlZmF1bHQodGFyZ2V0KTtcbiAgICAgICAgc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2Uuc2V0KHRhcmdldCwgc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHNjaGVtYSwgb3B0aW9ucyk7XG59O1xuZXhwb3J0cy5Bc25UeXBlID0gQXNuVHlwZTtcbmNvbnN0IEFzbkNob2ljZVR5cGUgPSAoKSA9PiAoMCwgZXhwb3J0cy5Bc25UeXBlKSh7IHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KTtcbmV4cG9ydHMuQXNuQ2hvaWNlVHlwZSA9IEFzbkNob2ljZVR5cGU7XG5jb25zdCBBc25TZXRUeXBlID0gKG9wdGlvbnMpID0+ICgwLCBleHBvcnRzLkFzblR5cGUpKHsgdHlwZTogZW51bXNfMS5Bc25UeXBlVHlwZXMuU2V0LCAuLi5vcHRpb25zIH0pO1xuZXhwb3J0cy5Bc25TZXRUeXBlID0gQXNuU2V0VHlwZTtcbmNvbnN0IEFzblNlcXVlbmNlVHlwZSA9IChvcHRpb25zKSA9PiAoMCwgZXhwb3J0cy5Bc25UeXBlKSh7IHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlLCAuLi5vcHRpb25zIH0pO1xuZXhwb3J0cy5Bc25TZXF1ZW5jZVR5cGUgPSBBc25TZXF1ZW5jZVR5cGU7XG5jb25zdCBBc25Qcm9wID0gKG9wdGlvbnMpID0+ICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XG4gICAgbGV0IHNjaGVtYTtcbiAgICBpZiAoIXN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXQuY29uc3RydWN0b3IpKSB7XG4gICAgICAgIHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmNyZWF0ZURlZmF1bHQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2Uuc2V0KHRhcmdldC5jb25zdHJ1Y3Rvciwgc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBjb3B5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgY29weU9wdGlvbnMudHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhY29weU9wdGlvbnMuY29udmVydGVyKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzLmRlZmF1bHRDb252ZXJ0ZXIob3B0aW9ucy50eXBlKTtcbiAgICAgICAgaWYgKCFkZWZhdWx0Q29udmVydGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIHByb3BlcnR5ICcke3Byb3BlcnR5S2V5fScgb2YgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5T3B0aW9ucy5jb252ZXJ0ZXIgPSBkZWZhdWx0Q29udmVydGVyO1xuICAgIH1cbiAgICBzY2hlbWEuaXRlbXNbcHJvcGVydHlLZXldID0gY29weU9wdGlvbnM7XG59O1xuZXhwb3J0cy5Bc25Qcm9wID0gQXNuUHJvcDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblByb3AiLCJBc25TZXF1ZW5jZVR5cGUiLCJBc25TZXRUeXBlIiwiQXNuQ2hvaWNlVHlwZSIsIkFzblR5cGUiLCJjb252ZXJ0ZXJzIiwicmVxdWlyZSIsImVudW1zXzEiLCJzdG9yYWdlXzEiLCJvcHRpb25zIiwidGFyZ2V0Iiwic2NoZW1hIiwic2NoZW1hU3RvcmFnZSIsImhhcyIsImNyZWF0ZURlZmF1bHQiLCJzZXQiLCJnZXQiLCJhc3NpZ24iLCJ0eXBlIiwiQXNuVHlwZVR5cGVzIiwiQ2hvaWNlIiwiU2V0IiwiU2VxdWVuY2UiLCJwcm9wZXJ0eUtleSIsImNvbnN0cnVjdG9yIiwiY29weU9wdGlvbnMiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0Q29udmVydGVyIiwiRXJyb3IiLCJuYW1lIiwiaXRlbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnPropTypes = exports.AsnTypeTypes = void 0;\nvar AsnTypeTypes;\n(function(AsnTypeTypes) {\n    AsnTypeTypes[AsnTypeTypes[\"Sequence\"] = 0] = \"Sequence\";\n    AsnTypeTypes[AsnTypeTypes[\"Set\"] = 1] = \"Set\";\n    AsnTypeTypes[AsnTypeTypes[\"Choice\"] = 2] = \"Choice\";\n})(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function(AsnPropTypes) {\n    AsnPropTypes[AsnPropTypes[\"Any\"] = 1] = \"Any\";\n    AsnPropTypes[AsnPropTypes[\"Boolean\"] = 2] = \"Boolean\";\n    AsnPropTypes[AsnPropTypes[\"OctetString\"] = 3] = \"OctetString\";\n    AsnPropTypes[AsnPropTypes[\"BitString\"] = 4] = \"BitString\";\n    AsnPropTypes[AsnPropTypes[\"Integer\"] = 5] = \"Integer\";\n    AsnPropTypes[AsnPropTypes[\"Enumerated\"] = 6] = \"Enumerated\";\n    AsnPropTypes[AsnPropTypes[\"ObjectIdentifier\"] = 7] = \"ObjectIdentifier\";\n    AsnPropTypes[AsnPropTypes[\"Utf8String\"] = 8] = \"Utf8String\";\n    AsnPropTypes[AsnPropTypes[\"BmpString\"] = 9] = \"BmpString\";\n    AsnPropTypes[AsnPropTypes[\"UniversalString\"] = 10] = \"UniversalString\";\n    AsnPropTypes[AsnPropTypes[\"NumericString\"] = 11] = \"NumericString\";\n    AsnPropTypes[AsnPropTypes[\"PrintableString\"] = 12] = \"PrintableString\";\n    AsnPropTypes[AsnPropTypes[\"TeletexString\"] = 13] = \"TeletexString\";\n    AsnPropTypes[AsnPropTypes[\"VideotexString\"] = 14] = \"VideotexString\";\n    AsnPropTypes[AsnPropTypes[\"IA5String\"] = 15] = \"IA5String\";\n    AsnPropTypes[AsnPropTypes[\"GraphicString\"] = 16] = \"GraphicString\";\n    AsnPropTypes[AsnPropTypes[\"VisibleString\"] = 17] = \"VisibleString\";\n    AsnPropTypes[AsnPropTypes[\"GeneralString\"] = 18] = \"GeneralString\";\n    AsnPropTypes[AsnPropTypes[\"CharacterString\"] = 19] = \"CharacterString\";\n    AsnPropTypes[AsnPropTypes[\"UTCTime\"] = 20] = \"UTCTime\";\n    AsnPropTypes[AsnPropTypes[\"GeneralizedTime\"] = 21] = \"GeneralizedTime\";\n    AsnPropTypes[AsnPropTypes[\"DATE\"] = 22] = \"DATE\";\n    AsnPropTypes[AsnPropTypes[\"TimeOfDay\"] = 23] = \"TimeOfDay\";\n    AsnPropTypes[AsnPropTypes[\"DateTime\"] = 24] = \"DateTime\";\n    AsnPropTypes[AsnPropTypes[\"Duration\"] = 25] = \"Duration\";\n    AsnPropTypes[AsnPropTypes[\"TIME\"] = 26] = \"TIME\";\n    AsnPropTypes[AsnPropTypes[\"Null\"] = 27] = \"Null\";\n})(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZW51bXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQ25ELElBQUlHO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUM3Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUN4Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUMvQyxHQUFHQSxlQUFlSCxRQUFRRyxZQUFZLElBQUtILENBQUFBLG9CQUFvQixHQUFHLENBQUM7QUFDbkUsSUFBSUU7QUFDSCxVQUFVQSxZQUFZO0lBQ25CQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQ3hDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQ2hEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQy9DQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDL0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDOUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ25EQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUNuREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxHQUFHO0lBQ3BEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxZQUFZLEdBQUcsR0FBRyxHQUFHO0lBQy9DQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUNuREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ25EQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDN0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUMvQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUM5Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUM5Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUM5QyxHQUFHQSxlQUFlRixRQUFRRSxZQUFZLElBQUtGLENBQUFBLG9CQUFvQixHQUFHLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZW51bXMuanM/OGM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuUHJvcFR5cGVzID0gZXhwb3J0cy5Bc25UeXBlVHlwZXMgPSB2b2lkIDA7XG52YXIgQXNuVHlwZVR5cGVzO1xuKGZ1bmN0aW9uIChBc25UeXBlVHlwZXMpIHtcbiAgICBBc25UeXBlVHlwZXNbQXNuVHlwZVR5cGVzW1wiU2VxdWVuY2VcIl0gPSAwXSA9IFwiU2VxdWVuY2VcIjtcbiAgICBBc25UeXBlVHlwZXNbQXNuVHlwZVR5cGVzW1wiU2V0XCJdID0gMV0gPSBcIlNldFwiO1xuICAgIEFzblR5cGVUeXBlc1tBc25UeXBlVHlwZXNbXCJDaG9pY2VcIl0gPSAyXSA9IFwiQ2hvaWNlXCI7XG59KShBc25UeXBlVHlwZXMgPSBleHBvcnRzLkFzblR5cGVUeXBlcyB8fCAoZXhwb3J0cy5Bc25UeXBlVHlwZXMgPSB7fSkpO1xudmFyIEFzblByb3BUeXBlcztcbihmdW5jdGlvbiAoQXNuUHJvcFR5cGVzKSB7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkFueVwiXSA9IDFdID0gXCJBbnlcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDJdID0gXCJCb29sZWFuXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk9jdGV0U3RyaW5nXCJdID0gM10gPSBcIk9jdGV0U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJpdFN0cmluZ1wiXSA9IDRdID0gXCJCaXRTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiSW50ZWdlclwiXSA9IDVdID0gXCJJbnRlZ2VyXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkVudW1lcmF0ZWRcIl0gPSA2XSA9IFwiRW51bWVyYXRlZFwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJPYmplY3RJZGVudGlmaWVyXCJdID0gN10gPSBcIk9iamVjdElkZW50aWZpZXJcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVXRmOFN0cmluZ1wiXSA9IDhdID0gXCJVdGY4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJtcFN0cmluZ1wiXSA9IDldID0gXCJCbXBTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVW5pdmVyc2FsU3RyaW5nXCJdID0gMTBdID0gXCJVbml2ZXJzYWxTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiTnVtZXJpY1N0cmluZ1wiXSA9IDExXSA9IFwiTnVtZXJpY1N0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJQcmludGFibGVTdHJpbmdcIl0gPSAxMl0gPSBcIlByaW50YWJsZVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUZWxldGV4U3RyaW5nXCJdID0gMTNdID0gXCJUZWxldGV4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlZpZGVvdGV4U3RyaW5nXCJdID0gMTRdID0gXCJWaWRlb3RleFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJJQTVTdHJpbmdcIl0gPSAxNV0gPSBcIklBNVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJHcmFwaGljU3RyaW5nXCJdID0gMTZdID0gXCJHcmFwaGljU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlZpc2libGVTdHJpbmdcIl0gPSAxN10gPSBcIlZpc2libGVTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiR2VuZXJhbFN0cmluZ1wiXSA9IDE4XSA9IFwiR2VuZXJhbFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJDaGFyYWN0ZXJTdHJpbmdcIl0gPSAxOV0gPSBcIkNoYXJhY3RlclN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVVENUaW1lXCJdID0gMjBdID0gXCJVVENUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkdlbmVyYWxpemVkVGltZVwiXSA9IDIxXSA9IFwiR2VuZXJhbGl6ZWRUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkRBVEVcIl0gPSAyMl0gPSBcIkRBVEVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVGltZU9mRGF5XCJdID0gMjNdID0gXCJUaW1lT2ZEYXlcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRGF0ZVRpbWVcIl0gPSAyNF0gPSBcIkRhdGVUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkR1cmF0aW9uXCJdID0gMjVdID0gXCJEdXJhdGlvblwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUSU1FXCJdID0gMjZdID0gXCJUSU1FXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk51bGxcIl0gPSAyN10gPSBcIk51bGxcIjtcbn0pKEFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuUHJvcFR5cGVzIHx8IChleHBvcnRzLkFzblByb3BUeXBlcyA9IHt9KSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25Qcm9wVHlwZXMiLCJBc25UeXBlVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/../../node_modules/tslib/tslib.es6.js\");\ntslib_1.__exportStar(__webpack_require__(/*! ./schema_validation */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLDBEQUFPO0FBQy9CRCxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLGlIQUFxQixHQUFHSCIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvaW5kZXguanM/MmYzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFfdmFsaWRhdGlvblwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYl8xIiwicmVxdWlyZSIsIl9fZXhwb3J0U3RhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSchemaValidationError = void 0;\nclass AsnSchemaValidationError extends Error {\n    constructor(){\n        super(...arguments);\n        this.schemas = [];\n    }\n}\nexports.AsnSchemaValidationError = AsnSchemaValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL3NjaGVtYV92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1FLGlDQUFpQ0M7SUFDbkNDLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtJQUNyQjtBQUNKO0FBQ0FOLGdDQUFnQyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvc2NoZW1hX3ZhbGlkYXRpb24uanM/ZDc3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yID0gdm9pZCAwO1xuY2xhc3MgQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBbXTtcbiAgICB9XG59XG5leHBvcnRzLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvciA9IEFzblNjaGVtYVZhbGlkYXRpb25FcnJvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblNjaGVtYVZhbGlkYXRpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJzY2hlbWFzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;\nfunction isConvertible(target) {\n    if (typeof target === \"function\" && target.prototype) {\n        if (target.prototype.toASN && target.prototype.fromASN) {\n            return true;\n        } else {\n            return isConvertible(target.prototype);\n        }\n    } else {\n        return !!(target && typeof target === \"object\" && \"toASN\" in target && \"fromASN\" in target);\n    }\n}\nexports.isConvertible = isConvertible;\nfunction isTypeOfArray(target) {\n    var _a;\n    if (target) {\n        const proto = Object.getPrototypeOf(target);\n        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {\n            return true;\n        }\n        return isTypeOfArray(proto);\n    }\n    return false;\n}\nexports.isTypeOfArray = isTypeOfArray;\nfunction isArrayEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for(let i = 0; i < bytes1.byteLength; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EscUJBQXFCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDNUUsU0FBU0ksY0FBY0MsTUFBTTtJQUN6QixJQUFJLE9BQU9BLFdBQVcsY0FBY0EsT0FBT0MsU0FBUyxFQUFFO1FBQ2xELElBQUlELE9BQU9DLFNBQVMsQ0FBQ0MsS0FBSyxJQUFJRixPQUFPQyxTQUFTLENBQUNFLE9BQU8sRUFBRTtZQUNwRCxPQUFPO1FBQ1gsT0FDSztZQUNELE9BQU9KLGNBQWNDLE9BQU9DLFNBQVM7UUFDekM7SUFDSixPQUNLO1FBQ0QsT0FBTyxDQUFDLENBQUVELENBQUFBLFVBQVUsT0FBT0EsV0FBVyxZQUFZLFdBQVdBLFVBQVUsYUFBYUEsTUFBSztJQUM3RjtBQUNKO0FBQ0FMLHFCQUFxQixHQUFHSTtBQUN4QixTQUFTRCxjQUFjRSxNQUFNO0lBQ3pCLElBQUlJO0lBQ0osSUFBSUosUUFBUTtRQUNSLE1BQU1LLFFBQVFaLE9BQU9hLGNBQWMsQ0FBQ047UUFDcEMsSUFBSSxDQUFDLENBQUNJLEtBQUtDLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNSixTQUFTLE1BQU0sUUFBUUcsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxXQUFXLE1BQU1DLE9BQU87WUFDdEksT0FBTztRQUNYO1FBQ0EsT0FBT1YsY0FBY087SUFDekI7SUFDQSxPQUFPO0FBQ1g7QUFDQVYscUJBQXFCLEdBQUdHO0FBQ3hCLFNBQVNELGFBQWFZLE1BQU0sRUFBRUMsTUFBTTtJQUNoQyxJQUFJLENBQUVELENBQUFBLFVBQVVDLE1BQUssR0FBSTtRQUNyQixPQUFPO0lBQ1g7SUFDQSxJQUFJRCxPQUFPRSxVQUFVLEtBQUtELE9BQU9DLFVBQVUsRUFBRTtRQUN6QyxPQUFPO0lBQ1g7SUFDQSxNQUFNQyxLQUFLLElBQUlDLFdBQVdKO0lBQzFCLE1BQU1LLEtBQUssSUFBSUQsV0FBV0g7SUFDMUIsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlOLE9BQU9FLFVBQVUsRUFBRUksSUFBSztRQUN4QyxJQUFJSCxFQUFFLENBQUNHLEVBQUUsS0FBS0QsRUFBRSxDQUFDQyxFQUFFLEVBQUU7WUFDakIsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQXBCLG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9oZWxwZXIuanM/ODA0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gZXhwb3J0cy5pc1R5cGVPZkFycmF5ID0gZXhwb3J0cy5pc0NvbnZlcnRpYmxlID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNDb252ZXJ0aWJsZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUudG9BU04gJiYgdGFyZ2V0LnByb3RvdHlwZS5mcm9tQVNOKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnZlcnRpYmxlKHRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gISEodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIgJiYgXCJ0b0FTTlwiIGluIHRhcmdldCAmJiBcImZyb21BU05cIiBpbiB0YXJnZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNDb252ZXJ0aWJsZSA9IGlzQ29udmVydGlibGU7XG5mdW5jdGlvbiBpc1R5cGVPZkFycmF5KHRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIGlmICgoKF9hID0gcHJvdG8gPT09IG51bGwgfHwgcHJvdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3RvLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN0cnVjdG9yKSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1R5cGVPZkFycmF5KHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1R5cGVPZkFycmF5ID0gaXNUeXBlT2ZBcnJheTtcbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChieXRlczEsIGJ5dGVzMikge1xuICAgIGlmICghKGJ5dGVzMSAmJiBieXRlczIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzMS5ieXRlTGVuZ3RoICE9PSBieXRlczIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMxKTtcbiAgICBjb25zdCBiMiA9IG5ldyBVaW50OEFycmF5KGJ5dGVzMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gaXNBcnJheUVxdWFsO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNBcnJheUVxdWFsIiwiaXNUeXBlT2ZBcnJheSIsImlzQ29udmVydGlibGUiLCJ0YXJnZXQiLCJwcm90b3R5cGUiLCJ0b0FTTiIsImZyb21BU04iLCJfYSIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIkFycmF5IiwiYnl0ZXMxIiwiYnl0ZXMyIiwiYnl0ZUxlbmd0aCIsImIxIiwiVWludDhBcnJheSIsImIyIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/../../node_modules/tslib/tslib.es6.js\");\ntslib_1.__exportStar(__webpack_require__(/*! ./converters */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./types/index */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\"), exports);\nvar decorators_1 = __webpack_require__(/*! ./decorators */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\");\nObject.defineProperty(exports, \"AsnProp\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnProp;\n    }\n}));\nObject.defineProperty(exports, \"AsnType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnType;\n    }\n}));\nObject.defineProperty(exports, \"AsnChoiceType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnChoiceType;\n    }\n}));\nObject.defineProperty(exports, \"AsnSequenceType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnSequenceType;\n    }\n}));\nObject.defineProperty(exports, \"AsnSetType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnSetType;\n    }\n}));\nvar enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nObject.defineProperty(exports, \"AsnTypeTypes\", ({\n    enumerable: true,\n    get: function() {\n        return enums_1.AsnTypeTypes;\n    }\n}));\nObject.defineProperty(exports, \"AsnPropTypes\", ({\n    enumerable: true,\n    get: function() {\n        return enums_1.AsnPropTypes;\n    }\n}));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nObject.defineProperty(exports, \"AsnParser\", ({\n    enumerable: true,\n    get: function() {\n        return parser_1.AsnParser;\n    }\n}));\nvar serializer_1 = __webpack_require__(/*! ./serializer */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nObject.defineProperty(exports, \"AsnSerializer\", ({\n    enumerable: true,\n    get: function() {\n        return serializer_1.AsnSerializer;\n    }\n}));\ntslib_1.__exportStar(__webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./objects */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./convert */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/convert.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFCQUFxQixHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzFNLE1BQU1XLFVBQVVDLG1CQUFPQSxDQUFDLDBEQUFPO0FBQy9CRCxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLDRGQUFjLEdBQUdaO0FBQzlDVyxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLDhGQUFlLEdBQUdaO0FBQy9DLElBQUljLGVBQWVGLG1CQUFPQSxDQUFDLDRGQUFjO0FBQ3pDZCwyQ0FBMEM7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLGFBQWFKLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSFosMkNBQTBDO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixhQUFhTCxPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEhYLGlEQUFnRDtJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsYUFBYU4sYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzlIVixtREFBa0Q7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLGFBQWFQLGVBQWU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSVQsOENBQTZDO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixhQUFhUixVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEgsSUFBSVcsVUFBVUwsbUJBQU9BLENBQUMsa0ZBQVM7QUFDL0JkLGdEQUErQztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsUUFBUVosWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZIUCxnREFBK0M7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFiLFlBQVk7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2SCxJQUFJYyxXQUFXTixtQkFBT0EsQ0FBQyxvRkFBVTtBQUNqQ2QsNkNBQTRDO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxTQUFTZixTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEgsSUFBSWdCLGVBQWVQLG1CQUFPQSxDQUFDLDRGQUFjO0FBQ3pDZCxpREFBZ0Q7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLGFBQWFqQixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUhTLFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsMEZBQVUsR0FBR1o7QUFDMUNXLFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsc0ZBQVcsR0FBR1o7QUFDM0NXLFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsc0ZBQVcsR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaW5kZXguanM/NjI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IGV4cG9ydHMuQXNuUGFyc2VyID0gZXhwb3J0cy5Bc25Qcm9wVHlwZXMgPSBleHBvcnRzLkFzblR5cGVUeXBlcyA9IGV4cG9ydHMuQXNuU2V0VHlwZSA9IGV4cG9ydHMuQXNuU2VxdWVuY2VUeXBlID0gZXhwb3J0cy5Bc25DaG9pY2VUeXBlID0gZXhwb3J0cy5Bc25UeXBlID0gZXhwb3J0cy5Bc25Qcm9wID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvaW5kZXhcIiksIGV4cG9ydHMpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25Qcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuUHJvcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuQ2hvaWNlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzbkNob2ljZVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25TZXF1ZW5jZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25TZXF1ZW5jZVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25TZXRUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuU2V0VHlwZTsgfSB9KTtcbnZhciBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25UeXBlVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuQXNuVHlwZVR5cGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuUHJvcFR5cGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLkFzblByb3BUeXBlczsgfSB9KTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblBhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuQXNuUGFyc2VyOyB9IH0pO1xudmFyIHNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25TZXJpYWxpemVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJpYWxpemVyXzEuQXNuU2VyaWFsaXplcjsgfSB9KTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vYmplY3RzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnZlcnRcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuU2VyaWFsaXplciIsIkFzblBhcnNlciIsIkFzblByb3BUeXBlcyIsIkFzblR5cGVUeXBlcyIsIkFzblNldFR5cGUiLCJBc25TZXF1ZW5jZVR5cGUiLCJBc25DaG9pY2VUeXBlIiwiQXNuVHlwZSIsIkFzblByb3AiLCJ0c2xpYl8xIiwicmVxdWlyZSIsIl9fZXhwb3J0U3RhciIsImRlY29yYXRvcnNfMSIsImVudW1lcmFibGUiLCJnZXQiLCJlbnVtc18xIiwicGFyc2VyXzEiLCJzZXJpYWxpemVyXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnArray = void 0;\nclass AsnArray extends Array {\n    constructor(items = []){\n        if (typeof items === \"number\") {\n            super(items);\n        } else {\n            super();\n            for (const item of items){\n                this.push(item);\n            }\n        }\n    }\n}\nexports.AsnArray = AsnArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvb2JqZWN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QixNQUFNRSxpQkFBaUJDO0lBQ25CQyxZQUFZQyxRQUFRLEVBQUUsQ0FBRTtRQUNwQixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUMzQixLQUFLLENBQUNBO1FBQ1YsT0FDSztZQUNELEtBQUs7WUFDTCxLQUFLLE1BQU1DLFFBQVFELE1BQU87Z0JBQ3RCLElBQUksQ0FBQ0UsSUFBSSxDQUFDRDtZQUNkO1FBQ0o7SUFDSjtBQUNKO0FBQ0FOLGdCQUFnQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9vYmplY3RzLmpzPzNjNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzbkFycmF5ID0gdm9pZCAwO1xuY2xhc3MgQXNuQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMgPSBbXSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzdXBlcihpdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bc25BcnJheSA9IEFzbkFycmF5O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuQXJyYXkiLCJBcnJheSIsImNvbnN0cnVjdG9yIiwiaXRlbXMiLCJpdGVtIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/objects.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnParser = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if ((0, helper_1.isConvertible)(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = storage_1.schemaStorage.get(target);\n            storage_1.schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber\n                    },\n                    value: schema.schema.valueBlock.value\n                });\n                for(const key in schema.items){\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if ((0, helper_1.isTypeOfArray)(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element)=>converter.fromASN(element));\n                } else {\n                    return target.from(asn1Schema.valueBlock.value, (element)=>this.fromASN(element, itemType));\n                }\n            }\n            for(const key in schema.items){\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || (0, helper_1.isConvertible)(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (0, helper_1.isConvertible)(schemaItemType) ? new schemaItemType() : null;\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element)=>converter.fromASN(element));\n                        } else {\n                            res[key] = Array.from(asn1SchemaValue, (element)=>converter.fromASN(element));\n                        }\n                    } else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if ((0, helper_1.isConvertible)(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            } else {\n                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                } else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element)=>this.fromASN(element, schemaItemType));\n                    } else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        } catch (error) {\n            if (error instanceof errors_1.AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\nexports.AsnParser = AsnParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLDhEQUFRO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLGtGQUFTO0FBQ2pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRGQUFjO0FBQ3pDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLDBGQUFVO0FBQ25DLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLG9GQUFVO0FBQ25DLE1BQU1LLFlBQVlMLG1CQUFPQSxDQUFDLHNGQUFXO0FBQ3JDLE1BQU1GO0lBQ0YsT0FBT1EsTUFBTUMsSUFBSSxFQUFFQyxNQUFNLEVBQUU7UUFDdkIsTUFBTUMsYUFBYVYsT0FBT1csT0FBTyxDQUFDSDtRQUNsQyxJQUFJRSxXQUFXRSxNQUFNLENBQUNDLEtBQUssRUFBRTtZQUN6QixNQUFNLElBQUlDLE1BQU1KLFdBQVdFLE1BQU0sQ0FBQ0MsS0FBSztRQUMzQztRQUNBLE1BQU1FLE1BQU0sSUFBSSxDQUFDQyxPQUFPLENBQUNOLFdBQVdFLE1BQU0sRUFBRUg7UUFDNUMsT0FBT007SUFDWDtJQUNBLE9BQU9DLFFBQVFDLFVBQVUsRUFBRVIsTUFBTSxFQUFFO1FBQy9CLElBQUlTO1FBQ0osSUFBSTtZQUNBLElBQUksQ0FBQyxHQUFHYixTQUFTYyxhQUFhLEVBQUVWLFNBQVM7Z0JBQ3JDLE1BQU1YLFFBQVEsSUFBSVc7Z0JBQ2xCLE9BQU9YLE1BQU1rQixPQUFPLENBQUNDO1lBQ3pCO1lBQ0EsTUFBTUcsU0FBU2QsVUFBVWUsYUFBYSxDQUFDQyxHQUFHLENBQUNiO1lBQzNDSCxVQUFVZSxhQUFhLENBQUNFLEtBQUssQ0FBQ2Q7WUFDOUIsSUFBSWUsZUFBZUosT0FBT0Es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YSwwQkFBMEIsQ0FBQztnQ0FDM0U7Z0NBQ0FMLFVBQVUsSUFBSU87NEJBQ2xCOzRCQUNBUCxRQUFReEIsVUFBVSxHQUFHbkMsTUFBTW1DLFVBQVU7NEJBQ3JDbkMsUUFBUUUsT0FBT1csT0FBTyxDQUFDOEMsUUFBUUUsS0FBSyxDQUFDLFFBQVEvQyxNQUFNO3dCQUN2RDt3QkFDQUcsR0FBRyxDQUFDbUIsSUFBSSxHQUFHVyxVQUFVN0IsT0FBTyxDQUFDbEI7b0JBQ2pDO2dCQUNKLE9BQ0s7b0JBQ0QsSUFBSW9ELFdBQVdFLFFBQVEsRUFBRTt3QkFDckIsSUFBSSxDQUFDVixNQUFNQyxPQUFPLENBQUNNLGtCQUFrQjs0QkFDakMsTUFBTSxJQUFJbkMsTUFBTTt3QkFDcEI7d0JBQ0FDLEdBQUcsQ0FBQ21CLElBQUksR0FBR1EsTUFBTUssSUFBSSxDQUFDRSxpQkFBaUIsQ0FBQ0QsVUFBWSxJQUFJLENBQUNoQyxPQUFPLENBQUNnQyxTQUFTRztvQkFDOUUsT0FDSzt3QkFDRHBDLEdBQUcsQ0FBQ21CLElBQUksR0FBRyxJQUFJLENBQUNsQixPQUFPLENBQUNpQyxpQkFBaUJFO29CQUM3QztnQkFDSjtZQUNKO1lBQ0EsT0FBT3BDO1FBQ1gsRUFDQSxPQUFPRixPQUFPO1lBQ1YsSUFBSUEsaUJBQWlCVCxTQUFTbUMsd0JBQXdCLEVBQUU7Z0JBQ3BEMUIsTUFBTW9ELE9BQU8sQ0FBQ0MsSUFBSSxDQUFDekQsT0FBTytCLElBQUk7WUFDbEM7WUFDQSxNQUFNM0I7UUFDVjtJQUNKO0FBQ0o7QUFDQWhCLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9wYXJzZXIuanM/ZDM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGNvbnZlcnRlcnMgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jbGFzcyBBc25QYXJzZXIge1xuICAgIHN0YXRpYyBwYXJzZShkYXRhLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgYXNuMVBhcnNlZCA9IGFzbjFqcy5mcm9tQkVSKGRhdGEpO1xuICAgICAgICBpZiAoYXNuMVBhcnNlZC5yZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhc24xUGFyc2VkLnJlc3VsdC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5mcm9tQVNOKGFzbjFQYXJzZWQucmVzdWx0LCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFTTihhc24xU2NoZW1hLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmZyb21BU04oYXNuMVNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmNhY2hlKHRhcmdldCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0U2NoZW1hID0gc2NoZW1hLnNjaGVtYTtcbiAgICAgICAgICAgIGlmIChhc24xU2NoZW1hLmNvbnN0cnVjdG9yID09PSBhc24xanMuQ29uc3RydWN0ZWQgJiYgc2NoZW1hLnR5cGUgIT09IGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNjaGVtYSA9IG5ldyBhc24xanMuQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogYXNuMVNjaGVtYS5pZEJsb2NrLnRhZ051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNjaGVtYS5zY2hlbWEudmFsdWVCbG9jay52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFzbjFTY2hlbWFba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhc24xQ29tcGFyZWRTY2hlbWEgPSBhc24xanMuY29tcGFyZVNjaGVtYSh7fSwgYXNuMVNjaGVtYSwgdGFyZ2V0U2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghYXNuMUNvbXBhcmVkU2NoZW1hLnZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvcihgRGF0YSBkb2VzIG5vdCBtYXRjaCB0byAke3RhcmdldC5uYW1lfSBBU04xIHNjaGVtYS4gJHthc24xQ29tcGFyZWRTY2hlbWEucmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IHRhcmdldCgpO1xuICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJfMS5pc1R5cGVPZkFycmF5KSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoXCJ2YWx1ZVwiIGluIGFzbjFTY2hlbWEudmFsdWVCbG9jayAmJiBBcnJheS5pc0FycmF5KGFzbjFTY2hlbWEudmFsdWVCbG9jay52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBpdGVtcyBmcm9tIHRoZSBBU04uMSBwYXJzZWQgdmFsdWUuIEFTTi4xIG9iamVjdCBpcyBub3QgY29uc3RydWN0ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gc2NoZW1hLml0ZW1UeXBlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbVR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gY29udmVydGVycy5kZWZhdWx0Q29udmVydGVyKGl0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBkZWZhdWx0IGNvbnZlcnRlciBmb3IgYXJyYXkgaXRlbSBvZiAke3RhcmdldC5uYW1lfSBBU04xIHNjaGVtYWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZnJvbShhc24xU2NoZW1hLnZhbHVlQmxvY2sudmFsdWUsIChlbGVtZW50KSA9PiBjb252ZXJ0ZXIuZnJvbUFTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmZyb20oYXNuMVNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLCAoZWxlbWVudCkgPT4gdGhpcy5mcm9tQVNOKGVsZW1lbnQsIGl0ZW1UeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNuMVNjaGVtYVZhbHVlID0gYXNuMUNvbXBhcmVkU2NoZW1hLnJlc3VsdFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghYXNuMVNjaGVtYVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gc2NoZW1hLml0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbVR5cGUgPSBzY2hlbWFJdGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtVHlwZSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoc2NoZW1hSXRlbVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IChfYSA9IHNjaGVtYUl0ZW0uY29udmVydGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW1UeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgc2NoZW1hSXRlbVR5cGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZlcnRlciBpcyBlbXB0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0uaW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBzY2hlbWFJdGVtLnJlcGVhdGVkID09PSBcInNlcXVlbmNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuU2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSBuZXcgQ29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbS52YWx1ZUJsb2NrID0gYXNuMVNjaGVtYVZhbHVlLnZhbHVlQmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbUFzbiA9IGFzbjFqcy5mcm9tQkVSKG5ld0l0ZW0udG9CRVIoZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SXRlbUFzbi5vZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIHRoZSBjaGlsZCBpdGVtLiAke25ld0l0ZW1Bc24ucmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShcInZhbHVlXCIgaW4gbmV3SXRlbUFzbi5yZXN1bHQudmFsdWVCbG9jayAmJiBBcnJheS5pc0FycmF5KG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGl0ZW1zIGZyb20gdGhlIEFTTi4xIHBhcnNlZCB2YWx1ZS4gQVNOLjEgb2JqZWN0IGlzIG5vdCBjb25zdHJ1Y3RlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3SXRlbUFzbi5yZXN1bHQudmFsdWVCbG9jay52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IEFycmF5LmZyb20odmFsdWUsIChlbGVtZW50KSA9PiBjb252ZXJ0ZXIuZnJvbUFTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IEFycmF5LmZyb20oYXNuMVNjaGVtYVZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYXNuMVNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0uaW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW1UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtID0gbmV3IHNjaGVtYUl0ZW1UeXBlKCkudG9TY2hlbWEoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZU5hbWUgPSBlbnVtc18xLkFzblByb3BUeXBlc1tzY2hlbWFJdGVtVHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlID0gYXNuMWpzW0FzbjFUeXBlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXNuMVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCAnJHtBc24xVHlwZU5hbWV9JyBjbGFzcyBmcm9tIGFzbjFqcyBtb2R1bGVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtID0gbmV3IEFzbjFUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0udmFsdWVCbG9jayA9IHZhbHVlLnZhbHVlQmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhc24xanMuZnJvbUJFUihuZXdJdGVtLnRvQkVSKGZhbHNlKSkucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBjb252ZXJ0ZXIuZnJvbUFTTih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXNuMVNjaGVtYVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgbGlzdCBvZiBpdGVtcyBmcm9tIHRoZSBBU04uMSBwYXJzZWQgdmFsdWUuIEFTTi4xIHZhbHVlIHNob3VsZCBiZSBpdGVyYWJsZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IEFycmF5LmZyb20oYXNuMVNjaGVtYVZhbHVlLCAoZWxlbWVudCkgPT4gdGhpcy5mcm9tQVNOKGVsZW1lbnQsIHNjaGVtYUl0ZW1UeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IHRoaXMuZnJvbUFTTihhc24xU2NoZW1hVmFsdWUsIHNjaGVtYUl0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnNfMS5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5zY2hlbWFzLnB1c2godGFyZ2V0Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFzblBhcnNlciA9IEFzblBhcnNlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblBhcnNlciIsImFzbjFqcyIsInJlcXVpcmUiLCJlbnVtc18xIiwiY29udmVydGVycyIsImVycm9yc18xIiwiaGVscGVyXzEiLCJzdG9yYWdlXzEiLCJwYXJzZSIsImRhdGEiLCJ0YXJnZXQiLCJhc24xUGFyc2VkIiwiZnJvbUJFUiIsInJlc3VsdCIsImVycm9yIiwiRXJyb3IiLCJyZXMiLCJmcm9tQVNOIiwiYXNuMVNjaGVtYSIsIl9hIiwiaXNDb252ZXJ0aWJsZSIsInNjaGVtYSIsInNjaGVtYVN0b3JhZ2UiLCJnZXQiLCJjYWNoZSIsInRhcmdldFNjaGVtYSIsImNvbnN0cnVjdG9yIiwiQ29uc3RydWN0ZWQiLCJ0eXBlIiwiQXNuVHlwZVR5cGVzIiwiQ2hvaWNlIiwiaWRCbG9jayIsInRhZ0NsYXNzIiwidGFnTnVtYmVyIiwidmFsdWVCbG9jayIsImtleSIsIml0ZW1zIiwiYXNuMUNvbXBhcmVkU2NoZW1hIiwiY29tcGFyZVNjaGVtYSIsInZlcmlmaWVkIiwiQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yIiwibmFtZSIsImlzVHlwZU9mQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtVHlwZSIsImNvbnZlcnRlciIsImRlZmF1bHRDb252ZXJ0ZXIiLCJmcm9tIiwiZWxlbWVudCIsImFzbjFTY2hlbWFWYWx1ZSIsInNjaGVtYUl0ZW0iLCJzY2hlbWFJdGVtVHlwZSIsInJlcGVhdGVkIiwiaW1wbGljaXQiLCJDb250YWluZXIiLCJTZXF1ZW5jZSIsIlNldCIsIm5ld0l0ZW0iLCJuZXdJdGVtQXNuIiwidG9CRVIiLCJvZmZzZXQiLCJ0b1NjaGVtYSIsIkFzbjFUeXBlTmFtZSIsIkFzblByb3BUeXBlcyIsIkFzbjFUeXBlIiwic2NoZW1hcyIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/parser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSchemaStorage = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nclass AsnSchemaStorage {\n    constructor(){\n        this.items = new WeakMap();\n    }\n    has(target) {\n        return this.items.has(target);\n    }\n    get(target, checkSchema = false) {\n        const schema = this.items.get(target);\n        if (!schema) {\n            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n        }\n        if (checkSchema && !schema.schema) {\n            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n        }\n        return schema;\n    }\n    cache(target) {\n        const schema = this.get(target);\n        if (!schema.schema) {\n            schema.schema = this.create(target, true);\n        }\n    }\n    createDefault(target) {\n        const schema = {\n            type: enums_1.AsnTypeTypes.Sequence,\n            items: {}\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.items = Object.assign({}, schema.items, parentSchema.items);\n        }\n        return schema;\n    }\n    create(target, useNames) {\n        const schema = this.items.get(target) || this.createDefault(target);\n        const asn1Value = [];\n        for(const key in schema.items){\n            const item = schema.items[key];\n            const name = useNames ? key : \"\";\n            let asn1Item;\n            if (typeof item.type === \"number\") {\n                const Asn1TypeName = enums_1.AsnPropTypes[item.type];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n                }\n                asn1Item = new Asn1Type({\n                    name\n                });\n            } else if ((0, helper_1.isConvertible)(item.type)) {\n                const instance = new item.type();\n                asn1Item = instance.toSchema(name);\n            } else if (item.optional) {\n                const itemSchema = this.get(item.type);\n                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {\n                    asn1Item = new asn1js.Any({\n                        name\n                    });\n                } else {\n                    asn1Item = this.create(item.type, false);\n                    asn1Item.name = name;\n                }\n            } else {\n                asn1Item = new asn1js.Any({\n                    name\n                });\n            }\n            const optional = !!item.optional || item.defaultValue !== undefined;\n            if (item.repeated) {\n                asn1Item.name = \"\";\n                const Container = item.repeated === \"set\" ? asn1js.Set : asn1js.Sequence;\n                asn1Item = new Container({\n                    name: \"\",\n                    value: [\n                        new asn1js.Repeated({\n                            name,\n                            value: asn1Item\n                        })\n                    ]\n                });\n            }\n            if (item.context !== null && item.context !== undefined) {\n                if (item.implicit) {\n                    if (typeof item.type === \"number\" || (0, helper_1.isConvertible)(item.type)) {\n                        const Container = item.repeated ? asn1js.Constructed : asn1js.Primitive;\n                        asn1Value.push(new Container({\n                            name,\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context\n                            }\n                        }));\n                    } else {\n                        this.cache(item.type);\n                        const isRepeated = !!item.repeated;\n                        let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;\n                        value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n                        asn1Value.push(new asn1js.Constructed({\n                            name: !isRepeated ? name : \"\",\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context\n                            },\n                            value: value\n                        }));\n                    }\n                } else {\n                    asn1Value.push(new asn1js.Constructed({\n                        optional,\n                        idBlock: {\n                            tagClass: 3,\n                            tagNumber: item.context\n                        },\n                        value: [\n                            asn1Item\n                        ]\n                    }));\n                }\n            } else {\n                asn1Item.optional = optional;\n                asn1Value.push(asn1Item);\n            }\n        }\n        switch(schema.type){\n            case enums_1.AsnTypeTypes.Sequence:\n                return new asn1js.Sequence({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            case enums_1.AsnTypeTypes.Set:\n                return new asn1js.Set({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            case enums_1.AsnTypeTypes.Choice:\n                return new asn1js.Choice({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            default:\n                throw new Error(`Unsupported ASN1 type in use`);\n        }\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nexports.AsnSchemaStorage = AsnSchemaStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLDhEQUFRO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLGtGQUFTO0FBQ2pDLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLG9GQUFVO0FBQ25DLE1BQU1GO0lBQ0ZLLGFBQWM7UUFDVixJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJQztJQUNyQjtJQUNBQyxJQUFJQyxNQUFNLEVBQUU7UUFDUixPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDRSxHQUFHLENBQUNDO0lBQzFCO0lBQ0FDLElBQUlELE1BQU0sRUFBRUUsY0FBYyxLQUFLLEVBQUU7UUFDN0IsTUFBTUMsU0FBUyxJQUFJLENBQUNOLEtBQUssQ0FBQ0ksR0FBRyxDQUFDRDtRQUM5QixJQUFJLENBQUNHLFFBQVE7WUFDVCxNQUFNLElBQUlDLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRUosT0FBT0ssU0FBUyxDQUFDVCxXQUFXLENBQUNVLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDekY7UUFDQSxJQUFJSixlQUFlLENBQUNDLE9BQU9BLE1BQU0sRUFBRTtZQUMvQixNQUFNLElBQUlDLE1BQU0sQ0FBQyxRQUFRLEVBQUVKLE9BQU9LLFNBQVMsQ0FBQ1QsV0FBVyxDQUFDVSxJQUFJLENBQUMsOERBQThELENBQUM7UUFDaEk7UUFDQSxPQUFPSDtJQUNYO0lBQ0FJLE1BQU1QLE1BQU0sRUFBRTtRQUNWLE1BQU1HLFNBQVMsSUFBSSxDQUFDRixHQUFHLENBQUNEO1FBQ3hCLElBQUksQ0FBQ0csT0FBT0EsTUFBTSxFQUFFO1lBQ2hCQSxPQUFPQSxNQUFNLEdBQUcsSUFBSSxDQUFDSyxNQUFNLENBQUNSLFFB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OUIsT0FBTyxJQUFJcEIsT0FBT29CLFFBQVEsQ0FBQztvQkFBRXRCLE9BQU8yQjtvQkFBV1gsTUFBTTtnQkFBRztZQUM1RCxLQUFLWixRQUFRaUIsWUFBWSxDQUFDd0IsR0FBRztnQkFDekIsT0FBTyxJQUFJM0MsT0FBTzJDLEdBQUcsQ0FBQztvQkFBRTdDLE9BQU8yQjtvQkFBV1gsTUFBTTtnQkFBRztZQUN2RCxLQUFLWixRQUFRaUIsWUFBWSxDQUFDa0IsTUFBTTtnQkFDNUIsT0FBTyxJQUFJckMsT0FBT3FDLE1BQU0sQ0FBQztvQkFBRXZDLE9BQU8yQjtvQkFBV1gsTUFBTTtnQkFBRztZQUMxRDtnQkFDSSxNQUFNLElBQUlGLE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQztRQUN0RDtJQUNKO0lBQ0EyQyxJQUFJL0MsTUFBTSxFQUFFRyxNQUFNLEVBQUU7UUFDaEIsSUFBSSxDQUFDTixLQUFLLENBQUNrRCxHQUFHLENBQUMvQyxRQUFRRztRQUN2QixPQUFPLElBQUk7SUFDZjtJQUNBVyxpQkFBaUJkLE1BQU0sRUFBRTtRQUNyQixNQUFNZ0QsU0FBUzdELE9BQU84RCxjQUFjLENBQUNqRDtRQUNyQyxJQUFJZ0QsUUFBUTtZQUNSLE1BQU03QyxTQUFTLElBQUksQ0FBQ04sS0FBSyxDQUFDSSxHQUFHLENBQUMrQztZQUM5QixPQUFPN0MsVUFBVSxJQUFJLENBQUNXLGdCQUFnQixDQUFDa0M7UUFDM0M7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBM0Qsd0JBQXdCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NjaGVtYS5qcz8wNTEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TY2hlbWFTdG9yYWdlID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY2xhc3MgQXNuU2NoZW1hU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBoYXModGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyh0YXJnZXQpO1xuICAgIH1cbiAgICBnZXQodGFyZ2V0LCBjaGVja1NjaGVtYSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgc2NoZW1hIGZvciAnJHt0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWV9JyB0YXJnZXRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTY2hlbWEgJiYgIXNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hICcke3RhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZX0nIGRvZXNuJ3QgY29udGFpbiBBU04uMSBzY2hlbWEuIENhbGwgJ0FzblNjaGVtYVN0b3JhZ2UuY2FjaGUnLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNhY2hlKHRhcmdldCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYS5zY2hlbWEgPSB0aGlzLmNyZWF0ZSh0YXJnZXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZURlZmF1bHQodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlLFxuICAgICAgICAgICAgaXRlbXM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBzY2hlbWEuaXRlbXMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEuaXRlbXMsIHBhcmVudFNjaGVtYS5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY3JlYXRlKHRhcmdldCwgdXNlTmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQodGFyZ2V0KSB8fCB0aGlzLmNyZWF0ZURlZmF1bHQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYXNuMVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHVzZU5hbWVzID8ga2V5IDogXCJcIjtcbiAgICAgICAgICAgIGxldCBhc24xSXRlbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZU5hbWUgPSBlbnVtc18xLkFzblByb3BUeXBlc1tpdGVtLnR5cGVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlID0gYXNuMWpzW0FzbjFUeXBlTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFBc24xVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgQVNOMSBjbGFzcyBieSBuYW1lICcke0FzbjFUeXBlTmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IEFzbjFUeXBlKHsgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgaXRlbS50eXBlKCk7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBpbnN0YW5jZS50b1NjaGVtYShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gdGhpcy5nZXQoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVNjaGVtYS50eXBlID09PSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgYXNuMWpzLkFueSh7IG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbSA9IHRoaXMuY3JlYXRlKGl0ZW0udHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBhc24xanMuQW55KHsgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbmFsID0gISFpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IGl0ZW0ucmVwZWF0ZWQgPT09IFwic2V0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2V0XG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNlcXVlbmNlO1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgYXNuMWpzLlJlcGVhdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhc24xSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uY29udGV4dCAhPT0gbnVsbCAmJiBpdGVtLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS50eXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBpdGVtLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuQ29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5QcmltaXRpdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlKGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1JlcGVhdGVkID0gISFpdGVtLnJlcGVhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gIWlzUmVwZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0KGl0ZW0udHlwZSwgdHJ1ZSkuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhc24xSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJ2YWx1ZUJsb2NrXCIgaW4gdmFsdWUgPyB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlIDogdmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAhaXNSZXBlYXRlZCA/IG5hbWUgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogaXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbYXNuMUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0ub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChhc24xSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzY2hlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5TZXF1ZW5jZSh7IHZhbHVlOiBhc24xVmFsdWUsIG5hbWU6IFwiXCIgfSk7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5TZXQoeyB2YWx1ZTogYXNuMVZhbHVlLCBuYW1lOiBcIlwiIH0pO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuQ2hvaWNlKHsgdmFsdWU6IGFzbjFWYWx1ZSwgbmFtZTogXCJcIiB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBBU04xIHR5cGUgaW4gdXNlYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHRhcmdldCwgc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYSB8fCB0aGlzLmZpbmRQYXJlbnRTY2hlbWEocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkFzblNjaGVtYVN0b3JhZ2UgPSBBc25TY2hlbWFTdG9yYWdlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuU2NoZW1hU3RvcmFnZSIsImFzbjFqcyIsInJlcXVpcmUiLCJlbnVtc18xIiwiaGVscGVyXzEiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwiV2Vha01hcCIsImhhcyIsInRhcmdldCIsImdldCIsImNoZWNrU2NoZW1hIiwic2NoZW1hIiwiRXJyb3IiLCJwcm90b3R5cGUiLCJuYW1lIiwiY2FjaGUiLCJjcmVhdGUiLCJjcmVhdGVEZWZhdWx0IiwidHlwZSIsIkFzblR5cGVUeXBlcyIsIlNlcXVlbmNlIiwicGFyZW50U2NoZW1hIiwiZmluZFBhcmVudFNjaGVtYSIsImFzc2lnbiIsInVzZU5hbWVzIiwiYXNuMVZhbHVlIiwia2V5IiwiaXRlbSIsImFzbjFJdGVtIiwiQXNuMVR5cGVOYW1lIiwiQXNuUHJvcFR5cGVzIiwiQXNuMVR5cGUiLCJpc0NvbnZlcnRpYmxlIiwiaW5zdGFuY2UiLCJ0b1NjaGVtYSIsIm9wdGlvbmFsIiwiaXRlbVNjaGVtYSIsIkNob2ljZSIsIkFueSIsImRlZmF1bHRWYWx1ZSIsInVuZGVmaW5lZCIsInJlcGVhdGVkIiwiQ29udGFpbmVyIiwiU2V0IiwiUmVwZWF0ZWQiLCJjb250ZXh0IiwiaW1wbGljaXQiLCJDb25zdHJ1Y3RlZCIsIlByaW1pdGl2ZSIsInB1c2giLCJpZEJsb2NrIiwidGFnQ2xhc3MiLCJ0YWdOdW1iZXIiLCJpc1JlcGVhdGVkIiwidmFsdWVCbG9jayIsInNldCIsInBhcmVudCIsImdldFByb3RvdHlwZU9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSerializer = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && (0, helper_1.isConvertible)(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = storage_1.schemaStorage.get(target);\n        storage_1.schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o)=>converter.toASN(o));\n            } else {\n                asn1Value = obj.map((o)=>this.toAsnItem({\n                        type: schema.itemType\n                    }, \"[]\", target, o));\n            }\n        } else {\n            for(const key in schema.items){\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\" && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated && (typeof schemaItem.type === \"number\" || (0, helper_1.isConvertible)(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context\n                                },\n                                ...value\n                            }));\n                        } else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context\n                                },\n                                value: asn1Item.valueBlock.value\n                            }));\n                        }\n                    } else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context\n                            },\n                            value: [\n                                asn1Item\n                            ]\n                        }));\n                    }\n                } else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                } else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch(schema.type){\n            case enums_1.AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({\n                    value: asn1Value\n                });\n                break;\n            case enums_1.AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({\n                    value: asn1Value\n                });\n                break;\n            case enums_1.AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof schemaItem.type === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element)=>converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                asn1Item = new Container({\n                    value: items\n                });\n            } else {\n                asn1Item = converter.toASN(objProp);\n            }\n        } else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element)=>this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                asn1Item = new Container({\n                    value: items\n                });\n            } else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\nexports.AsnSerializer = AsnSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc2VyaWFsaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUMvQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyw0RkFBYztBQUN6QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyxrRkFBUztBQUNqQyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyxvRkFBVTtBQUNuQyxNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyxzRkFBVztBQUNyQyxNQUFNRjtJQUNGLE9BQU9PLFVBQVVDLEdBQUcsRUFBRTtRQUNsQixJQUFJQSxlQUFlUCxPQUFPUSxTQUFTLEVBQUU7WUFDakMsT0FBT0QsSUFBSUUsS0FBSyxDQUFDO1FBQ3JCO1FBQ0EsT0FBTyxJQUFJLENBQUNDLEtBQUssQ0FBQ0gsS0FBS0UsS0FBSyxDQUFDO0lBQ2pDO0lBQ0EsT0FBT0MsTUFBTUgsR0FBRyxFQUFFO1FBQ2QsSUFBSUEsT0FBTyxPQUFPQSxRQUFRLFlBQVksQ0FBQyxHQUFHSCxTQUFTTyxhQUFhLEVBQUVKLE1BQU07WUFDcEUsT0FBT0EsSUFBSUcsS0FBSztRQUNwQjtRQUNBLElBQUksQ0FBRUgsQ0FBQUEsT0FBTyxPQUFPQSxRQUFRLFFBQU8sR0FBSTtZQUNuQyxNQUFNLElBQUlLLFVBQVU7UUFDeEI7UUFDQSxNQUFNQyxTQUFTTixJQUFJTyxXQUFXO1FBQzlCLE1BQU1DLFNBQVNWLFVBQVVXLGFBQWEsQ0FBQ0MsR0FBRyxDQUFDSjtRQUMzQ1IsVUFBVVcsYUFBYSxDQUFDRSxLQUFLLENBQUNMO1FBQzlCLElBQUlNLFlBQVksRUFBRTtRQUNsQixJQUFJSixPQUFPSyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNmLE1BQU07Z0JBQ3JCLE1BQU0sSUFBSUssVUFBVTtZQUN4QjtZQUNBLElBQUksT0FBT0csT0FBT0ssUUFBUSxLQUFLLFVBQVU7Z0JBQ3JDLE1BQU1HLFlBQVlyQixXQUFXc0IsZ0JBQWdCLENBQUNULE9BQU9LLFFBQVE7Z0JBQzdELElBQUksQ0FBQ0csV0FBVztvQkFDWixNQUFNLElBQUlFLE1BQU0sQ0FBQywrQ0FBK0MsRUFBRVosT0FBT2EsSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFDL0Y7Z0JBQ0FQLFlBQVlaLElBQUlvQixHQUFHLENBQUMsQ0FBQ0MsSUFBTUwsVUFBVWIsS0FBSyxDQUFDa0I7WUFDL0MsT0FDSztnQkFDRFQsWUFBWVosSUFBSW9CLEdBQUcsQ0FBQyxDQUFDQyxJQUFNLElBQUksQ0FBQ0MsU0FBUyxDQUFDO3dCQUFFQyxNQUFNZixPQUFPSyxRQUFRO29CQUFDLEdBQUcsTUFBTVAsUUFBUWU7WUFDdkY7UUFDSixPQUNLO1lBQ0QsSUFBSyxNQUFNRyxPQUFPaEIsT0FBT2lCLEtBQUssQ0FBRTtnQkFDNUIsTUFBTUMsYUFBYWxCLE9BQU9pQixLQUFLLENBQUNELElBQUk7Z0JBQ3BDLE1BQU1HLFVBQVUzQixHQUFHLENBQUN3QixJQUFJO2dCQUN4QixJQUFJRyxZQUFZQyxhQUNURixXQUFXRyxZQUFZLEtBQUtGLFdBQzNCLE9BQU9ELFdBQVdHLFlBQVksS0FBSyxZQUFZLE9BQU9GLFlBQVksWUFDL0QsQ0FBQyxHQUFHOUIsU0FBU2lDLFlBQVksRUFBRSxJQUFJLENBQUMvQixTQUFTLENBQUMyQixXQUFXRyxZQUFZLEdBQUcsSUFBSSxDQUFDOUIsU0FBUyxDQUFDNEIsV0FBWTtvQkFDdEc7Z0JBQ0o7Z0JBQ0EsTUFBTUksV0FBV3ZDLGNBQWM4QixTQUFTLENBQUNJLFlBQVlGLEtBQUtsQixRQUFRcUI7Z0JBQ2xFLElBQUksT0FBT0QsV0FBV00sT0FBTyxLQUFLLFVBQVU7b0JBQ3hDLElBQUlOLFdBQVdPLFFBQVEsRUFBRTt3QkFDckIsSUFBSSxDQUFDUCxXQUFXUSxRQUFRLElBQ2hCLFFBQU9SLFdBQVdILElBQUksS0FBSyxZQUFZLENBQUMsR0FBRzFCLFNBQVNPLGFBQWEsRUFBRXNCLFdBQVdILElBQUksSUFBSTs0QkFDMUYsTUFBTWhDLFFBQVEsQ0FBQzs0QkFDZkEsTUFBTTRDLFFBQVEsR0FBR0osb0JBQW9CdEMsT0FBTzJDLElBQUksR0FBR0wsU0FBU00scUJBQXFCLEdBQUdOLFNBQVNPLFVBQVUsQ0FBQ3BDLEtBQUs7NEJBQzdHVSxVQUFVMkIsSUFBSSxDQUFDLElBQUk5QyxPQUFPK0MsU0FBUyxDQUFDO2dDQUNoQ0MsVUFBVWYsV0FBV2UsUUFBUTtnQ0FDN0JDLFNBQVM7b0NBQ0xDLFVBQVU7b0NBQ1ZDLFdBQVdsQixXQUFXTSxPQUFPO2dDQUNqQztnQ0FDQSxHQUFHekMsS0FBSzs0QkFDWjt3QkFDSixPQUNLOzRCQUNEcUIsVUFBVTJCLElBQUksQ0FBQyxJQUFJOUMsT0FBT29ELFdBQVcsQ0FBQztnQ0FDbENKLFVBQVVmLFdBQVdlLFFBQVE7Z0NBQzdCQyxTQUFTO29DQUNMQyxVQUFVO29DQUNWQyxXQUFXbEIsV0FBV00sT0FBTztnQ0FDakM7Z0NBQ0F6QyxPQUFPd0MsU0FBU08sVUFBVSxDQUFDL0MsS0FBSzs0QkFDcEM7d0JBQ0o7b0JBQ0osT0FDSzt3QkFDRHFCLFVBQVUyQixJQUFJLENBQUMsSUFBSTlDLE9BQU9vRCxXQUFXLENBQUM7NEJBQ2xDSixVQUFVZixXQUFXZSxRQUFROzRCQUM3QkMsU0FBUztnQ0FDTEMsVUFBVTtnQ0FDVkMsV0FBV2xCLFdBQVdNLE9BQU87NEJBQ2pDOzRCQUNBekMsT0FBTztnQ0FBQ3dDOzZCQUFTO3dCQUNyQjtvQkFDSjtnQkFDSixPQUNLLElBQUlMLFdBQVdRLFFBQVEsRUFBRTtvQkFDMUJ0QixZQUFZQSxVQUFVa0MsTUFBTSxDQUFDZjtnQkFDakMsT0FDSztvQkFDRG5CLFVBQVUyQixJQUFJLENBQUNSO2dCQUNuQjtZQUNKO1FBQ0o7UUFDQSxJQUFJZ0I7UUFDSixPQUFRdkMsT0FBT2UsSUFBSTtZQUNmLEtBQUszQixRQUFRb0QsWUFBWSxDQUFDQyxRQUFRO2dCQUM5QkYsWUFBWSxJQUFJdEQsT0FBT3dELFFBQVEsQ0FBQztvQkFBRTFELE9BQU9xQjtnQkFBVTtnQkFDbkQ7WUFDSixLQUFLaEIsUUFBUW9ELFlBQVksQ0FBQ0UsR0FBRztnQkFDekJILFlBQVksSUFBSXRELE9BQU95RCxHQUFHLENBQUM7b0JBQUUzRCxPQUFPcUI7Z0JBQVU7Z0JBQzlDO1lBQ0osS0FBS2hCLFFBQVFvRCxZQUFZLENBQUNHLE1BQU07Z0JBQzVCLElBQUksQ0FBQ3ZDLFNBQVMsQ0FBQyxFQUFFLEVBQUU7b0JBQ2YsTUFBTSxJQUFJTSxNQUFNLENBQUMsUUFBUSxFQUFFWixPQUFPYSxJQUFJLENBQUMseUNBQXlDLENBQUM7Z0JBQ3JGO2dCQUNBNEIsWUFBWW5DLFNBQVMsQ0FBQyxFQUFFO2dCQUN4QjtRQUNSO1FBQ0EsT0FBT21DO0lBQ1g7SUFDQSxPQUFPekIsVUFBVUksVUFBVSxFQUFFRixHQUFHLEVBQUVsQixNQUFNLEVBQUVxQixPQUFPLEVBQUU7UUFDL0MsSUFBSUk7UUFDSixJQUFJLE9BQVFMLFdBQVdILElBQUksS0FBTSxVQUFVO1lBQ3ZDLE1BQU1QLFlBQVlVLFdBQVdWLFNBQVM7WUFDdEMsSUFBSSxDQUFDQSxXQUFXO2dCQUNaLE1BQU0sSUFBSUUsTUFBTSxDQUFDLFVBQVUsRUFBRU0sSUFBSSxrQ0FBa0MsRUFBRTVCLFFBQVF3RCxZQUFZLENBQUMxQixXQUFXSCxJQUFJLENBQUMsQ0FBQyxZQUFZLEVBQUVqQixPQUFPYSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzNJO1lBQ0EsSUFBSU8sV0FBV1EsUUFBUSxFQUFFO2dCQUNyQixJQUFJLENBQUNwQixNQUFNQyxPQUFPLENBQUNZLFVBQVU7b0JBQ3pCLE1BQU0sSUFBSXRCLFVBQVU7Z0JBQ3hCO2dCQUNBLE1BQU1vQixRQUFRWCxNQUFNdUMsSUFBSSxDQUFDMUIsU0FBUyxDQUFDMkIsVUFBWXRDLFVBQVViLEtBQUssQ0FBQ21EO2dCQUMvRCxNQUFNQyxZQUFZN0IsV0FBV1EsUUFBUSxLQUFLLGFBQ3BDekMsT0FBT3dELFFBQVEsR0FDZnhELE9BQU95RCxHQUFHO2dCQUNoQm5CLFdBQVcsSUFBSXdCLFVBQVU7b0JBQ3JCaEUsT0FBT2tDO2dCQUNYO1lBQ0osT0FDSztnQkFDRE0sV0FBV2YsVUFBVWIsS0FBSyxDQUFDd0I7WUFDL0I7UUFDSixPQUNLO1lBQ0QsSUFBSUQsV0FBV1EsUUFBUSxFQUFFO2dCQUNyQixJQUFJLENBQUNwQixNQUFNQyxPQUFPLENBQUNZLFVBQVU7b0JBQ3pCLE1BQU0sSUFBSXRCLFVBQVU7Z0JBQ3hCO2dCQUNBLE1BQU1vQixRQUFRWCxNQUFNdUMsSUFBSSxDQUFDMUIsU0FBUyxDQUFDMkIsVUFBWSxJQUFJLENBQUNuRCxLQUFLLENBQUNtRDtnQkFDMUQsTUFBTUMsWUFBWTdCLFdBQVdRLFFBQVEsS0FBSyxhQUNwQ3pDLE9BQU93RCxRQUFRLEdBQ2Z4RCxPQUFPeUQsR0FBRztnQkFDaEJuQixXQUFXLElBQUl3QixVQUFVO29CQUNyQmhFLE9BQU9rQztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0RNLFdBQVcsSUFBSSxDQUFDNUIsS0FBSyxDQUFDd0I7WUFDMUI7UUFDSjtRQUNBLE9BQU9JO0lBQ1g7QUFDSjtBQUNBekMscUJBQXFCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NlcmlhbGl6ZXIuanM/YmY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNsYXNzIEFzblNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBhc24xanMuQmFzZUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvQkVSKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b0FTTihvYmopLnRvQkVSKGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQVNOKG9iaikge1xuICAgICAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9BU04oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgMSBzaG91bGQgYmUgdHlwZSBvZiBPYmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmNhY2hlKHRhcmdldCk7XG4gICAgICAgIGxldCBhc24xVmFsdWUgPSBbXTtcbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtVHlwZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyIDEgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuaXRlbVR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzLmRlZmF1bHRDb252ZXJ0ZXIoc2NoZW1hLml0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIGFycmF5IGl0ZW0gb2YgJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gb2JqLm1hcCgobykgPT4gY29udmVydGVyLnRvQVNOKG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IG9iai5tYXAoKG8pID0+IHRoaXMudG9Bc25JdGVtKHsgdHlwZTogc2NoZW1hLml0ZW1UeXBlIH0sIFwiW11cIiwgdGFyZ2V0LCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gc2NoZW1hLml0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqUHJvcCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChvYmpQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfHwgc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUgPT09IG9ialByb3BcbiAgICAgICAgICAgICAgICAgICAgfHwgKHR5cGVvZiBzY2hlbWFJdGVtLmRlZmF1bHRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqUHJvcCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKDAsIGhlbHBlcl8xLmlzQXJyYXlFcXVhbCkodGhpcy5zZXJpYWxpemUoc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUpLCB0aGlzLnNlcmlhbGl6ZShvYmpQcm9wKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhc24xSXRlbSA9IEFzblNlcmlhbGl6ZXIudG9Bc25JdGVtKHNjaGVtYUl0ZW0sIGtleSwgdGFyZ2V0LCBvYmpQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUl0ZW0uY29udGV4dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFJdGVtLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW0udHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZUhleCA9IGFzbjFJdGVtIGluc3RhbmNlb2YgYXNuMWpzLk51bGwgPyBhc24xSXRlbS52YWx1ZUJlZm9yZURlY29kZVZpZXcgOiBhc24xSXRlbS52YWx1ZUJsb2NrLnRvQkVSKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5QcmltaXRpdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzY2hlbWFJdGVtLm9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogc2NoZW1hSXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXNuMUl0ZW0udmFsdWVCbG9jay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbYXNuMUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gYXNuMVZhbHVlLmNvbmNhdChhc24xSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChhc24xSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhc25TY2hlbWE7XG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gbmV3IGFzbjFqcy5TZXF1ZW5jZSh7IHZhbHVlOiBhc24xVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldDpcbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBuZXcgYXNuMWpzLlNldCh7IHZhbHVlOiBhc24xVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZTpcbiAgICAgICAgICAgICAgICBpZiAoIWFzbjFWYWx1ZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSAnJHt0YXJnZXQubmFtZX0nIGhhcyB3cm9uZyBkYXRhLiBDaG9pY2UgY2Fubm90IGJlIGVtcHR5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBhc24xVmFsdWVbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzblNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIHRvQXNuSXRlbShzY2hlbWFJdGVtLCBrZXksIHRhcmdldCwgb2JqUHJvcCkge1xuICAgICAgICBsZXQgYXNuMUl0ZW07XG4gICAgICAgIGlmICh0eXBlb2YgKHNjaGVtYUl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IHNjaGVtYUl0ZW0uY29udmVydGVyO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICcke2tleX0nIGRvZXNuJ3QgaGF2ZSBjb252ZXJ0ZXIgZm9yIHR5cGUgJHtlbnVtc18xLkFzblByb3BUeXBlc1tzY2hlbWFJdGVtLnR5cGVdfSBpbiBzY2hlbWEgJyR7dGFyZ2V0Lm5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqUHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAnb2JqUHJvcCcgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20ob2JqUHJvcCwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci50b0FTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IGNvbnZlcnRlci50b0FTTihvYmpQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ29ialByb3AnIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG9ialByb3AsIChlbGVtZW50KSA9PiB0aGlzLnRvQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBzY2hlbWFJdGVtLnJlcGVhdGVkID09PSBcInNlcXVlbmNlXCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuU2V0O1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gdGhpcy50b0FTTihvYmpQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNuMUl0ZW07XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gQXNuU2VyaWFsaXplcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblNlcmlhbGl6ZXIiLCJhc24xanMiLCJyZXF1aXJlIiwiY29udmVydGVycyIsImVudW1zXzEiLCJoZWxwZXJfMSIsInN0b3JhZ2VfMSIsInNlcmlhbGl6ZSIsIm9iaiIsIkJhc2VCbG9jayIsInRvQkVSIiwidG9BU04iLCJpc0NvbnZlcnRpYmxlIiwiVHlwZUVycm9yIiwidGFyZ2V0IiwiY29uc3RydWN0b3IiLCJzY2hlbWEiLCJzY2hlbWFTdG9yYWdlIiwiZ2V0IiwiY2FjaGUiLCJhc24xVmFsdWUiLCJpdGVtVHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImNvbnZlcnRlciIsImRlZmF1bHRDb252ZXJ0ZXIiLCJFcnJvciIsIm5hbWUiLCJtYXAiLCJvIiwidG9Bc25JdGVtIiwidHlwZSIsImtleSIsIml0ZW1zIiwic2NoZW1hSXRlbSIsIm9ialByb3AiLCJ1bmRlZmluZWQiLCJkZWZhdWx0VmFsdWUiLCJpc0FycmF5RXF1YWwiLCJhc24xSXRlbSIsImNvbnRleHQiLCJpbXBsaWNpdCIsInJlcGVhdGVkIiwidmFsdWVIZXgiLCJOdWxsIiwidmFsdWVCZWZvcmVEZWNvZGVWaWV3IiwidmFsdWVCbG9jayIsInB1c2giLCJQcmltaXRpdmUiLCJvcHRpb25hbCIsImlkQmxvY2siLCJ0YWdDbGFzcyIsInRhZ051bWJlciIsIkNvbnN0cnVjdGVkIiwiY29uY2F0IiwiYXNuU2NoZW1hIiwiQXNuVHlwZVR5cGVzIiwiU2VxdWVuY2UiLCJTZXQiLCJDaG9pY2UiLCJBc25Qcm9wVHlwZXMiLCJmcm9tIiwiZWxlbWVudCIsIkNvbnRhaW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.schemaStorage = void 0;\nconst schema_1 = __webpack_require__(/*! ./schema */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/schema.js\");\nexports.schemaStorage = new schema_1.AsnSchemaStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxvRkFBVTtBQUNuQ0oscUJBQXFCLEdBQUcsSUFBSUcsU0FBU0UsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3N0b3JhZ2UuanM/MTU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZW1hU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IHNjaGVtYV8xID0gcmVxdWlyZShcIi4vc2NoZW1hXCIpO1xuZXhwb3J0cy5zY2hlbWFTdG9yYWdlID0gbmV3IHNjaGVtYV8xLkFzblNjaGVtYVN0b3JhZ2UoKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNjaGVtYVN0b3JhZ2UiLCJzY2hlbWFfMSIsInJlcXVpcmUiLCJBc25TY2hlbWFTdG9yYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/storage.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BitString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(rsc)/../../node_modules/pvtsutils/build/index.js\");\nclass BitString {\n    constructor(params, unusedBits = 0){\n        this.unusedBits = 0;\n        this.value = new ArrayBuffer(0);\n        if (params) {\n            if (typeof params === \"number\") {\n                this.fromNumber(params);\n            } else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {\n                this.unusedBits = unusedBits;\n                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);\n            } else {\n                throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.BitString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n        }\n        this.unusedBits = asn.valueBlock.unusedBits;\n        this.value = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.BitString({\n            unusedBits: this.unusedBits,\n            valueHex: this.value\n        });\n    }\n    toSchema(name) {\n        return new asn1js.BitString({\n            name\n        });\n    }\n    toNumber() {\n        let res = \"\";\n        const uintArray = new Uint8Array(this.value);\n        for (const octet of uintArray){\n            res += octet.toString(2).padStart(8, \"0\");\n        }\n        res = res.split(\"\").reverse().join(\"\");\n        if (this.unusedBits) {\n            res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n        }\n        return parseInt(res, 2);\n    }\n    fromNumber(value) {\n        let bits = value.toString(2);\n        const octetSize = bits.length + 7 >> 3;\n        this.unusedBits = (octetSize << 3) - bits.length;\n        const octets = new Uint8Array(octetSize);\n        bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n        let index = 0;\n        while(index < octetSize){\n            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n            index++;\n        }\n        this.value = octets.buffer;\n    }\n}\nexports.BitString = BitString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvYml0X3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUMvQixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxvRUFBVztBQUN2QyxNQUFNRjtJQUNGSSxZQUFZQyxNQUFNLEVBQUVDLGFBQWEsQ0FBQyxDQUFFO1FBQ2hDLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ1AsS0FBSyxHQUFHLElBQUlRLFlBQVk7UUFDN0IsSUFBSUYsUUFBUTtZQUNSLElBQUksT0FBT0EsV0FBVyxVQUFVO2dCQUM1QixJQUFJLENBQUNHLFVBQVUsQ0FBQ0g7WUFDcEIsT0FDSyxJQUFJRixZQUFZTSxxQkFBcUIsQ0FBQ0MsY0FBYyxDQUFDTCxTQUFTO2dCQUMvRCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7Z0JBQ2xCLElBQUksQ0FBQ1AsS0FBSyxHQUFHSSxZQUFZTSxxQkFBcUIsQ0FBQ0UsYUFBYSxDQUFDTjtZQUNqRSxPQUNLO2dCQUNELE1BQU1PLFVBQVU7WUFDcEI7UUFDSjtJQUNKO0lBQ0FDLFFBQVFDLEdBQUcsRUFBRTtRQUNULElBQUksQ0FBRUEsQ0FBQUEsZUFBZWIsT0FBT0QsU0FBUyxHQUFHO1lBQ3BDLE1BQU0sSUFBSVksVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBQ04sVUFBVSxHQUFHUSxJQUFJQyxVQUFVLENBQUNULFVBQVU7UUFDM0MsSUFBSSxDQUFDUCxLQUFLLEdBQUdlLElBQUlDLFVBQVUsQ0FBQ0MsUUFBUTtRQUNwQyxPQUFPLElBQUk7SUFDZjtJQUNBQyxRQUFRO1FBQ0osT0FBTyxJQUFJaEIsT0FBT0QsU0FBUyxDQUFDO1lBQUVNLFlBQVksSUFBSSxDQUFDQSxVQUFVO1lBQUVVLFVBQVUsSUFBSSxDQUFDakIsS0FBSztRQUFDO0lBQ3BGO0lBQ0FtQixTQUFTQyxJQUFJLEVBQUU7UUFDWCxPQUFPLElBQUlsQixPQUFPRCxTQUFTLENBQUM7WUFBRW1CO1FBQUs7SUFDdkM7SUFDQUMsV0FBVztRQUNQLElBQUlDLE1BQU07UUFDVixNQUFNQyxZQUFZLElBQUlDLFdBQVcsSUFBSSxDQUFDeEIsS0FBSztRQUMzQyxLQUFLLE1BQU15QixTQUFTRixVQUFXO1lBQzNCRCxPQUFPRyxNQUFNQyxRQUFRLENBQUMsR0FBR0MsUUFBUSxDQUFDLEdBQUc7UUFDekM7UUFDQUwsTUFBTUEsSUFBSU0sS0FBSyxDQUFDLElBQUlDLE9BQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ25DLElBQUksSUFBSSxDQUFDdkIsVUFBVSxFQUFFO1lBQ2pCZSxNQUFNQSxJQUFJUyxLQUFLLENBQUMsSUFBSSxDQUFDeEIsVUFBVSxFQUFFb0IsUUFBUSxDQUFDLElBQUksQ0FBQ3BCLFVBQVUsRUFBRTtRQUMvRDtRQUNBLE9BQU95QixTQUFTVixLQUFLO0lBQ3pCO0lBQ0FiLFdBQVdULEtBQUssRUFBRTtRQUNkLElBQUlpQyxPQUFPakMsTUFBTTBCLFFBQVEsQ0FBQztRQUMxQixNQUFNUSxZQUFZLEtBQU1DLE1BQU0sR0FBRyxLQUFNO1FBQ3ZDLElBQUksQ0FBQzVCLFVBQVUsR0FBRyxDQUFDMkIsYUFBYSxLQUFLRCxLQUFLRSxNQUFNO1FBQ2hELE1BQU1DLFNBQVMsSUFBSVosV0FBV1U7UUFDOUJELE9BQU9BLEtBQUtOLFFBQVEsQ0FBQ08sYUFBYSxHQUFHLEtBQUtOLEtBQUssQ0FBQyxJQUFJQyxPQUFPLEdBQUdDLElBQUksQ0FBQztRQUNuRSxJQUFJTyxRQUFRO1FBQ1osTUFBT0EsUUFBUUgsVUFBVztZQUN0QkUsTUFBTSxDQUFDQyxNQUFNLEdBQUdMLFNBQVNDLEtBQUtGLEtBQUssQ0FBQ00sU0FBUyxHQUFHLENBQUNBLFNBQVMsS0FBSyxJQUFJO1lBQ25FQTtRQUNKO1FBQ0EsSUFBSSxDQUFDckMsS0FBSyxHQUFHb0MsT0FBT0UsTUFBTTtJQUM5QjtBQUNKO0FBQ0F2QyxpQkFBaUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvYml0X3N0cmluZy5qcz85NDA3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY2xhc3MgQml0U3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIHVudXNlZEJpdHMgPSAwKSB7XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW51c2VkQml0cyA9IHVudXNlZEJpdHM7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mICdwYXJhbXMnIGFyZ3VtZW50IGZvciBCaXRTdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbUFTTihhc24pIHtcbiAgICAgICAgaWYgKCEoYXNuIGluc3RhbmNlb2YgYXNuMWpzLkJpdFN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYXNuJyBpcyBub3QgaW5zdGFuY2Ugb2YgQVNOLjEgQml0U3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IGFzbi52YWx1ZUJsb2NrLnVudXNlZEJpdHM7XG4gICAgICAgIHRoaXMudmFsdWUgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvQVNOKCkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyB1bnVzZWRCaXRzOiB0aGlzLnVudXNlZEJpdHMsIHZhbHVlSGV4OiB0aGlzLnZhbHVlIH0pO1xuICAgIH1cbiAgICB0b1NjaGVtYShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLkJpdFN0cmluZyh7IG5hbWUgfSk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgY29uc3QgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgb2N0ZXQgb2YgdWludEFycmF5KSB7XG4gICAgICAgICAgICByZXMgKz0gb2N0ZXQudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IHJlcy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgaWYgKHRoaXMudW51c2VkQml0cykge1xuICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKHRoaXMudW51c2VkQml0cykucGFkU3RhcnQodGhpcy51bnVzZWRCaXRzLCBcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJlcywgMik7XG4gICAgfVxuICAgIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGJpdHMgPSB2YWx1ZS50b1N0cmluZygyKTtcbiAgICAgICAgY29uc3Qgb2N0ZXRTaXplID0gKGJpdHMubGVuZ3RoICsgNykgPj4gMztcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gKG9jdGV0U2l6ZSA8PCAzKSAtIGJpdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBvY3RldHMgPSBuZXcgVWludDhBcnJheShvY3RldFNpemUpO1xuICAgICAgICBiaXRzID0gYml0cy5wYWRTdGFydChvY3RldFNpemUgPDwgMywgXCIwXCIpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBvY3RldFNpemUpIHtcbiAgICAgICAgICAgIG9jdGV0c1tpbmRleF0gPSBwYXJzZUludChiaXRzLnNsaWNlKGluZGV4IDw8IDMsIChpbmRleCA8PCAzKSArIDgpLCAyKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IG9jdGV0cy5idWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRTdHJpbmcgPSBCaXRTdHJpbmc7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCaXRTdHJpbmciLCJhc24xanMiLCJyZXF1aXJlIiwicHZ0c3V0aWxzXzEiLCJjb25zdHJ1Y3RvciIsInBhcmFtcyIsInVudXNlZEJpdHMiLCJBcnJheUJ1ZmZlciIsImZyb21OdW1iZXIiLCJCdWZmZXJTb3VyY2VDb252ZXJ0ZXIiLCJpc0J1ZmZlclNvdXJjZSIsInRvQXJyYXlCdWZmZXIiLCJUeXBlRXJyb3IiLCJmcm9tQVNOIiwiYXNuIiwidmFsdWVCbG9jayIsInZhbHVlSGV4IiwidG9BU04iLCJ0b1NjaGVtYSIsIm5hbWUiLCJ0b051bWJlciIsInJlcyIsInVpbnRBcnJheSIsIlVpbnQ4QXJyYXkiLCJvY3RldCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJzcGxpdCIsInJldmVyc2UiLCJqb2luIiwic2xpY2UiLCJwYXJzZUludCIsImJpdHMiLCJvY3RldFNpemUiLCJsZW5ndGgiLCJvY3RldHMiLCJpbmRleCIsImJ1ZmZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/../../node_modules/tslib/tslib.es6.js\");\ntslib_1.__exportStar(__webpack_require__(/*! ./bit_string */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./octet_string */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsMERBQU87QUFDL0JELFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsa0dBQWMsR0FBR0g7QUFDOUNFLFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsc0dBQWdCLEdBQUdIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2luZGV4LmpzPzczZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYml0X3N0cmluZ1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vY3RldF9zdHJpbmdcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJfX2V4cG9ydFN0YXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OctetString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(rsc)/../../node_modules/pvtsutils/build/index.js\");\nclass OctetString {\n    constructor(param){\n        if (typeof param === \"number\") {\n            this.buffer = new ArrayBuffer(param);\n        } else {\n            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {\n                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);\n            } else if (Array.isArray(param)) {\n                this.buffer = new Uint8Array(param);\n            } else {\n                this.buffer = new ArrayBuffer(0);\n            }\n        }\n    }\n    get byteLength() {\n        return this.buffer.byteLength;\n    }\n    get byteOffset() {\n        return 0;\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.OctetString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 OctetString\");\n        }\n        this.buffer = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.OctetString({\n            valueHex: this.buffer\n        });\n    }\n    toSchema(name) {\n        return new asn1js.OctetString({\n            name\n        });\n    }\n}\nexports.OctetString = OctetString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvb2N0ZXRfc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLDhEQUFRO0FBQy9CLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLG9FQUFXO0FBQ3ZDLE1BQU1GO0lBQ0ZJLFlBQVlDLEtBQUssQ0FBRTtRQUNmLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzNCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlDLFlBQVlGO1FBQ2xDLE9BQ0s7WUFDRCxJQUFJRixZQUFZSyxxQkFBcUIsQ0FBQ0MsY0FBYyxDQUFDSixRQUFRO2dCQUN6RCxJQUFJLENBQUNDLE1BQU0sR0FBR0gsWUFBWUsscUJBQXFCLENBQUNFLGFBQWEsQ0FBQ0w7WUFDbEUsT0FDSyxJQUFJTSxNQUFNQyxPQUFPLENBQUNQLFFBQVE7Z0JBQzNCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlPLFdBQVdSO1lBQ2pDLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsWUFBWTtZQUNsQztRQUNKO0lBQ0o7SUFDQSxJQUFJTyxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNSLE1BQU0sQ0FBQ1EsVUFBVTtJQUNqQztJQUNBLElBQUlDLGFBQWE7UUFDYixPQUFPO0lBQ1g7SUFDQUMsUUFBUUMsR0FBRyxFQUFFO1FBQ1QsSUFBSSxDQUFFQSxDQUFBQSxlQUFlaEIsT0FBT0QsV0FBVyxHQUFHO1lBQ3RDLE1BQU0sSUFBSWtCLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNaLE1BQU0sR0FBR1csSUFBSUUsVUFBVSxDQUFDQyxRQUFRO1FBQ3JDLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFFBQVE7UUFDSixPQUFPLElBQUlwQixPQUFPRCxXQUFXLENBQUM7WUFBRW9CLFVBQVUsSUFBSSxDQUFDZCxNQUFNO1FBQUM7SUFDMUQ7SUFDQWdCLFNBQVNDLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSXRCLE9BQU9ELFdBQVcsQ0FBQztZQUFFdUI7UUFBSztJQUN6QztBQUNKO0FBQ0F6QixtQkFBbUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvb2N0ZXRfc3RyaW5nLmpzP2ViMTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9jdGV0U3RyaW5nID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IHB2dHN1dGlsc18xID0gcmVxdWlyZShcInB2dHN1dGlsc1wiKTtcbmNsYXNzIE9jdGV0U3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBieXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGJ5dGVPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmcm9tQVNOKGFzbikge1xuICAgICAgICBpZiAoIShhc24gaW5zdGFuY2VvZiBhc24xanMuT2N0ZXRTdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2FzbicgaXMgbm90IGluc3RhbmNlIG9mIEFTTi4xIE9jdGV0U3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYXNuLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0FTTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuT2N0ZXRTdHJpbmcoeyB2YWx1ZUhleDogdGhpcy5idWZmZXIgfSk7XG4gICAgfVxuICAgIHRvU2NoZW1hKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuT2N0ZXRTdHJpbmcoeyBuYW1lIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuT2N0ZXRTdHJpbmcgPSBPY3RldFN0cmluZztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk9jdGV0U3RyaW5nIiwiYXNuMWpzIiwicmVxdWlyZSIsInB2dHN1dGlsc18xIiwiY29uc3RydWN0b3IiLCJwYXJhbSIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwiaXNCdWZmZXJTb3VyY2UiLCJ0b0FycmF5QnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5IiwiVWludDhBcnJheSIsImJ5dGVMZW5ndGgiLCJieXRlT2Zmc2V0IiwiZnJvbUFTTiIsImFzbiIsIlR5cGVFcnJvciIsInZhbHVlQmxvY2siLCJ2YWx1ZUhleCIsInRvQVNOIiwidG9TY2hlbWEiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/json-schema/build/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@peculiar/json-schema/build/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass JsonError extends Error {\n    constructor(message, innerError){\n        super(innerError ? `${message}. See the inner exception for more details.` : message);\n        this.message = message;\n        this.innerError = innerError;\n    }\n}\nclass TransformError extends JsonError {\n    constructor(schema, message, innerError){\n        super(message, innerError);\n        this.schema = schema;\n    }\n}\nclass ParserError extends TransformError {\n    constructor(schema, message, innerError){\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\n    }\n}\nclass ValidationError extends JsonError {\n}\nclass SerializerError extends JsonError {\n    constructor(schemaName, message, innerError){\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\n        this.schemaName = schemaName;\n    }\n}\nclass KeyError extends ParserError {\n    constructor(schema, keys, errors = {}){\n        super(schema, \"Some keys doesn't match to schema\");\n        this.keys = keys;\n        this.errors = errors;\n    }\n}\n(function(JsonPropTypes) {\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\n})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));\nfunction checkType(value, type) {\n    switch(type){\n        case exports.JsonPropTypes.Boolean:\n            return typeof value === \"boolean\";\n        case exports.JsonPropTypes.Number:\n            return typeof value === \"number\";\n        case exports.JsonPropTypes.String:\n            return typeof value === \"string\";\n    }\n    return true;\n}\nfunction throwIfTypeIsWrong(value, type) {\n    if (!checkType(value, type)) {\n        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);\n    }\n}\nfunction isConvertible(target) {\n    if (target && target.prototype) {\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\n            return true;\n        } else {\n            return isConvertible(target.prototype);\n        }\n    } else {\n        return !!(target && target.toJSON && target.fromJSON);\n    }\n}\nclass JsonSchemaStorage {\n    constructor(){\n        this.items = new Map();\n    }\n    has(target) {\n        return this.items.has(target) || !!this.findParentSchema(target);\n    }\n    get(target) {\n        const schema = this.items.get(target) || this.findParentSchema(target);\n        if (!schema) {\n            throw new Error(\"Cannot get schema for current target\");\n        }\n        return schema;\n    }\n    create(target) {\n        const schema = {\n            names: {}\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.names = {};\n            for(const name in parentSchema.names){\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\n            }\n        }\n        schema.target = target;\n        return schema;\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = target.__proto__;\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nconst DEFAULT_SCHEMA = \"default\";\nconst schemaStorage = new JsonSchemaStorage();\nclass PatternValidation {\n    constructor(pattern){\n        this.pattern = new RegExp(pattern);\n    }\n    validate(value) {\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\n        if (typeof value !== \"string\") {\n            throw new ValidationError(\"Incoming value must be string\");\n        }\n        if (!pattern.exec(value)) {\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\n        }\n    }\n}\nclass InclusiveValidation {\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){\n        this.min = min;\n        this.max = max;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\n        if (!(this.min <= value && value <= this.max)) {\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\n        }\n    }\n}\nclass ExclusiveValidation {\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){\n        this.min = min;\n        this.max = max;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\n        if (!(this.min < value && value < this.max)) {\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\n        }\n    }\n}\nclass LengthValidation {\n    constructor(length, minLength, maxLength){\n        this.length = length;\n        this.minLength = minLength;\n        this.maxLength = maxLength;\n    }\n    validate(value) {\n        if (this.length !== undefined) {\n            if (value.length !== this.length) {\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\n            }\n            return;\n        }\n        if (this.minLength !== undefined) {\n            if (value.length < this.minLength) {\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\n            }\n        }\n        if (this.maxLength !== undefined) {\n            if (value.length > this.maxLength) {\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\n            }\n        }\n    }\n}\nclass EnumerationValidation {\n    constructor(enumeration){\n        this.enumeration = enumeration;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);\n        if (!this.enumeration.includes(value)) {\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v)=>`'${v}'`).join(\", \")}`);\n        }\n    }\n}\nclass JsonTransform {\n    static checkValues(data, schemaItem) {\n        const values = Array.isArray(data) ? data : [\n            data\n        ];\n        for (const value of values){\n            for (const validation of schemaItem.validations){\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\n                    validation.validate(data);\n                } else {\n                    validation.validate(value);\n                }\n            }\n        }\n    }\n    static checkTypes(value, schemaItem) {\n        if (schemaItem.repeated && !Array.isArray(value)) {\n            throw new TypeError(\"Value must be Array\");\n        }\n        if (typeof schemaItem.type === \"number\") {\n            const values = Array.isArray(value) ? value : [\n                value\n            ];\n            for (const v of values){\n                throwIfTypeIsWrong(v, schemaItem.type);\n            }\n        }\n    }\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\n        return {\n            ...schema.names[DEFAULT_SCHEMA],\n            ...schema.names[name]\n        };\n    }\n}\nclass JsonSerializer extends JsonTransform {\n    static serialize(obj, options, replacer, space) {\n        const json = this.toJSON(obj, options);\n        return JSON.stringify(json, replacer, space);\n    }\n    static toJSON(obj, options = {}) {\n        let res;\n        let targetSchema = options.targetSchema;\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\n        if (isConvertible(obj)) {\n            return obj.toJSON();\n        }\n        if (Array.isArray(obj)) {\n            res = [];\n            for (const item of obj){\n                res.push(this.toJSON(item, options));\n            }\n        } else if (typeof obj === \"object\") {\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\n            }\n            targetSchema = targetSchema || obj.constructor;\n            if (schemaStorage.has(targetSchema)) {\n                const schema = schemaStorage.get(targetSchema);\n                res = {};\n                const namedSchema = this.getSchemaByName(schema, schemaName);\n                for(const key in namedSchema){\n                    try {\n                        const item = namedSchema[key];\n                        const objItem = obj[key];\n                        let value;\n                        if (item.optional && objItem === undefined || item.defaultValue !== undefined && objItem === item.defaultValue) {\n                            continue;\n                        }\n                        if (!item.optional && objItem === undefined) {\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\n                        }\n                        if (typeof item.type === \"number\") {\n                            if (item.converter) {\n                                if (item.repeated) {\n                                    value = objItem.map((el)=>item.converter.toJSON(el, obj));\n                                } else {\n                                    value = item.converter.toJSON(objItem, obj);\n                                }\n                            } else {\n                                value = objItem;\n                            }\n                        } else {\n                            if (item.repeated) {\n                                value = objItem.map((el)=>this.toJSON(el, {\n                                        schemaName\n                                    }));\n                            } else {\n                                value = this.toJSON(objItem, {\n                                    schemaName\n                                });\n                            }\n                        }\n                        this.checkTypes(value, item);\n                        this.checkValues(value, item);\n                        res[item.name || key] = value;\n                    } catch (e) {\n                        if (e instanceof SerializerError) {\n                            throw e;\n                        } else {\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\n                        }\n                    }\n                }\n            } else {\n                res = {};\n                for(const key in obj){\n                    res[key] = this.toJSON(obj[key], {\n                        schemaName\n                    });\n                }\n            }\n        } else {\n            res = obj;\n        }\n        return res;\n    }\n}\nclass JsonParser extends JsonTransform {\n    static parse(data, options) {\n        const obj = JSON.parse(data);\n        return this.fromJSON(obj, options);\n    }\n    static fromJSON(target, options) {\n        const targetSchema = options.targetSchema;\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\n        const obj = new targetSchema();\n        if (isConvertible(obj)) {\n            return obj.fromJSON(target);\n        }\n        const schema = schemaStorage.get(targetSchema);\n        const namedSchema = this.getSchemaByName(schema, schemaName);\n        const keyErrors = {};\n        if (options.strictProperty && !Array.isArray(target)) {\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\n        }\n        for(const key in namedSchema){\n            try {\n                const item = namedSchema[key];\n                const name = item.name || key;\n                const value = target[name];\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\n                    continue;\n                }\n                if (!item.optional && value === undefined) {\n                    throw new ParserError(schema, `Property '${name}' is required.`);\n                }\n                this.checkTypes(value, item);\n                this.checkValues(value, item);\n                if (typeof item.type === \"number\") {\n                    if (item.converter) {\n                        if (item.repeated) {\n                            obj[key] = value.map((el)=>item.converter.fromJSON(el, obj));\n                        } else {\n                            obj[key] = item.converter.fromJSON(value, obj);\n                        }\n                    } else {\n                        obj[key] = value;\n                    }\n                } else {\n                    const newOptions = {\n                        ...options,\n                        targetSchema: item.type,\n                        schemaName\n                    };\n                    if (item.repeated) {\n                        obj[key] = value.map((el)=>this.fromJSON(el, newOptions));\n                    } else {\n                        obj[key] = this.fromJSON(value, newOptions);\n                    }\n                }\n            } catch (e) {\n                if (!(e instanceof ParserError)) {\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\n                }\n                if (options.strictAllKeys) {\n                    keyErrors[key] = e;\n                } else {\n                    throw e;\n                }\n            }\n        }\n        const keys = Object.keys(keyErrors);\n        if (keys.length) {\n            throw new KeyError(schema, keys, keyErrors);\n        }\n        return obj;\n    }\n    static checkStrictProperty(target, namedSchema, schema) {\n        const jsonProps = Object.keys(target);\n        const schemaProps = Object.keys(namedSchema);\n        const keys = [];\n        for (const key of jsonProps){\n            if (schemaProps.indexOf(key) === -1) {\n                keys.push(key);\n            }\n        }\n        if (keys.length) {\n            throw new KeyError(schema, keys);\n        }\n    }\n}\nfunction getValidations(item) {\n    const validations = [];\n    if (item.pattern) {\n        validations.push(new PatternValidation(item.pattern));\n    }\n    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\n        }\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\n        }\n        if (item.enumeration !== undefined) {\n            validations.push(new EnumerationValidation(item.enumeration));\n        }\n    }\n    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\n        }\n    }\n    return validations;\n}\nconst JsonProp = (options = {})=>(target, propertyKey)=>{\n        const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\n        let schema;\n        if (!schemaStorage.has(target.constructor)) {\n            schema = schemaStorage.create(target.constructor);\n            schemaStorage.set(target.constructor, schema);\n        } else {\n            schema = schemaStorage.get(target.constructor);\n            if (schema.target !== target.constructor) {\n                schema = schemaStorage.create(target.constructor);\n                schemaStorage.set(target.constructor, schema);\n            }\n        }\n        const defaultSchema = {\n            type: exports.JsonPropTypes.Any,\n            validations: []\n        };\n        const copyOptions = Object.assign(defaultSchema, options);\n        copyOptions.validations = getValidations(copyOptions);\n        if (typeof copyOptions.type !== \"number\") {\n            if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\n                throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\n            }\n        }\n        let schemaNames;\n        if (Array.isArray(options.schema)) {\n            schemaNames = options.schema;\n        } else {\n            schemaNames = [\n                options.schema || DEFAULT_SCHEMA\n            ];\n        }\n        for (const schemaName of schemaNames){\n            if (!schema.names[schemaName]) {\n                schema.names[schemaName] = {};\n            }\n            const namedSchema = schema.names[schemaName];\n            namedSchema[propertyKey] = copyOptions;\n        }\n    };\nexports.JsonError = JsonError;\nexports.JsonParser = JsonParser;\nexports.JsonProp = JsonProp;\nexports.JsonSerializer = JsonSerializer;\nexports.KeyError = KeyError;\nexports.ParserError = ParserError;\nexports.SerializerError = SerializerError;\nexports.TransformError = TransformError;\nexports.ValidationError = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9qc29uLXNjaGVtYS9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELE1BQU1DLGtCQUFrQkM7SUFDcEJDLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxDQUFFO1FBQzdCLEtBQUssQ0FBQ0EsYUFDQSxDQUFDLEVBQUVELFFBQVEsMkNBQTJDLENBQUMsR0FDdkRBO1FBQ04sSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO0lBQ3RCO0FBQ0o7QUFFQSxNQUFNQyx1QkFBdUJMO0lBQ3pCRSxZQUFZSSxNQUFNLEVBQUVILE9BQU8sRUFBRUMsVUFBVSxDQUFFO1FBQ3JDLEtBQUssQ0FBQ0QsU0FBU0M7UUFDZixJQUFJLENBQUNFLE1BQU0sR0FBR0E7SUFDbEI7QUFDSjtBQUVBLE1BQU1DLG9CQUFvQkY7SUFDdEJILFlBQVlJLE1BQU0sRUFBRUgsT0FBTyxFQUFFQyxVQUFVLENBQUU7UUFDckMsS0FBSyxDQUFDRSxRQUFRLENBQUMsdUJBQXVCLEVBQUVBLE9BQU9FLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLFVBQVUsRUFBRU4sUUFBUSxDQUFDLEVBQUVDO0lBQ3RGO0FBQ0o7QUFFQSxNQUFNTSx3QkFBd0JWO0FBQzlCO0FBRUEsTUFBTVcsd0JBQXdCWDtJQUMxQkUsWUFBWVUsVUFBVSxFQUFFVCxPQUFPLEVBQUVDLFVBQVUsQ0FBRTtRQUN6QyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsRUFBRVEsV0FBVyxVQUFVLEVBQUVULFFBQVEsQ0FBQyxFQUFFQztRQUNoRSxJQUFJLENBQUNRLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUVBLE1BQU1DLGlCQUFpQk47SUFDbkJMLFlBQVlJLE1BQU0sRUFBRVEsSUFBSSxFQUFFQyxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ25DLEtBQUss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dkMsUUFBUTdFLE1BQU0sSUFBSW1DO2FBQWU7UUFDcEQ7UUFDQSxLQUFLLE1BQU03QixjQUFjOEcsWUFBYTtZQUNsQyxJQUFJLENBQUNwSCxPQUFPNkIsS0FBSyxDQUFDdkIsV0FBVyxFQUFFO2dCQUMzQk4sT0FBTzZCLEtBQUssQ0FBQ3ZCLFdBQVcsR0FBRyxDQUFDO1lBQ2hDO1lBQ0EsTUFBTWlGLGNBQWN2RixPQUFPNkIsS0FBSyxDQUFDdkIsV0FBVztZQUM1Q2lGLFdBQVcsQ0FBQ3lCLFlBQVksR0FBR0c7UUFDL0I7SUFDSjtBQUVBM0gsaUJBQWlCLEdBQUdFO0FBQ3BCRixrQkFBa0IsR0FBR3VHO0FBQ3JCdkcsZ0JBQWdCLEdBQUd1SDtBQUNuQnZILHNCQUFzQixHQUFHa0Y7QUFDekJsRixnQkFBZ0IsR0FBR2U7QUFDbkJmLG1CQUFtQixHQUFHUztBQUN0QlQsdUJBQXVCLEdBQUdhO0FBQzFCYixzQkFBc0IsR0FBR087QUFDekJQLHVCQUF1QixHQUFHWSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1YmJsZWd1bS8uLi8uLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2pzb24tc2NoZW1hL2J1aWxkL2luZGV4LmpzPzZmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAsIFBlY3VsaWFyIFZlbnR1cmVzLCBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY2xhc3MgSnNvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKGlubmVyRXJyb3JcclxuICAgICAgICAgICAgPyBgJHttZXNzYWdlfS4gU2VlIHRoZSBpbm5lciBleGNlcHRpb24gZm9yIG1vcmUgZGV0YWlscy5gXHJcbiAgICAgICAgICAgIDogbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICB0aGlzLmlubmVyRXJyb3IgPSBpbm5lckVycm9yO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFRyYW5zZm9ybUVycm9yIGV4dGVuZHMgSnNvbkVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgVHJhbnNmb3JtRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoc2NoZW1hLCBgSlNPTiBkb2Vzbid0IG1hdGNoIHRvICcke3NjaGVtYS50YXJnZXQubmFtZX0nIHNjaGVtYS4gJHttZXNzYWdlfWAsIGlubmVyRXJyb3IpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbn1cblxuY2xhc3MgU2VyaWFsaXplckVycm9yIGV4dGVuZHMgSnNvbkVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYU5hbWUsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihgQ2Fubm90IHNlcmlhbGl6ZSBieSAnJHtzY2hlbWFOYW1lfScgc2NoZW1hLiAke21lc3NhZ2V9YCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hTmFtZTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBLZXlFcnJvciBleHRlbmRzIFBhcnNlckVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwga2V5cywgZXJyb3JzID0ge30pIHtcclxuICAgICAgICBzdXBlcihzY2hlbWEsIFwiU29tZSBrZXlzIGRvZXNuJ3QgbWF0Y2ggdG8gc2NoZW1hXCIpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbn1cblxuKGZ1bmN0aW9uIChKc29uUHJvcFR5cGVzKSB7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJBbnlcIl0gPSAwXSA9IFwiQW55XCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJCb29sZWFuXCJdID0gMV0gPSBcIkJvb2xlYW5cIjtcclxuICAgIEpzb25Qcm9wVHlwZXNbSnNvblByb3BUeXBlc1tcIk51bWJlclwiXSA9IDJdID0gXCJOdW1iZXJcIjtcclxuICAgIEpzb25Qcm9wVHlwZXNbSnNvblByb3BUeXBlc1tcIlN0cmluZ1wiXSA9IDNdID0gXCJTdHJpbmdcIjtcclxufSkoZXhwb3J0cy5Kc29uUHJvcFR5cGVzIHx8IChleHBvcnRzLkpzb25Qcm9wVHlwZXMgPSB7fSkpO1xuXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLkJvb2xlYW46XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcjpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5TdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICghY2hlY2tUeXBlKHZhbHVlLCB0eXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFZhbHVlIG11c3QgYmUgJHtleHBvcnRzLkpzb25Qcm9wVHlwZXNbdHlwZV19YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNDb252ZXJ0aWJsZSh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlLnRvSlNPTiAmJiB0YXJnZXQucHJvdG90eXBlLmZyb21KU09OKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQ29udmVydGlibGUodGFyZ2V0LnByb3RvdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRhcmdldCAmJiB0YXJnZXQudG9KU09OICYmIHRhcmdldC5mcm9tSlNPTik7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSnNvblNjaGVtYVN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGhhcyh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5oYXModGFyZ2V0KSB8fCAhIXRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZ2V0KHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHRhcmdldCkgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFzY2hlbWEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBzY2hlbWEgZm9yIGN1cnJlbnQgdGFyZ2V0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHsgbmFtZXM6IHt9IH07XHJcbiAgICAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gdGhpcy5maW5kUGFyZW50U2NoZW1hKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYSkge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNjaGVtYSwgcGFyZW50U2NoZW1hKTtcclxuICAgICAgICAgICAgc2NoZW1hLm5hbWVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBwYXJlbnRTY2hlbWEubmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIHNjaGVtYS5uYW1lc1tuYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFNjaGVtYS5uYW1lc1tuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2NoZW1hLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICByZXR1cm4gc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgc2V0KHRhcmdldCwgc2NoZW1hKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5zZXQodGFyZ2V0LCBzY2hlbWEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0YXJnZXQuX19wcm90b19fO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQocGFyZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYSB8fCB0aGlzLmZpbmRQYXJlbnRTY2hlbWEocGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgREVGQVVMVF9TQ0hFTUEgPSBcImRlZmF1bHRcIjtcclxuY29uc3Qgc2NoZW1hU3RvcmFnZSA9IG5ldyBKc29uU2NoZW1hU3RvcmFnZSgpO1xuXG5jbGFzcyBQYXR0ZXJuVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XHJcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAodGhpcy5wYXR0ZXJuLnNvdXJjZSwgdGhpcy5wYXR0ZXJuLmZsYWdzKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJJbmNvbWluZyB2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwYXR0ZXJuLmV4ZWModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gcGF0dGVybiAnJHtwYXR0ZXJuLnRvU3RyaW5nKCl9J2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBJbmNsdXNpdmVWYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG1pbiA9IE51bWJlci5NSU5fVkFMVUUsIG1heCA9IE51bWJlci5NQVhfVkFMVUUpIHtcclxuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcclxuICAgICAgICB0aGlzLm1heCA9IG1heDtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCBleHBvcnRzLkpzb25Qcm9wVHlwZXMuTnVtYmVyKTtcclxuICAgICAgICBpZiAoISh0aGlzLm1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB0aGlzLm1heCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW4gPT09IE51bWJlci5NSU5fVkFMVUUgPyBcIk1JTlwiIDogdGhpcy5taW47XHJcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4ID09PSBOdW1iZXIuTUFYX1ZBTFVFID8gXCJNQVhcIiA6IHRoaXMubWF4O1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIGRpYXBhc29uIFske21pbn0sJHttYXh9XWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBFeGNsdXNpdmVWYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG1pbiA9IE51bWJlci5NSU5fVkFMVUUsIG1heCA9IE51bWJlci5NQVhfVkFMVUUpIHtcclxuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcclxuICAgICAgICB0aGlzLm1heCA9IG1heDtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCBleHBvcnRzLkpzb25Qcm9wVHlwZXMuTnVtYmVyKTtcclxuICAgICAgICBpZiAoISh0aGlzLm1pbiA8IHZhbHVlICYmIHZhbHVlIDwgdGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gXCJNSU5cIiA6IHRoaXMubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLm1heCA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/IFwiTUFYXCIgOiB0aGlzLm1heDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBkaWFwYXNvbiAoJHttaW59LCR7bWF4fSlgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgTGVuZ3RoVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBtaW5MZW5ndGg7XHJcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBsZW5ndGggbXVzdCBiZSBleGFjdGx5ICR7dGhpcy5sZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHRoaXMubWluTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBsZW5ndGggbXVzdCBiZSBtb3JlIHRoYW4gJHt0aGlzLm1pbkxlbmd0aH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gJHt0aGlzLm1heExlbmd0aH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRW51bWVyYXRpb25WYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudW1lcmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5lbnVtZXJhdGlvbiA9IGVudW1lcmF0aW9uO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIGV4cG9ydHMuSnNvblByb3BUeXBlcy5TdHJpbmcpO1xyXG4gICAgICAgIGlmICghdGhpcy5lbnVtZXJhdGlvbi5pbmNsdWRlcyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbXVzdCBiZSBvbmUgb2YgJHt0aGlzLmVudW1lcmF0aW9uLm1hcCgodikgPT4gYCcke3Z9J2ApLmpvaW4oXCIsIFwiKX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgY2hlY2tWYWx1ZXMoZGF0YSwgc2NoZW1hSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsaWRhdGlvbiBvZiBzY2hlbWFJdGVtLnZhbGlkYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvbiBpbnN0YW5jZW9mIExlbmd0aFZhbGlkYXRpb24gJiYgc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb24udmFsaWRhdGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnZhbGlkYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja1R5cGVzKHZhbHVlLCBzY2hlbWFJdGVtKSB7XHJcbiAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJWYWx1ZSBtdXN0IGJlIEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dJZlR5cGVJc1dyb25nKHYsIHNjaGVtYUl0ZW0udHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0U2NoZW1hQnlOYW1lKHNjaGVtYSwgbmFtZSA9IERFRkFVTFRfU0NIRU1BKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgLi4uc2NoZW1hLm5hbWVzW0RFRkFVTFRfU0NIRU1BXSwgLi4uc2NoZW1hLm5hbWVzW25hbWVdIH07XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSnNvblNlcmlhbGl6ZXIgZXh0ZW5kcyBKc29uVHJhbnNmb3JtIHtcclxuICAgIHN0YXRpYyBzZXJpYWxpemUob2JqLCBvcHRpb25zLCByZXBsYWNlciwgc3BhY2UpIHtcclxuICAgICAgICBjb25zdCBqc29uID0gdGhpcy50b0pTT04ob2JqLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNvbiwgcmVwbGFjZXIsIHNwYWNlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0b0pTT04ob2JqLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICBsZXQgcmVzO1xyXG4gICAgICAgIGxldCB0YXJnZXRTY2hlbWEgPSBvcHRpb25zLnRhcmdldFNjaGVtYTtcclxuICAgICAgICBjb25zdCBzY2hlbWFOYW1lID0gb3B0aW9ucy5zY2hlbWFOYW1lIHx8IERFRkFVTFRfU0NIRU1BO1xyXG4gICAgICAgIGlmIChpc0NvbnZlcnRpYmxlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai50b0pTT04oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICByZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy50b0pTT04oaXRlbSwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFNjaGVtYSAmJiAhc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0U2NoZW1hKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25FcnJvcihcIkNhbm5vdCBnZXQgc2NoZW1hIGZvciBgdGFyZ2V0U2NoZW1hYCBwYXJhbVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YXJnZXRTY2hlbWEgPSAodGFyZ2V0U2NoZW1hIHx8IG9iai5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChzY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXRTY2hlbWEpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmdldCh0YXJnZXRTY2hlbWEpO1xyXG4gICAgICAgICAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHRoaXMuZ2V0U2NoZW1hQnlOYW1lKHNjaGVtYSwgc2NoZW1hTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lZFNjaGVtYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuYW1lZFNjaGVtYVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmpJdGVtID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpdGVtLm9wdGlvbmFsICYmIG9iakl0ZW0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChpdGVtLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9iakl0ZW0gPT09IGl0ZW0uZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLm9wdGlvbmFsICYmIG9iakl0ZW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6ZXJFcnJvcih0YXJnZXRTY2hlbWEubmFtZSwgYFByb3BlcnR5ICcke2tleX0nIGlzIHJlcXVpcmVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iakl0ZW0ubWFwKChlbCkgPT4gaXRlbS5jb252ZXJ0ZXIudG9KU09OKGVsLCBvYmopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbS5jb252ZXJ0ZXIudG9KU09OKG9iakl0ZW0sIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iakl0ZW0ubWFwKChlbCkgPT4gdGhpcy50b0pTT04oZWwsIHsgc2NoZW1hTmFtZSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG9KU09OKG9iakl0ZW0sIHsgc2NoZW1hTmFtZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVHlwZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVmFsdWVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2l0ZW0ubmFtZSB8fCBrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU2VyaWFsaXplckVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6ZXJFcnJvcihzY2hlbWEudGFyZ2V0Lm5hbWUsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyB3cm9uZy4gJHtlLm1lc3NhZ2V9YCwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gdGhpcy50b0pTT04ob2JqW2tleV0sIHsgc2NoZW1hTmFtZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25QYXJzZXIgZXh0ZW5kcyBKc29uVHJhbnNmb3JtIHtcclxuICAgIHN0YXRpYyBwYXJzZShkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSlNPTihvYmosIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21KU09OKHRhcmdldCwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFNjaGVtYSA9IG9wdGlvbnMudGFyZ2V0U2NoZW1hO1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYU5hbWUgPSBvcHRpb25zLnNjaGVtYU5hbWUgfHwgREVGQVVMVF9TQ0hFTUE7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gbmV3IHRhcmdldFNjaGVtYSgpO1xyXG4gICAgICAgIGlmIChpc0NvbnZlcnRpYmxlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5mcm9tSlNPTih0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmdldCh0YXJnZXRTY2hlbWEpO1xyXG4gICAgICAgIGNvbnN0IG5hbWVkU2NoZW1hID0gdGhpcy5nZXRTY2hlbWFCeU5hbWUoc2NoZW1hLCBzY2hlbWFOYW1lKTtcclxuICAgICAgICBjb25zdCBrZXlFcnJvcnMgPSB7fTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3RQcm9wZXJ0eSAmJiAhQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIEpzb25QYXJzZXIuY2hlY2tTdHJpY3RQcm9wZXJ0eSh0YXJnZXQsIG5hbWVkU2NoZW1hLCBzY2hlbWEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lZFNjaGVtYSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG5hbWVkU2NoZW1hW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gaXRlbS5uYW1lIHx8IGtleTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgKGl0ZW0ub3B0aW9uYWwgfHwgaXRlbS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXRlbS5vcHRpb25hbCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKHNjaGVtYSwgYFByb3BlcnR5ICcke25hbWV9JyBpcyByZXF1aXJlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tUeXBlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVmFsdWVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGl0ZW0udHlwZSkgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUubWFwKChlbCkgPT4gaXRlbS5jb252ZXJ0ZXIuZnJvbUpTT04oZWwsIG9iaikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpdGVtLmNvbnZlcnRlci5mcm9tSlNPTih2YWx1ZSwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTY2hlbWE6IGl0ZW0udHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUubWFwKChlbCkgPT4gdGhpcy5mcm9tSlNPTihlbCwgbmV3T3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB0aGlzLmZyb21KU09OKHZhbHVlLCBuZXdPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBQYXJzZXJFcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gbmV3IFBhcnNlckVycm9yKHNjaGVtYSwgYFByb3BlcnR5ICcke2tleX0nIGlzIHdyb25nLiAke2UubWVzc2FnZX1gLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0cmljdEFsbEtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlFcnJvcnNba2V5XSA9IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrZXlFcnJvcnMpO1xyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5RXJyb3Ioc2NoZW1hLCBrZXlzLCBrZXlFcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNoZWNrU3RyaWN0UHJvcGVydHkodGFyZ2V0LCBuYW1lZFNjaGVtYSwgc2NoZW1hKSB7XHJcbiAgICAgICAgY29uc3QganNvblByb3BzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBzY2hlbWFQcm9wcyA9IE9iamVjdC5rZXlzKG5hbWVkU2NoZW1hKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YganNvblByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKHNjaGVtYSwga2V5cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRpb25zKGl0ZW0pIHtcclxuICAgIGNvbnN0IHZhbGlkYXRpb25zID0gW107XHJcbiAgICBpZiAoaXRlbS5wYXR0ZXJuKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgUGF0dGVyblZhbGlkYXRpb24oaXRlbS5wYXR0ZXJuKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuTnVtYmVyIHx8IGl0ZW0udHlwZSA9PT0gZXhwb3J0cy5Kc29uUHJvcFR5cGVzLkFueSkge1xyXG4gICAgICAgIGlmIChpdGVtLm1pbkluY2x1c2l2ZSAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4SW5jbHVzaXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgSW5jbHVzaXZlVmFsaWRhdGlvbihpdGVtLm1pbkluY2x1c2l2ZSwgaXRlbS5tYXhJbmNsdXNpdmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0ubWluRXhjbHVzaXZlICE9PSB1bmRlZmluZWQgfHwgaXRlbS5tYXhFeGNsdXNpdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBFeGNsdXNpdmVWYWxpZGF0aW9uKGl0ZW0ubWluRXhjbHVzaXZlLCBpdGVtLm1heEV4Y2x1c2l2ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5lbnVtZXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEVudW1lcmF0aW9uVmFsaWRhdGlvbihpdGVtLmVudW1lcmF0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gZXhwb3J0cy5Kc29uUHJvcFR5cGVzLlN0cmluZyB8fCBpdGVtLnJlcGVhdGVkIHx8IGl0ZW0udHlwZSA9PT0gZXhwb3J0cy5Kc29uUHJvcFR5cGVzLkFueSkge1xyXG4gICAgICAgIGlmIChpdGVtLmxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgfHwgaXRlbS5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBMZW5ndGhWYWxpZGF0aW9uKGl0ZW0ubGVuZ3RoLCBpdGVtLm1pbkxlbmd0aCwgaXRlbS5tYXhMZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsaWRhdGlvbnM7XHJcbn1cclxuY29uc3QgSnNvblByb3AgPSAob3B0aW9ucyA9IHt9KSA9PiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xyXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYENhbm5vdCBzZXQgdHlwZSBmb3IgJHtwcm9wZXJ0eUtleX0gcHJvcGVydHkgb2YgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0gc2NoZW1hYDtcclxuICAgIGxldCBzY2hlbWE7XHJcbiAgICBpZiAoIXNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldC5jb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmNyZWF0ZSh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIHNjaGVtYVN0b3JhZ2Uuc2V0KHRhcmdldC5jb25zdHJ1Y3Rvciwgc2NoZW1hKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgaWYgKHNjaGVtYS50YXJnZXQgIT09IHRhcmdldC5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmNyZWF0ZSh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBzY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmYXVsdFNjaGVtYSA9IHtcclxuICAgICAgICB0eXBlOiBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQW55LFxyXG4gICAgICAgIHZhbGlkYXRpb25zOiBbXSxcclxuICAgIH07XHJcbiAgICBjb25zdCBjb3B5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdFNjaGVtYSwgb3B0aW9ucyk7XHJcbiAgICBjb3B5T3B0aW9ucy52YWxpZGF0aW9ucyA9IGdldFZhbGlkYXRpb25zKGNvcHlPcHRpb25zKTtcclxuICAgIGlmICh0eXBlb2YgY29weU9wdGlvbnMudHlwZSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGlmICghc2NoZW1hU3RvcmFnZS5oYXMoY29weU9wdGlvbnMudHlwZSkgJiYgIWlzQ29udmVydGlibGUoY29weU9wdGlvbnMudHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTWVzc2FnZX0uIEFzc2lnbmluZyB0eXBlIGRvZXNuJ3QgaGF2ZSBzY2hlbWEuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHNjaGVtYU5hbWVzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zY2hlbWEpKSB7XHJcbiAgICAgICAgc2NoZW1hTmFtZXMgPSBvcHRpb25zLnNjaGVtYTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNjaGVtYU5hbWVzID0gW29wdGlvbnMuc2NoZW1hIHx8IERFRkFVTFRfU0NIRU1BXTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgc2NoZW1hTmFtZSBvZiBzY2hlbWFOYW1lcykge1xyXG4gICAgICAgIGlmICghc2NoZW1hLm5hbWVzW3NjaGVtYU5hbWVdKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXTtcclxuICAgICAgICBuYW1lZFNjaGVtYVtwcm9wZXJ0eUtleV0gPSBjb3B5T3B0aW9ucztcclxuICAgIH1cclxufTtcblxuZXhwb3J0cy5Kc29uRXJyb3IgPSBKc29uRXJyb3I7XG5leHBvcnRzLkpzb25QYXJzZXIgPSBKc29uUGFyc2VyO1xuZXhwb3J0cy5Kc29uUHJvcCA9IEpzb25Qcm9wO1xuZXhwb3J0cy5Kc29uU2VyaWFsaXplciA9IEpzb25TZXJpYWxpemVyO1xuZXhwb3J0cy5LZXlFcnJvciA9IEtleUVycm9yO1xuZXhwb3J0cy5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuZXhwb3J0cy5TZXJpYWxpemVyRXJyb3IgPSBTZXJpYWxpemVyRXJyb3I7XG5leHBvcnRzLlRyYW5zZm9ybUVycm9yID0gVHJhbnNmb3JtRXJyb3I7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IFZhbGlkYXRpb25FcnJvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkpzb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiaW5uZXJFcnJvciIsIlRyYW5zZm9ybUVycm9yIiwic2NoZW1hIiwiUGFyc2VyRXJyb3IiLCJ0YXJnZXQiLCJuYW1lIiwiVmFsaWRhdGlvbkVycm9yIiwiU2VyaWFsaXplckVycm9yIiwic2NoZW1hTmFtZSIsIktleUVycm9yIiwia2V5cyIsImVycm9ycyIsIkpzb25Qcm9wVHlwZXMiLCJjaGVja1R5cGUiLCJ0eXBlIiwiQm9vbGVhbiIsIk51bWJlciIsIlN0cmluZyIsInRocm93SWZUeXBlSXNXcm9uZyIsIlR5cGVFcnJvciIsImlzQ29udmVydGlibGUiLCJwcm90b3R5cGUiLCJ0b0pTT04iLCJmcm9tSlNPTiIsIkpzb25TY2hlbWFTdG9yYWdlIiwiaXRlbXMiLCJNYXAiLCJoYXMiLCJmaW5kUGFyZW50U2NoZW1hIiwiZ2V0IiwiY3JlYXRlIiwibmFtZXMiLCJwYXJlbnRTY2hlbWEiLCJhc3NpZ24iLCJzZXQiLCJwYXJlbnQiLCJfX3Byb3RvX18iLCJERUZBVUxUX1NDSEVNQSIsInNjaGVtYVN0b3JhZ2UiLCJQYXR0ZXJuVmFsaWRhdGlvbiIsInBhdHRlcm4iLCJSZWdFeHAiLCJ2YWxpZGF0ZSIsInNvdXJjZSIsImZsYWdzIiwiZXhlYyIsInRvU3RyaW5nIiwiSW5jbHVzaXZlVmFsaWRhdGlvbiIsIm1pbiIsIk1JTl9WQUxVRSIsIm1heCIsIk1BWF9WQUxVRSIsIkV4Y2x1c2l2ZVZhbGlkYXRpb24iLCJMZW5ndGhWYWxpZGF0aW9uIiwibGVuZ3RoIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwidW5kZWZpbmVkIiwiRW51bWVyYXRpb25WYWxpZGF0aW9uIiwiZW51bWVyYXRpb24iLCJpbmNsdWRlcyIsIm1hcCIsInYiLCJqb2luIiwiSnNvblRyYW5zZm9ybSIsImNoZWNrVmFsdWVzIiwiZGF0YSIsInNjaGVtYUl0ZW0iLCJ2YWx1ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGlvbnMiLCJyZXBlYXRlZCIsImNoZWNrVHlwZXMiLCJnZXRTY2hlbWFCeU5hbWUiLCJKc29uU2VyaWFsaXplciIsInNlcmlhbGl6ZSIsIm9iaiIsIm9wdGlvbnMiLCJyZXBsYWNlciIsInNwYWNlIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXMiLCJ0YXJnZXRTY2hlbWEiLCJpdGVtIiwicHVzaCIsIm5hbWVkU2NoZW1hIiwia2V5Iiwib2JqSXRlbSIsIm9wdGlvbmFsIiwiZGVmYXVsdFZhbHVlIiwiY29udmVydGVyIiwiZWwiLCJlIiwiSnNvblBhcnNlciIsInBhcnNlIiwia2V5RXJyb3JzIiwic3RyaWN0UHJvcGVydHkiLCJjaGVja1N0cmljdFByb3BlcnR5IiwibmV3T3B0aW9ucyIsInN0cmljdEFsbEtleXMiLCJqc29uUHJvcHMiLCJzY2hlbWFQcm9wcyIsImluZGV4T2YiLCJnZXRWYWxpZGF0aW9ucyIsIkFueSIsIm1pbkluY2x1c2l2ZSIsIm1heEluY2x1c2l2ZSIsIm1pbkV4Y2x1c2l2ZSIsIm1heEV4Y2x1c2l2ZSIsIkpzb25Qcm9wIiwicHJvcGVydHlLZXkiLCJlcnJvck1lc3NhZ2UiLCJkZWZhdWx0U2NoZW1hIiwiY29weU9wdGlvbnMiLCJzY2hlbWFOYW1lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/json-schema/build/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@peculiar/webcrypto/build/webcrypto.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@peculiar/webcrypto/build/webcrypto.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ \nvar core = __webpack_require__(/*! webcrypto-core */ \"(rsc)/../../node_modules/webcrypto-core/build/webcrypto-core.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar process = __webpack_require__(/*! process */ \"process\");\nvar tslib = __webpack_require__(/*! tslib */ \"(rsc)/../../node_modules/tslib/tslib.es6.js\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(rsc)/../../node_modules/@peculiar/json-schema/build/index.js\");\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/../../node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar core__namespace = /*#__PURE__*/ _interopNamespaceDefault(core);\nvar crypto__namespace = /*#__PURE__*/ _interopNamespaceDefault(crypto);\nvar process__namespace = /*#__PURE__*/ _interopNamespaceDefault(process);\nconst JsonBase64UrlConverter = {\n    fromJSON: (value)=>Buffer.from(pvtsutils.Convert.FromBase64Url(value)),\n    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(value)\n};\nclass CryptoKey extends core__namespace.CryptoKey {\n    constructor(){\n        super(...arguments);\n        this.data = Buffer.alloc(0);\n        this.algorithm = {\n            name: \"\"\n        };\n        this.extractable = false;\n        this.type = \"secret\";\n        this.usages = [];\n        this.kty = \"oct\";\n        this.alg = \"\";\n    }\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"ext\",\n        type: jsonSchema.JsonPropTypes.Boolean,\n        optional: true\n    })\n], CryptoKey.prototype, \"extractable\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"key_ops\",\n        type: jsonSchema.JsonPropTypes.String,\n        repeated: true,\n        optional: true\n    })\n], CryptoKey.prototype, \"usages\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String\n    })\n], CryptoKey.prototype, \"kty\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String,\n        optional: true\n    })\n], CryptoKey.prototype, \"alg\", void 0);\nclass SymmetricKey extends CryptoKey {\n    constructor(){\n        super(...arguments);\n        this.kty = \"oct\";\n        this.type = \"secret\";\n    }\n}\nclass AsymmetricKey extends CryptoKey {\n}\nclass AesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch(this.algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return `A${this.algorithm.length}CBC`;\n            case \"AES-CTR\":\n                return `A${this.algorithm.length}CTR`;\n            case \"AES-GCM\":\n                return `A${this.algorithm.length}GCM`;\n            case \"AES-KW\":\n                return `A${this.algorithm.length}KW`;\n            case \"AES-CMAC\":\n                return `A${this.algorithm.length}CMAC`;\n            case \"AES-ECB\":\n                return `A${this.algorithm.length}ECB`;\n            default:\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], AesCryptoKey.prototype, \"data\", void 0);\nconst keyStorage = new WeakMap();\nfunction getCryptoKey(key) {\n    const res = keyStorage.get(key);\n    if (!res) {\n        throw new core__namespace.OperationError(\"Cannot get CryptoKey from secure storage\");\n    }\n    return res;\n}\nfunction setCryptoKey(value) {\n    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\n    Object.freeze(key);\n    keyStorage.set(key, value);\n    return key;\n}\nclass AesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new AesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: AesCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new AesCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.algorithm.length = key.data.length << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        switch(key.algorithm.length){\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new core__namespace.OperationError(\"keyData: Is wrong key length\");\n        }\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\n            case \"AES-CTR\":\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\n            case \"AES-GCM\":\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\n            case \"AES-KW\":\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\n            case \"AES-ECB\":\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch(algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\n            case \"AES-CTR\":\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\n            case \"AES-GCM\":\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\n            case \"AES-KW\":\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\n            case \"AES-ECB\":\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptAesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesCTR(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCTR(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesGCM(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\n            authTagLength: (algorithm.tagLength || 128) >> 3\n        });\n        if (algorithm.additionalData) {\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\n        }\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final(),\n            cipher.getAuthTag()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesGCM(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\n        const tagLength = (algorithm.tagLength || 128) >> 3;\n        const enc = data.slice(0, data.length - tagLength);\n        const tag = data.slice(data.length - tagLength);\n        if (algorithm.additionalData) {\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\n        }\n        decipher.setAuthTag(tag);\n        let dec = decipher.update(enc);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesKW(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        return new Uint8Array(enc).buffer;\n    }\n    static async decryptAesKW(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesECB(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesECB(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\nclass AesCbcProvider extends core__namespace.AesCbcProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nconst zero = Buffer.from([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n]);\nconst rb = Buffer.from([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    135\n]);\nconst blockSize = 16;\nfunction bitShiftLeft(buffer) {\n    const shifted = Buffer.alloc(buffer.length);\n    const last = buffer.length - 1;\n    for(let index = 0; index < last; index++){\n        shifted[index] = buffer[index] << 1;\n        if (buffer[index + 1] & 0x80) {\n            shifted[index] += 0x01;\n        }\n    }\n    shifted[last] = buffer[last] << 1;\n    return shifted;\n}\nfunction xor(a, b) {\n    const length = Math.min(a.length, b.length);\n    const output = Buffer.alloc(length);\n    for(let index = 0; index < length; index++){\n        output[index] = a[index] ^ b[index];\n    }\n    return output;\n}\nfunction aes(key, message) {\n    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);\n    const result = cipher.update(message);\n    cipher.final();\n    return result;\n}\nfunction getMessageBlock(message, blockIndex) {\n    const block = Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = start + blockSize;\n    message.copy(block, 0, start, end);\n    return block;\n}\nfunction getPaddedMessageBlock(message, blockIndex) {\n    const block = Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = message.length;\n    block.fill(0);\n    message.copy(block, 0, start, end);\n    block[end - start] = 0x80;\n    return block;\n}\nfunction generateSubkeys(key) {\n    const l = aes(key, zero);\n    let subkey1 = bitShiftLeft(l);\n    if (l[0] & 0x80) {\n        subkey1 = xor(subkey1, rb);\n    }\n    let subkey2 = bitShiftLeft(subkey1);\n    if (subkey1[0] & 0x80) {\n        subkey2 = xor(subkey2, rb);\n    }\n    return {\n        subkey1,\n        subkey2\n    };\n}\nfunction aesCmac(key, message) {\n    const subkeys = generateSubkeys(key);\n    let blockCount = Math.ceil(message.length / blockSize);\n    let lastBlockCompleteFlag;\n    let lastBlock;\n    if (blockCount === 0) {\n        blockCount = 1;\n        lastBlockCompleteFlag = false;\n    } else {\n        lastBlockCompleteFlag = message.length % blockSize === 0;\n    }\n    const lastBlockIndex = blockCount - 1;\n    if (lastBlockCompleteFlag) {\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\n    } else {\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\n    }\n    let x = zero;\n    let y;\n    for(let index = 0; index < lastBlockIndex; index++){\n        y = xor(x, getMessageBlock(message, index));\n        x = aes(key, y);\n    }\n    y = xor(lastBlock, x);\n    return aes(key, y);\n}\nclass AesCmacProvider extends core__namespace.AesCmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\n        return new Uint8Array(result).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const signature2 = await this.sign(algorithm, key, data);\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesCtrProvider extends core__namespace.AesCtrProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesGcmProvider extends core__namespace.AesGcmProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesKwProvider extends core__namespace.AesKwProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesEcbProvider extends core__namespace.AesEcbProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass DesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch(this.algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return `DES-CBC`;\n            case \"DES-EDE3-CBC\":\n                return `3DES-CBC`;\n            default:\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], DesCryptoKey.prototype, \"data\", void 0);\nclass DesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new DesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: DesCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new DesCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof DesCryptoKey)) {\n            throw new Error(\"key: Is not DesCryptoKey\");\n        }\n        switch(algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptDesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptDesEDE3CBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesEDE3CBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nclass DesCbcProvider extends core__namespace.DesProvider {\n    constructor(){\n        super(...arguments);\n        this.keySizeBits = 64;\n        this.ivSize = 8;\n        this.name = \"DES-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, {\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        if (key.data.length !== this.keySizeBits >> 3) {\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\nclass DesEde3CbcProvider extends core__namespace.DesProvider {\n    constructor(){\n        super(...arguments);\n        this.keySizeBits = 192;\n        this.ivSize = 8;\n        this.name = \"DES-EDE3-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, {\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        if (key.data.length !== this.keySizeBits >> 3) {\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\nfunction getJwkAlgorithm(algorithm) {\n    switch(algorithm.name.toUpperCase()){\n        case \"RSA-OAEP\":\n            {\n                const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\n                return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\n            }\n        case \"RSASSA-PKCS1-V1_5\":\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PSS\":\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PKCS1\":\n            return `RS1`;\n        default:\n            throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n    }\n}\nclass RsaPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.RsaPrivateKey\n        });\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n    }\n}\nclass RsaPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.RsaPublicKey\n        });\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n    }\n}\nclass RsaCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new RsaPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new RsaPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const publicExponent = Buffer.concat([\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\n            Buffer.from(algorithm.publicExponent)\n        ]).readInt32BE(0);\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\n            modulusLength: algorithm.modulusLength,\n            publicExponent,\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.RsaPrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.RsaPublicKey\n                        });\n                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async sign(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.signRsa(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async verify(algorithm, key, signature, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.verifySSA(algorithm, key, data, signature);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-OAEP\":\n                return this.encryptOAEP(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-OAEP\":\n                return this.decryptOAEP(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new RsaPrivateKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new RsaPublicKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getCryptoAlgorithm(alg) {\n        switch(alg.hash.name.toUpperCase()){\n            case \"SHA-1\":\n                return \"RSA-SHA1\";\n            case \"SHA-256\":\n                return \"RSA-SHA256\";\n            case \"SHA-384\":\n                return \"RSA-SHA384\";\n            case \"SHA-512\":\n                return \"RSA-SHA512\";\n            case \"SHA3-256\":\n                return \"RSA-SHA3-256\";\n            case \"SHA3-384\":\n                return \"RSA-SHA3-384\";\n            case \"SHA3-512\":\n                return \"RSA-SHA3-512\";\n            default:\n                throw new core__namespace.OperationError(\"algorithm.hash: Is not recognized\");\n        }\n    }\n    static signRsa(algorithm, key, data) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const signature = signer.sign(options);\n        return new Uint8Array(signature).buffer;\n    }\n    static verifySSA(algorithm, key, data, signature) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const ok = signer.verify(options, signature);\n        return ok;\n    }\n    static encryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\n    }\n    static decryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\n    }\n}\nRsaCrypto.publicKeyUsages = [\n    \"verify\",\n    \"encrypt\",\n    \"wrapKey\"\n];\nRsaCrypto.privateKeyUsages = [\n    \"sign\",\n    \"decrypt\",\n    \"unwrapKey\"\n];\nclass RsaSsaProvider extends core__namespace.RsaSsaProvider {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\nclass RsaPssProvider extends core__namespace.RsaPssProvider {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\nclass ShaCrypto {\n    static size(algorithm) {\n        switch(algorithm.name.toUpperCase()){\n            case \"SHA-1\":\n                return 160;\n            case \"SHA-256\":\n            case \"SHA3-256\":\n                return 256;\n            case \"SHA-384\":\n            case \"SHA3-384\":\n                return 384;\n            case \"SHA-512\":\n            case \"SHA3-512\":\n                return 512;\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static getAlgorithmName(algorithm) {\n        switch(algorithm.name.toUpperCase()){\n            case \"SHA-1\":\n                return \"sha1\";\n            case \"SHA-256\":\n                return \"sha256\";\n            case \"SHA-384\":\n                return \"sha384\";\n            case \"SHA-512\":\n                return \"sha512\";\n            case \"SHA3-256\":\n                return \"sha3-256\";\n            case \"SHA3-384\":\n                return \"sha3-384\";\n            case \"SHA3-512\":\n                return \"sha3-512\";\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static digest(algorithm, data) {\n        const hashAlg = this.getAlgorithmName(algorithm);\n        const hash = crypto.createHash(hashAlg).update(Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\nclass RsaOaepProvider extends core__namespace.RsaOaepProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onEncrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const dataView = new Uint8Array(data);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = dataView.byteLength;\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\n        if (dataLength > keySize - 2 * hashSize - 2) {\n            throw new Error(\"Data too large\");\n        }\n        const message = new Uint8Array(keySize);\n        const seed = message.subarray(1, hashSize + 1);\n        const dataBlock = message.subarray(hashSize + 1);\n        dataBlock.set(dataView, hashSize + psLength + 1);\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n        dataBlock.set(labelHash, 0);\n        dataBlock[hashSize + psLength] = 1;\n        crypto.randomFillSync(seed);\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for(let i = 0; i < dataBlock.length; i++){\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for(let i = 0; i < seed.length; i++){\n            seed[i] ^= seedMask[i];\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const pkcs0 = crypto.publicEncrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING\n        }, Buffer.from(message));\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = data.byteLength;\n        if (dataLength !== keySize) {\n            throw new Error(\"Bad data\");\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        let pkcs0 = crypto.privateDecrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING\n        }, Buffer.from(data));\n        const z = pkcs0[0];\n        const seed = pkcs0.subarray(1, hashSize + 1);\n        const dataBlock = pkcs0.subarray(hashSize + 1);\n        if (z !== 0) {\n            throw new Error(\"Decryption failed\");\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for(let i = 0; i < seed.length; i++){\n            seed[i] ^= seedMask[i];\n        }\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for(let i = 0; i < dataBlock.length; i++){\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n        for(let i = 0; i < hashSize; i++){\n            if (labelHash[i] !== dataBlock[i]) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        let psEnd = hashSize;\n        for(; psEnd < dataBlock.length; psEnd++){\n            const psz = dataBlock[psEnd];\n            if (psz === 1) {\n                break;\n            }\n            if (psz !== 0) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        if (psEnd === dataBlock.length) {\n            throw new Error(\"Decryption failed\");\n        }\n        pkcs0 = dataBlock.subarray(psEnd + 1);\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    mgf1(algorithm, seed, length = 0) {\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\n        const mask = new Uint8Array(length);\n        const counter = new Uint8Array(4);\n        const chunks = Math.ceil(length / hashSize);\n        for(let i = 0; i < chunks; i++){\n            counter[0] = i >>> 24;\n            counter[1] = i >>> 16 & 255;\n            counter[2] = i >>> 8 & 255;\n            counter[3] = i & 255;\n            const submask = mask.subarray(i * hashSize);\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\")).update(seed).update(counter).digest();\n            if (chunk.length > submask.length) {\n                chunk = chunk.subarray(0, submask.length);\n            }\n            submask.set(chunk);\n        }\n        return mask;\n    }\n}\nclass RsaEsProvider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSAES-PKCS1-v1_5\";\n        this.usages = {\n            publicKey: [\n                \"encrypt\",\n                \"wrapKey\"\n            ],\n            privateKey: [\n                \"decrypt\",\n                \"unwrapKey\"\n            ]\n        };\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        switch(algorithm.modulusLength){\n            case 1024:\n            case 2048:\n            case 4096:\n                break;\n            default:\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\n        }\n    }\n    async onEncrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));\n        return new Uint8Array(enc).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));\n        return new Uint8Array(dec).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    toCryptoOptions(key) {\n        const type = key.type.toUpperCase();\n        return {\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\n            padding: crypto__namespace.constants.RSA_PKCS1_PADDING\n        };\n    }\n}\nconst namedOIDs = {\n    \"1.2.840.10045.3.1.7\": \"P-256\",\n    \"P-256\": \"1.2.840.10045.3.1.7\",\n    \"1.3.132.0.34\": \"P-384\",\n    \"P-384\": \"1.3.132.0.34\",\n    \"1.3.132.0.35\": \"P-521\",\n    \"P-521\": \"1.3.132.0.35\",\n    \"1.3.132.0.10\": \"K-256\",\n    \"K-256\": \"1.3.132.0.10\",\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\"\n};\nfunction getOidByNamedCurve$1(namedCurve) {\n    const oid = namedOIDs[namedCurve];\n    if (!oid) {\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\nclass EcPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.EcPrivateKey\n        });\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EcPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.EcPublicKey\n        });\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass Sha1Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-1\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha256Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha384Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha512Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3256Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3384Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3512Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass EcCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EcPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EcPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const keys = crypto.generateKeyPairSync(\"ec\", {\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const signature = signer.sign(options);\n        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);\n        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);\n        return signatureRaw.buffer;\n    }\n    static async verify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const ecSignature = new core__namespace.asn1.EcDsaSignature();\n        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);\n        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\n        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));\n        const ok = signer.verify(options, ecSignatureRaw);\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\n        const ecdh = crypto.createECDH(cryptoAlg);\n        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);\n        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\n        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\n        if (length === null) {\n            return bits;\n        }\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\":\n                {\n                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\n                    return publicKeyInfo.publicKey;\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.EcPrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.EcPublicKey\n                        });\n                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"raw\":\n                {\n                    const asnKey = new core__namespace.asn1.EcPublicKey(keyData);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\n                    this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\n                    this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static assertKeyParameters(parameters, namedCurve) {\n        if (!parameters) {\n            throw new core__namespace.CryptoError(\"Key info doesn't have required parameters\");\n        }\n        let namedCurveIdentifier = \"\";\n        try {\n            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;\n        } catch (e) {\n            throw new core__namespace.CryptoError(\"Cannot read key info parameters\");\n        }\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\n            throw new core__namespace.CryptoError(\"Key info parameter doesn't match to named curve\");\n        }\n    }\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new EcPrivateKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));\n        keyInfo.publicKey = asnKey.value;\n        const key = new EcPublicKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getOpenSSLNamedCurve(curve) {\n        switch(curve.toUpperCase()){\n            case \"P-256\":\n                return \"prime256v1\";\n            case \"K-256\":\n                return \"secp256k1\";\n            case \"P-384\":\n                return \"secp384r1\";\n            case \"P-521\":\n                return \"secp521r1\";\n            default:\n                return curve;\n        }\n    }\n}\nEcCrypto.publicKeyUsages = [\n    \"verify\"\n];\nEcCrypto.privateKeyUsages = [\n    \"sign\",\n    \"deriveKey\",\n    \"deriveBits\"\n];\nclass EcdsaProvider extends core__namespace.EcdsaProvider {\n    constructor(){\n        super(...arguments);\n        this.namedCurves = core__namespace.EcCurves.names;\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n}\nclass EcdhProvider extends core__namespace.EcdhProvider {\n    constructor(){\n        super(...arguments);\n        this.namedCurves = core__namespace.EcCurves.names;\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EcCrypto.deriveBits({\n            ...algorithm,\n            public: getCryptoKey(algorithm.public)\n        }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n}\nconst edOIDs = {\n    [core__namespace.asn1.idEd448]: \"Ed448\",\n    \"ed448\": core__namespace.asn1.idEd448,\n    [core__namespace.asn1.idX448]: \"X448\",\n    \"x448\": core__namespace.asn1.idX448,\n    [core__namespace.asn1.idEd25519]: \"Ed25519\",\n    \"ed25519\": core__namespace.asn1.idEd25519,\n    [core__namespace.asn1.idX25519]: \"X25519\",\n    \"x25519\": core__namespace.asn1.idX25519\n};\nfunction getOidByNamedCurve(namedCurve) {\n    const oid = edOIDs[namedCurve.toLowerCase()];\n    if (!oid) {\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\nclass EdPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.CurvePrivateKey\n        });\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EdPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return keyInfo.publicKey;\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, {\n            x: pvtsutils.Convert.ToBase64Url(key)\n        });\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        if (!json.x) {\n            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EdCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EdPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EdPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const type = algorithm.namedCurve.toLowerCase();\n        const keys = crypto.generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const signature = crypto.sign(null, Buffer.from(data), options);\n        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const publicKey = crypto.createPublicKey({\n            key: algorithm.public.data,\n            format: \"der\",\n            type: \"spki\"\n        });\n        const privateKey = crypto.createPrivateKey({\n            key: baseKey.data,\n            format: \"der\",\n            type: \"pkcs8\"\n        });\n        const bits = crypto.diffieHellman({\n            publicKey,\n            privateKey\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\":\n                {\n                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\n                    return publicKeyInfo.publicKey;\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.CurvePrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        if (!jwk.x) {\n                            throw new TypeError(\"keyData: Cannot get required 'x' filed\");\n                        }\n                        return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"raw\":\n                {\n                    return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPrivateKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            d: pvtsutils.Convert.ToBase64Url(asnKey.d)\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPublicKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            x: pvtsutils.Convert.ToBase64Url(asnKey)\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n}\nEdCrypto.publicKeyUsages = [\n    \"verify\"\n];\nEdCrypto.privateKeyUsages = [\n    \"sign\",\n    \"deriveKey\",\n    \"deriveBits\"\n];\nclass EdDsaProvider extends core__namespace.EdDsaProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\")\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\nclass EcdhEsProvider extends core__namespace.EcdhEsProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.toUpperCase()\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EdCrypto.deriveBits({\n            ...algorithm,\n            public: getCryptoKey(algorithm.public)\n        }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\nclass PbkdfCryptoKey extends CryptoKey {\n}\nclass Pbkdf2Provider extends core__namespace.Pbkdf2Provider {\n    async onDeriveBits(algorithm, baseKey, length) {\n        return new Promise((resolve, reject)=>{\n            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(new Uint8Array(derivedBits).buffer);\n                }\n            });\n        });\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format === \"raw\") {\n            const key = new PbkdfCryptoKey();\n            key.data = Buffer.from(keyData);\n            key.algorithm = {\n                name: this.name\n            };\n            key.extractable = false;\n            key.usages = keyUsages;\n            return setCryptoKey(key);\n        }\n        throw new core__namespace.OperationError(\"format: Must be 'raw'\");\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\n        }\n    }\n}\nclass HmacCryptoKey extends CryptoKey {\n    get alg() {\n        const hash = this.algorithm.hash.name.toUpperCase();\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], HmacCryptoKey.prototype, \"data\", void 0);\nclass HmacProvider extends core__namespace.HmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\n        const key = new HmacCryptoKey();\n        key.algorithm = {\n            ...algorithm,\n            length,\n            name: this.name\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(length >> 3);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n        return new Uint8Array(hmac).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n        return hmac.compare(Buffer.from(signature)) === 0;\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: HmacCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new HmacCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = {\n            hash: {\n                name: algorithm.hash.name\n            },\n            name: this.name,\n            length: key.data.length << 3\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onExportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));\n            case \"raw\":\n                return new Uint8Array(getCryptoKey(key).data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\n        }\n    }\n}\nclass HkdfCryptoKey extends CryptoKey {\n}\nclass HkdfProvider extends core__namespace.HkdfProvider {\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format.toLowerCase() !== \"raw\") {\n            throw new core__namespace.OperationError(\"Operation not supported\");\n        }\n        const key = new HkdfCryptoKey();\n        key.data = Buffer.from(keyData);\n        key.algorithm = {\n            name: this.name\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onDeriveBits(params, baseKey, length) {\n        const hash = params.hash.name.replace(\"-\", \"\");\n        const hashLength = crypto.createHash(hash).digest().length;\n        const byteLength = length / 8;\n        const info = core.BufferSourceConverter.toUint8Array(params.info);\n        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt)).update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();\n        const blocks = [\n            Buffer.alloc(0)\n        ];\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\n        for(let i = 1; i < blockCount; ++i){\n            blocks.push(crypto.createHmac(hash, PRK).update(Buffer.concat([\n                blocks[i - 1],\n                info,\n                Buffer.from([\n                    i\n                ])\n            ])).digest());\n        }\n        return Buffer.concat(blocks).slice(0, byteLength);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\n        }\n    }\n}\nclass ShakeCrypto {\n    static digest(algorithm, data) {\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), {\n            outputLength: algorithm.length\n        }).update(Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\nclass Shake128Provider extends core__namespace.Shake128Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\nclass Shake256Provider extends core__namespace.Shake256Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\nclass SubtleCrypto extends core__namespace.SubtleCrypto {\n    constructor(){\n        var _a;\n        super();\n        this.providers.set(new AesCbcProvider());\n        this.providers.set(new AesCtrProvider());\n        this.providers.set(new AesGcmProvider());\n        this.providers.set(new AesCmacProvider());\n        this.providers.set(new AesKwProvider());\n        this.providers.set(new AesEcbProvider());\n        this.providers.set(new DesCbcProvider());\n        this.providers.set(new DesEde3CbcProvider());\n        this.providers.set(new RsaSsaProvider());\n        this.providers.set(new RsaPssProvider());\n        this.providers.set(new RsaOaepProvider());\n        this.providers.set(new RsaEsProvider());\n        this.providers.set(new EcdsaProvider());\n        this.providers.set(new EcdhProvider());\n        this.providers.set(new Sha1Provider());\n        this.providers.set(new Sha256Provider());\n        this.providers.set(new Sha384Provider());\n        this.providers.set(new Sha512Provider());\n        this.providers.set(new Pbkdf2Provider());\n        this.providers.set(new HmacProvider());\n        this.providers.set(new HkdfProvider());\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\n            this.providers.set(new Shake128Provider());\n            this.providers.set(new Shake256Provider());\n        }\n        const hashes = crypto__namespace.getHashes();\n        if (hashes.includes(\"sha3-256\")) {\n            this.providers.set(new Sha3256Provider());\n        }\n        if (hashes.includes(\"sha3-384\")) {\n            this.providers.set(new Sha3384Provider());\n        }\n        if (hashes.includes(\"sha3-512\")) {\n            this.providers.set(new Sha3512Provider());\n        }\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\n            this.providers.set(new EdDsaProvider());\n            this.providers.set(new EcdhEsProvider());\n        }\n    }\n}\nclass Crypto extends core__namespace.Crypto {\n    constructor(){\n        super(...arguments);\n        this.subtle = new SubtleCrypto();\n    }\n    getRandomValues(array) {\n        if (!ArrayBuffer.isView(array)) {\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\n        }\n        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);\n        crypto.randomFillSync(buffer);\n        return array;\n    }\n}\nObject.defineProperty(exports, \"CryptoKey\", ({\n    enumerable: true,\n    get: function() {\n        return core.CryptoKey;\n    }\n}));\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci93ZWJjcnlwdG8vYnVpbGQvd2ViY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLEdBRUE7QUFFQSxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQixJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQztBQUN0QixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQztBQUN6QixJQUFJSyxZQUFZTCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJTSxhQUFhTixtQkFBT0EsQ0FBQztBQUV6QixTQUFTTyx5QkFBeUJDLENBQUM7SUFDakMsSUFBSUMsSUFBSUMsT0FBT0MsTUFBTSxDQUFDO0lBQ3RCLElBQUlILEdBQUc7UUFDTEUsT0FBT0UsSUFBSSxDQUFDSixHQUFHSyxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUNoQyxJQUFJQSxNQUFNLFdBQVc7Z0JBQ25CLElBQUlDLElBQUlMLE9BQU9NLHdCQUF3QixDQUFDUixHQUFHTTtnQkFDM0NKLE9BQU9PLGNBQWMsQ0FBQ1IsR0FBR0ssR0FBR0MsRUFBRUcsR0FBRyxHQUFHSCxJQUFJO29CQUN0Q0ksWUFBWTtvQkFDWkQsS0FBSzt3QkFBYyxPQUFPVixDQUFDLENBQUNNLEVBQUU7b0JBQUU7Z0JBQ2xDO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FMLEVBQUVXLE9BQU8sR0FBR1o7SUFDWixPQUFPRSxPQUFPVyxNQUFNLENBQUNaO0FBQ3ZCO0FBRUEsSUFBSWEsa0JBQWtCLFdBQVcsR0FBRWYseUJBQXlCUjtBQUM1RCxJQUFJd0Isb0JBQW9CLFdBQVcsR0FBRWhCLHlCQUF5Qk47QUFDOUQsSUFBSXVCLHFCQUFxQixXQUFXLEdBQUVqQix5QkFBeUJMO0FBRS9ELE1BQU11Qix5QkFBeUI7SUFDM0JDLFVBQVUsQ0FBQ0MsUUFBVUMsT0FBT0MsSUFBSSxDQUFDeEIsVUFBVXlCLE9B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Q0FBQ04sU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUlnUDtRQUMzQjtRQUNBLElBQUlxRixPQUFPRSxRQUFRLENBQUMsYUFBYTtZQUM3QixJQUFJLENBQUNOLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJaVA7UUFDM0I7UUFDQSxJQUFJaUYsb0JBQW9CRSxTQUFTRixrQkFBa0IsT0FBTyxJQUFJO1lBQzFELElBQUksQ0FBQ0QsU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUlrUztZQUN2QixJQUFJLENBQUMrQixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSW1TO1FBQzNCO0lBQ0o7QUFDSjtBQUVBLE1BQU1xQyxlQUFldFgsZ0JBQWdCc1gsTUFBTTtJQUN2Q3pXLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDeVcsTUFBTSxHQUFHLElBQUlWO0lBQ3RCO0lBQ0FXLGdCQUFnQkMsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsWUFBWUMsTUFBTSxDQUFDRixRQUFRO1lBQzVCLE1BQU0sSUFBSW5SLFVBQVU7UUFDeEI7UUFDQSxNQUFNN0MsU0FBU25ELE9BQU9DLElBQUksQ0FBQ2tYLE1BQU1oVSxNQUFNLEVBQUVnVSxNQUFNRyxVQUFVLEVBQUVILE1BQU14TCxVQUFVO1FBQzNFdE4sT0FBTzhRLGNBQWMsQ0FBQ2hNO1FBQ3RCLE9BQU9nVTtJQUNYO0FBQ0o7QUFFQXJZLDZDQUE0QztJQUMxQ1MsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT25CLEtBQUttQyxTQUFTO0lBQUU7QUFDNUMsQ0FBQyxFQUFDO0FBQ0ZpWCxjQUFjLEdBQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnViYmxlZ3VtLy4uLy4uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvd2ViY3J5cHRvL2J1aWxkL3dlYmNyeXB0by5qcz9jNWUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuIENvcHlyaWdodCAoYykgUGVjdWxpYXIgVmVudHVyZXMsIExMQ1xuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ3dlYmNyeXB0by1jb3JlJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIganNvblNjaGVtYSA9IHJlcXVpcmUoJ0BwZWN1bGlhci9qc29uLXNjaGVtYScpO1xudmFyIHB2dHN1dGlscyA9IHJlcXVpcmUoJ3B2dHN1dGlscycpO1xudmFyIGFzbjFTY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvYXNuMS1zY2hlbWEnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgY29yZV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChjb3JlKTtcbnZhciBjcnlwdG9fX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoY3J5cHRvKTtcbnZhciBwcm9jZXNzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KHByb2Nlc3MpO1xuXG5jb25zdCBKc29uQmFzZTY0VXJsQ29udmVydGVyID0ge1xyXG4gICAgZnJvbUpTT046ICh2YWx1ZSkgPT4gQnVmZmVyLmZyb20ocHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybCh2YWx1ZSkpLFxyXG4gICAgdG9KU09OOiAodmFsdWUpID0+IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKHZhbHVlKSxcclxufTtcblxuY2xhc3MgQ3J5cHRvS2V5IGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcclxuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IHsgbmFtZTogXCJcIiB9O1xyXG4gICAgICAgIHRoaXMuZXh0cmFjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInNlY3JldFwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5rdHkgPSBcIm9jdFwiO1xyXG4gICAgICAgIHRoaXMuYWxnID0gXCJcIjtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImV4dFwiLCB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuQm9vbGVhbiwgb3B0aW9uYWw6IHRydWUgfSlcclxuXSwgQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJleHRyYWN0YWJsZVwiLCB2b2lkIDApO1xyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtleV9vcHNcIiwgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLlN0cmluZywgcmVwZWF0ZWQ6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwidXNhZ2VzXCIsIHZvaWQgMCk7XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcgfSlcclxuXSwgQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJrdHlcIiwgdm9pZCAwKTtcclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLlN0cmluZywgb3B0aW9uYWw6IHRydWUgfSlcclxuXSwgQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJhbGdcIiwgdm9pZCAwKTtcblxuY2xhc3MgU3ltbWV0cmljS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5rdHkgPSBcIm9jdFwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwic2VjcmV0XCI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQXN5bW1ldHJpY0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbn1cblxuY2xhc3MgQWVzQ3J5cHRvS2V5IGV4dGVuZHMgU3ltbWV0cmljS2V5IHtcclxuICAgIGdldCBhbGcoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUNCQ2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ1RSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DVFJgO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9R0NNYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9S1dgO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNNQUNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUNNQUNgO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUVDQlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9RUNCYDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQWxnb3JpdGhtRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQgYWxnKHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxyXG5dLCBBZXNDcnlwdG9LZXkucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcblxuY29uc3Qga2V5U3RvcmFnZSA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIGdldENyeXB0b0tleShrZXkpIHtcclxuICAgIGNvbnN0IHJlcyA9IGtleVN0b3JhZ2UuZ2V0KGtleSk7XHJcbiAgICBpZiAoIXJlcykge1xyXG4gICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJDYW5ub3QgZ2V0IENyeXB0b0tleSBmcm9tIHNlY3VyZSBzdG9yYWdlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBzZXRDcnlwdG9LZXkodmFsdWUpIHtcclxuICAgIGNvbnN0IGtleSA9IGNvcmVfX25hbWVzcGFjZS5DcnlwdG9LZXkuY3JlYXRlKHZhbHVlLmFsZ29yaXRobSwgdmFsdWUudHlwZSwgdmFsdWUuZXh0cmFjdGFibGUsIHZhbHVlLnVzYWdlcyk7XHJcbiAgICBPYmplY3QuZnJlZXplKGtleSk7XHJcbiAgICBrZXlTdG9yYWdlLnNldChrZXksIHZhbHVlKTtcclxuICAgIHJldHVybiBrZXk7XHJcbn1cblxuY2xhc3MgQWVzQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgQWVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGFsZ29yaXRobS5sZW5ndGggPj4gMyk7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleTogSXMgbm90IEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBBZXNDcnlwdG9LZXkgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0gbmV3IEFlc0NyeXB0b0tleSgpO1xyXG4gICAgICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLmxlbmd0aCA9IGtleS5kYXRhLmxlbmd0aCA8PCAzO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDEyODpcclxuICAgICAgICAgICAgY2FzZSAxOTI6XHJcbiAgICAgICAgICAgIGNhc2UgMjU2OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwia2V5RGF0YTogSXMgd3Jvbmcga2V5IGxlbmd0aFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ1RSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtR0NNXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtS1dcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUVDQlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleTogSXMgbm90IEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ1RSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtR0NNXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtS1dcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUVDQlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWN0cmAsIGtleS5kYXRhLCBCdWZmZXIuZnJvbShhbGdvcml0aG0uY291bnRlcikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY3RyYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5jb3VudGVyKSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWdjbWAsIGtleS5kYXRhLCBCdWZmZXIuZnJvbShhbGdvcml0aG0uaXYpLCB7XHJcbiAgICAgICAgICAgIGF1dGhUYWdMZW5ndGg6IChhbGdvcml0aG0udGFnTGVuZ3RoIHx8IDEyOCkgPj4gMyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSB7XHJcbiAgICAgICAgICAgIGNpcGhlci5zZXRBQUQoQnVmZmVyLmZyb20oYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCksIGNpcGhlci5nZXRBdXRoVGFnKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZ2NtYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGNvbnN0IHRhZ0xlbmd0aCA9IChhbGdvcml0aG0udGFnTGVuZ3RoIHx8IDEyOCkgPj4gMztcclxuICAgICAgICBjb25zdCBlbmMgPSBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gdGFnTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB0YWcgPSBkYXRhLnNsaWNlKGRhdGEubGVuZ3RoIC0gdGFnTGVuZ3RoKTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSB7XHJcbiAgICAgICAgICAgIGRlY2lwaGVyLnNldEFBRChCdWZmZXIuZnJvbShhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyh0YWcpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZW5jKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBpZC1hZXMke2tleS5hbGdvcml0aG0ubGVuZ3RofS13cmFwYCwga2V5LmRhdGEsIHRoaXMuQUVTX0tXX0lWKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGlkLWFlcyR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LXdyYXBgLCBrZXkuZGF0YSwgdGhpcy5BRVNfS1dfSVYpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1lY2JgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoMCkpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZWNiYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KDApKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG5BZXNDcnlwdG8uQUVTX0tXX0lWID0gQnVmZmVyLmZyb20oXCJBNkE2QTZBNkE2QTZBNkE2XCIsIFwiaGV4XCIpO1xuXG5jbGFzcyBBZXNDYmNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNDYmNQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNvbnN0IHplcm8gPSBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xyXG5jb25zdCByYiA9IEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxMzVdKTtcclxuY29uc3QgYmxvY2tTaXplID0gMTY7XHJcbmZ1bmN0aW9uIGJpdFNoaWZ0TGVmdChidWZmZXIpIHtcclxuICAgIGNvbnN0IHNoaWZ0ZWQgPSBCdWZmZXIuYWxsb2MoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICBjb25zdCBsYXN0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGFzdDsgaW5kZXgrKykge1xyXG4gICAgICAgIHNoaWZ0ZWRbaW5kZXhdID0gYnVmZmVyW2luZGV4XSA8PCAxO1xyXG4gICAgICAgIGlmIChidWZmZXJbaW5kZXggKyAxXSAmIDB4ODApIHtcclxuICAgICAgICAgICAgc2hpZnRlZFtpbmRleF0gKz0gMHgwMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaGlmdGVkW2xhc3RdID0gYnVmZmVyW2xhc3RdIDw8IDE7XHJcbiAgICByZXR1cm4gc2hpZnRlZDtcclxufVxyXG5mdW5jdGlvbiB4b3IoYSwgYikge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIG91dHB1dFtpbmRleF0gPSBhW2luZGV4XSBeIGJbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5mdW5jdGlvbiBhZXMoa2V5LCBtZXNzYWdlKSB7XHJcbiAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG9fX25hbWVzcGFjZS5jcmVhdGVDaXBoZXJpdihgYWVzJHtrZXkubGVuZ3RoIDw8IDN9YCwga2V5LCB6ZXJvKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGNpcGhlci51cGRhdGUobWVzc2FnZSk7XHJcbiAgICBjaXBoZXIuZmluYWwoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGJsb2NrSW5kZXgpIHtcclxuICAgIGNvbnN0IGJsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSk7XHJcbiAgICBjb25zdCBzdGFydCA9IGJsb2NrSW5kZXggKiBibG9ja1NpemU7XHJcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGJsb2NrU2l6ZTtcclxuICAgIG1lc3NhZ2UuY29weShibG9jaywgMCwgc3RhcnQsIGVuZCk7XHJcbiAgICByZXR1cm4gYmxvY2s7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFkZGVkTWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGJsb2NrSW5kZXgpIHtcclxuICAgIGNvbnN0IGJsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSk7XHJcbiAgICBjb25zdCBzdGFydCA9IGJsb2NrSW5kZXggKiBibG9ja1NpemU7XHJcbiAgICBjb25zdCBlbmQgPSBtZXNzYWdlLmxlbmd0aDtcclxuICAgIGJsb2NrLmZpbGwoMCk7XHJcbiAgICBtZXNzYWdlLmNvcHkoYmxvY2ssIDAsIHN0YXJ0LCBlbmQpO1xyXG4gICAgYmxvY2tbZW5kIC0gc3RhcnRdID0gMHg4MDtcclxuICAgIHJldHVybiBibG9jaztcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZVN1YmtleXMoa2V5KSB7XHJcbiAgICBjb25zdCBsID0gYWVzKGtleSwgemVybyk7XHJcbiAgICBsZXQgc3Via2V5MSA9IGJpdFNoaWZ0TGVmdChsKTtcclxuICAgIGlmIChsWzBdICYgMHg4MCkge1xyXG4gICAgICAgIHN1YmtleTEgPSB4b3Ioc3Via2V5MSwgcmIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHN1YmtleTIgPSBiaXRTaGlmdExlZnQoc3Via2V5MSk7XHJcbiAgICBpZiAoc3Via2V5MVswXSAmIDB4ODApIHtcclxuICAgICAgICBzdWJrZXkyID0geG9yKHN1YmtleTIsIHJiKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHN1YmtleTEsIHN1YmtleTIgfTtcclxufVxyXG5mdW5jdGlvbiBhZXNDbWFjKGtleSwgbWVzc2FnZSkge1xyXG4gICAgY29uc3Qgc3Via2V5cyA9IGdlbmVyYXRlU3Via2V5cyhrZXkpO1xyXG4gICAgbGV0IGJsb2NrQ291bnQgPSBNYXRoLmNlaWwobWVzc2FnZS5sZW5ndGggLyBibG9ja1NpemUpO1xyXG4gICAgbGV0IGxhc3RCbG9ja0NvbXBsZXRlRmxhZztcclxuICAgIGxldCBsYXN0QmxvY2s7XHJcbiAgICBpZiAoYmxvY2tDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIGJsb2NrQ291bnQgPSAxO1xyXG4gICAgICAgIGxhc3RCbG9ja0NvbXBsZXRlRmxhZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGFzdEJsb2NrQ29tcGxldGVGbGFnID0gKG1lc3NhZ2UubGVuZ3RoICUgYmxvY2tTaXplID09PSAwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhc3RCbG9ja0luZGV4ID0gYmxvY2tDb3VudCAtIDE7XHJcbiAgICBpZiAobGFzdEJsb2NrQ29tcGxldGVGbGFnKSB7XHJcbiAgICAgICAgbGFzdEJsb2NrID0geG9yKGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBsYXN0QmxvY2tJbmRleCksIHN1YmtleXMuc3Via2V5MSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXN0QmxvY2sgPSB4b3IoZ2V0UGFkZGVkTWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGxhc3RCbG9ja0luZGV4KSwgc3Via2V5cy5zdWJrZXkyKTtcclxuICAgIH1cclxuICAgIGxldCB4ID0gemVybztcclxuICAgIGxldCB5O1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxhc3RCbG9ja0luZGV4OyBpbmRleCsrKSB7XHJcbiAgICAgICAgeSA9IHhvcih4LCBnZXRNZXNzYWdlQmxvY2sobWVzc2FnZSwgaW5kZXgpKTtcclxuICAgICAgICB4ID0gYWVzKGtleSwgeSk7XHJcbiAgICB9XHJcbiAgICB5ID0geG9yKGxhc3RCbG9jaywgeCk7XHJcbiAgICByZXR1cm4gYWVzKGtleSwgeSk7XHJcbn1cclxuY2xhc3MgQWVzQ21hY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0NtYWNQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFlc0NtYWMoZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmUyID0gYXdhaXQgdGhpcy5zaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb21wYXJlKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZTIpKSA9PT0gMDtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNDdHJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNDdHJQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0djbVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0djbVByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzS3dQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNLd1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzRWNiUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzRWNiUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBEZXNDcnlwdG9LZXkgZXh0ZW5kcyBTeW1tZXRyaWNLZXkge1xyXG4gICAgZ2V0IGFsZygpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBERVMtQ0JDYDtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1FREUzLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAzREVTLUNCQ2A7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkFsZ29yaXRobUVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIG5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IGFsZyh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia1wiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgfSlcclxuXSwgRGVzQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNsYXNzIERlc0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IERlc0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhhbGdvcml0aG0ubGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBEZXNDcnlwdG9LZXkgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0gbmV3IERlc0NyeXB0b0tleSgpO1xyXG4gICAgICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleTogSXMgbm90IERlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgZGVzLWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgZGVzLWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgZGVzLWVkZTMtY2JjYCwga2V5LmRhdGEsIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgZGVzLWVkZTMtY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIERlc0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkRlc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5rZXlTaXplQml0cyA9IDY0O1xyXG4gICAgICAgIHRoaXMuaXZTaXplID0gODtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIkRFUy1DQkNcIjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiB0aGlzLm5hbWUsIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICBpZiAoa2V5LmRhdGEubGVuZ3RoICE9PSAodGhpcy5rZXlTaXplQml0cyA+PiAzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwia2V5RGF0YTogV3Jvbmcga2V5IHNpemVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIERlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgRGVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBEZXNFZGUzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRGVzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmtleVNpemVCaXRzID0gMTkyO1xyXG4gICAgICAgIHRoaXMuaXZTaXplID0gODtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIkRFUy1FREUzLUNCQ1wiO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IHRoaXMubmFtZSwgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIGlmIChrZXkuZGF0YS5sZW5ndGggIT09ICh0aGlzLmtleVNpemVCaXRzID4+IDMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBXcm9uZyBrZXkgc2l6ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBEZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGdldEp3a0FsZ29yaXRobShhbGdvcml0aG0pIHtcclxuICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1kU2l6ZSA9IC8oXFxkKykkLy5leGVjKGFsZ29yaXRobS5oYXNoLm5hbWUpWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4gYFJTQS1PQUVQJHttZFNpemUgIT09IFwiMVwiID8gYC0ke21kU2l6ZX1gIDogXCJcIn1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGBSUyR7LyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV19YDtcclxuICAgICAgICBjYXNlIFwiUlNBLVBTU1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gYFBTJHsvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXX1gO1xyXG4gICAgICAgIGNhc2UgXCJSU0EtUEtDUzFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGBSUzFgO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYVByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVByaXZhdGVLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIlJTQVwiLFxyXG4gICAgICAgICAgICBhbGc6IGdldEp3a0FsZ29yaXRobSh0aGlzLmFsZ29yaXRobSksXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQdWJsaWNLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwdWJsaWNcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wdWJsaWNLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiUlNBXCIsXHJcbiAgICAgICAgICAgIGFsZzogZ2V0SndrQWxnb3JpdGhtKHRoaXMuYWxnb3JpdGhtKSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHVibGljS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgUnNhUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIHByaXZhdGVLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBwcml2YXRlS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnByaXZhdGVLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUnNhUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBwdWJsaWNFeHBvbmVudCA9IEJ1ZmZlci5jb25jYXQoW1xyXG4gICAgICAgICAgICBCdWZmZXIuYWxsb2MoNCAtIGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudC5ieXRlTGVuZ3RoLCAwKSxcclxuICAgICAgICAgICAgQnVmZmVyLmZyb20oYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50KSxcclxuICAgICAgICBdKS5yZWFkSW50MzJCRSgwKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoXCJyc2FcIiwge1xyXG4gICAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCxcclxuICAgICAgICAgICAgcHVibGljRXhwb25lbnQsXHJcbiAgICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5kYXRhID0ga2V5cy5wcml2YXRlS2V5O1xyXG4gICAgICAgIHB1YmxpY0tleS5kYXRhID0ga2V5cy5wdWJsaWNLZXk7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxyXG4gICAgICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShuZXcgVWludDhBcnJheShrZXlEYXRhKSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnB1YmxpY0tleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHVibGljS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShuZXcgVWludDhBcnJheShrZXlEYXRhKSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLVBTU1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25Sc2EoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtUFNTXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5U1NBKGFsZ29yaXRobSwga2V5LCBkYXRhLCBzaWduYXR1cmUpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBpbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoYXNuS2V5KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgUnNhUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCA9IG5ldyBVaW50OEFycmF5KGFzbktleS5wdWJsaWNFeHBvbmVudCk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID0gYXNuS2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCA8PCAzO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFJzYVB1YmxpY0tleSgpO1xyXG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCA9IG5ldyBVaW50OEFycmF5KGFzbktleS5wdWJsaWNFeHBvbmVudCk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID0gYXNuS2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCA8PCAzO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRDcnlwdG9BbGdvcml0aG0oYWxnKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGcuaGFzaC5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0xXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTM4NFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTUxMlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzLTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzLTM4NFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzLTUxMlwiO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobS5oYXNoOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2lnblJzYShhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IHRoaXMuZ2V0Q3J5cHRvQWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVTaWduKGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUlNBLVBTU1wiKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucGFkZGluZyA9IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BTU19QQURESU5HO1xyXG4gICAgICAgICAgICBvcHRpb25zLnNhbHRMZW5ndGggPSBhbGdvcml0aG0uc2FsdExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24ob3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHZlcmlmeVNTQShhbGdvcml0aG0sIGtleSwgZGF0YSwgc2lnbmF0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gdGhpcy5nZXRDcnlwdG9BbGdvcml0aG0oa2V5LmFsZ29yaXRobSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJSU0EtUFNTXCIpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wYWRkaW5nID0gY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkc7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2FsdExlbmd0aCA9IGFsZ29yaXRobS5zYWx0TGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvayA9IHNpZ25lci52ZXJpZnkob3B0aW9ucywgc2lnbmF0dXJlKTtcclxuICAgICAgICByZXR1cm4gb2s7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW5jcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYCxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfT0FFUF9QQURESU5HLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5sYWJlbCkgO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjcnlwdG8ucHVibGljRW5jcnlwdChvcHRpb25zLCBkYXRhKSkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYCxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfT0FFUF9QQURESU5HLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5sYWJlbCkgO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjcnlwdG8ucHJpdmF0ZURlY3J5cHQob3B0aW9ucywgZGF0YSkpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG5Sc2FDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCIsIFwiZW5jcnlwdFwiLCBcIndyYXBLZXlcIl07XHJcblJzYUNyeXB0by5wcml2YXRlS2V5VXNhZ2VzID0gW1wic2lnblwiLCBcImRlY3J5cHRcIiwgXCJ1bndyYXBLZXlcIl07XG5cbmNsYXNzIFJzYVNzYVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlJzYVNzYVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcclxuICAgICAgICAgICAgXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiLFxyXG4gICAgICAgICAgICBcInNoYWtlMTI4XCIsIFwic2hha2UyNTZcIixcclxuICAgICAgICAgICAgXCJTSEEzLTI1NlwiLCBcIlNIQTMtMzg0XCIsIFwiU0hBMy01MTJcIlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBSc2FDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8udmVyaWZ5KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IFJzYUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFJTQSBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYVBzc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlJzYVBzc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcclxuICAgICAgICAgICAgXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiLFxyXG4gICAgICAgICAgICBcInNoYWtlMTI4XCIsIFwic2hha2UyNTZcIixcclxuICAgICAgICAgICAgXCJTSEEzLTI1NlwiLCBcIlNIQTMtMzg0XCIsIFwiU0hBMy01MTJcIlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBSc2FDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8udmVyaWZ5KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IFJzYUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFJTQSBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYUNyeXB0byB7XHJcbiAgICBzdGF0aWMgc2l6ZShhbGdvcml0aG0pIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0xXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTYwO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAyNTY7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM4NDtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNTEyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMjU2XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTUxMlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtMjU2XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy0zODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTUxMlwiO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBoYXNoQWxnID0gdGhpcy5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGhhc2hBbGcpXHJcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLmRpZ2VzdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhT2FlcFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlJzYU9hZXBQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBSc2FDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcbiAgICAgICAgY29uc3Qga2V5U2l6ZSA9IE1hdGguY2VpbChpbnRlcm5hbEtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA+PiAzKTtcclxuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IFNoYUNyeXB0by5zaXplKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoKSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHBzTGVuZ3RoID0ga2V5U2l6ZSAtIGRhdGFMZW5ndGggLSAyICogaGFzaFNpemUgLSAyO1xyXG4gICAgICAgIGlmIChkYXRhTGVuZ3RoID4ga2V5U2l6ZSAtIDIgKiBoYXNoU2l6ZSAtIDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSB0b28gbGFyZ2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShrZXlTaXplKTtcclxuICAgICAgICBjb25zdCBzZWVkID0gbWVzc2FnZS5zdWJhcnJheSgxLCBoYXNoU2l6ZSArIDEpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFCbG9jayA9IG1lc3NhZ2Uuc3ViYXJyYXkoaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBkYXRhQmxvY2suc2V0KGRhdGFWaWV3LCBoYXNoU2l6ZSArIHBzTGVuZ3RoICsgMSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWxIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcclxuICAgICAgICAgICAgLnVwZGF0ZShjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShhbGdvcml0aG0ubGFiZWwgfHwgbmV3IFVpbnQ4QXJyYXkoMCkpKVxyXG4gICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgZGF0YUJsb2NrLnNldChsYWJlbEhhc2gsIDApO1xyXG4gICAgICAgIGRhdGFCbG9ja1toYXNoU2l6ZSArIHBzTGVuZ3RoXSA9IDE7XHJcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHNlZWQpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFCbG9ja01hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIHNlZWQsIGRhdGFCbG9jay5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUJsb2NrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFCbG9ja1tpXSBePSBkYXRhQmxvY2tNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWVkTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgZGF0YUJsb2NrLCBzZWVkLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZWRbaV0gXj0gc2VlZE1hc2tbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW50ZXJuYWxLZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGludGVybmFsS2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7aW50ZXJuYWxLZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwa2NzMCA9IGNyeXB0by5wdWJsaWNFbmNyeXB0KHtcclxuICAgICAgICAgICAga2V5OiBpbnRlcm5hbEtleS5wZW0sXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX05PX1BBRERJTkcsXHJcbiAgICAgICAgfSwgQnVmZmVyLmZyb20obWVzc2FnZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwa2NzMCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBjb25zdCBrZXlTaXplID0gTWF0aC5jZWlsKGludGVybmFsS2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gpID4+IDM7XHJcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICBpZiAoZGF0YUxlbmd0aCAhPT0ga2V5U2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgZGF0YVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpbnRlcm5hbEtleS5wZW0pIHtcclxuICAgICAgICAgICAgaW50ZXJuYWxLZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7aW50ZXJuYWxLZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBrY3MwID0gY3J5cHRvLnByaXZhdGVEZWNyeXB0KHtcclxuICAgICAgICAgICAga2V5OiBpbnRlcm5hbEtleS5wZW0sXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX05PX1BBRERJTkcsXHJcbiAgICAgICAgfSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGNvbnN0IHogPSBwa2NzMFswXTtcclxuICAgICAgICBjb25zdCBzZWVkID0gcGtjczAuc3ViYXJyYXkoMSwgaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBwa2NzMC5zdWJhcnJheShoYXNoU2l6ZSArIDEpO1xyXG4gICAgICAgIGlmICh6ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWVkTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgZGF0YUJsb2NrLCBzZWVkLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZWRbaV0gXj0gc2VlZE1hc2tbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGFCbG9ja01hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIHNlZWQsIGRhdGFCbG9jay5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUJsb2NrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFCbG9ja1tpXSBePSBkYXRhQmxvY2tNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYWJlbEhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpKVxyXG4gICAgICAgICAgICAudXBkYXRlKGNvcmVfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGFsZ29yaXRobS5sYWJlbCB8fCBuZXcgVWludDhBcnJheSgwKSkpXHJcbiAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhc2hTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxhYmVsSGFzaFtpXSAhPT0gZGF0YUJsb2NrW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHNFbmQgPSBoYXNoU2l6ZTtcclxuICAgICAgICBmb3IgKDsgcHNFbmQgPCBkYXRhQmxvY2subGVuZ3RoOyBwc0VuZCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBzeiA9IGRhdGFCbG9ja1twc0VuZF07XHJcbiAgICAgICAgICAgIGlmIChwc3ogPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwc3ogIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwc0VuZCA9PT0gZGF0YUJsb2NrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGtjczAgPSBkYXRhQmxvY2suc3ViYXJyYXkocHNFbmQgKyAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGtjczApLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IFJzYUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFJTQSBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWdmMShhbGdvcml0aG0sIHNlZWQsIGxlbmd0aCA9IDApIHtcclxuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IFNoYUNyeXB0by5zaXplKGFsZ29yaXRobSkgPj4gMztcclxuICAgICAgICBjb25zdCBtYXNrID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcbiAgICAgICAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGxlbmd0aCAvIGhhc2hTaXplKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbMF0gPSBpID4+PiAyNDtcclxuICAgICAgICAgICAgY291bnRlclsxXSA9IChpID4+PiAxNikgJiAyNTU7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbMl0gPSAoaSA+Pj4gOCkgJiAyNTU7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbM10gPSBpICYgMjU1O1xyXG4gICAgICAgICAgICBjb25zdCBzdWJtYXNrID0gbWFzay5zdWJhcnJheShpICogaGFzaFNpemUpO1xyXG4gICAgICAgICAgICBsZXQgY2h1bmsgPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0ubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoY291bnRlcilcclxuICAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IHN1Ym1hc2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnN1YmFycmF5KDAsIHN1Ym1hc2subGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdWJtYXNrLnNldChjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXNrO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYUVzUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQUVTLVBLQ1MxLXYxXzVcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcclxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJlbmNyeXB0XCIsIFwid3JhcEtleVwiXSxcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcclxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwicHVibGljRXhwb25lbnRcIik7XHJcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ICYmIGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTWlzc2luZyBvciBub3QgYSBVaW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNFeHBvbmVudCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0KGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCk7XHJcbiAgICAgICAgaWYgKCEocHVibGljRXhwb25lbnQgPT09IFwiQXc9PVwiIHx8IHB1YmxpY0V4cG9uZW50ID09PSBcIkFRQUJcIikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNdXN0IGJlIFszXSBvciBbMSwwLDFdXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibW9kdWx1c0xlbmd0aFwiKTtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTAyNDpcclxuICAgICAgICAgICAgY2FzZSAyMDQ4OlxyXG4gICAgICAgICAgICBjYXNlIDQwOTY6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtb2R1bHVzTGVuZ3RoOiBNdXN0IGJlIDEwMjQsIDIwNDgsIG9yIDQwOTZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMudG9DcnlwdG9PcHRpb25zKGtleSk7XHJcbiAgICAgICAgY29uc3QgZW5jID0gY3J5cHRvX19uYW1lc3BhY2UucHVibGljRW5jcnlwdChvcHRpb25zLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMudG9DcnlwdG9PcHRpb25zKGtleSk7XHJcbiAgICAgICAgY29uc3QgZGVjID0gY3J5cHRvX19uYW1lc3BhY2UucHJpdmF0ZURlY3J5cHQob3B0aW9ucywgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IFJzYUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFJTQSBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9DcnlwdG9PcHRpb25zKGtleSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBrZXkudHlwZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gJHt0eXBlfSBLRVktLS0tLVxcbiR7Z2V0Q3J5cHRvS2V5KGtleSkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCAke3R5cGV9IEtFWS0tLS0tYCxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvX19uYW1lc3BhY2UuY29uc3RhbnRzLlJTQV9QS0NTMV9QQURESU5HLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmFtZWRPSURzID0ge1xyXG4gICAgXCIxLjIuODQwLjEwMDQ1LjMuMS43XCI6IFwiUC0yNTZcIixcclxuICAgIFwiUC0yNTZcIjogXCIxLjIuODQwLjEwMDQ1LjMuMS43XCIsXHJcbiAgICBcIjEuMy4xMzIuMC4zNFwiOiBcIlAtMzg0XCIsXHJcbiAgICBcIlAtMzg0XCI6IFwiMS4zLjEzMi4wLjM0XCIsXHJcbiAgICBcIjEuMy4xMzIuMC4zNVwiOiBcIlAtNTIxXCIsXHJcbiAgICBcIlAtNTIxXCI6IFwiMS4zLjEzMi4wLjM1XCIsXHJcbiAgICBcIjEuMy4xMzIuMC4xMFwiOiBcIkstMjU2XCIsXHJcbiAgICBcIkstMjU2XCI6IFwiMS4zLjEzMi4wLjEwXCIsXHJcbiAgICBcImJyYWlucG9vbFAxNjByMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xXCI6IFwiYnJhaW5wb29sUDE2MHIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAxNjB0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4yXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4yXCI6IFwiYnJhaW5wb29sUDE2MHQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAxOTJyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4zXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4zXCI6IFwiYnJhaW5wb29sUDE5MnIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAxOTJ0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS40XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS40XCI6IFwiYnJhaW5wb29sUDE5MnQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAyMjRyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS41XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS41XCI6IFwiYnJhaW5wb29sUDIyNHIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAyMjR0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS42XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS42XCI6IFwiYnJhaW5wb29sUDIyNHQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAyNTZyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS43XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS43XCI6IFwiYnJhaW5wb29sUDI1NnIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAyNTZ0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS44XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS44XCI6IFwiYnJhaW5wb29sUDI1NnQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzMjByMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS45XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS45XCI6IFwiYnJhaW5wb29sUDMyMHIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzMjB0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTBcIjogXCJicmFpbnBvb2xQMzIwdDFcIixcclxuICAgIFwiYnJhaW5wb29sUDM4NHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjExXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMVwiOiBcImJyYWlucG9vbFAzODRyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzg0dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTJcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEyXCI6IFwiYnJhaW5wb29sUDM4NHQxXCIsXHJcbiAgICBcImJyYWlucG9vbFA1MTJyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xM1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTNcIjogXCJicmFpbnBvb2xQNTEycjFcIixcclxuICAgIFwiYnJhaW5wb29sUDUxMnQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjE0XCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xNFwiOiBcImJyYWlucG9vbFA1MTJ0MVwiLFxyXG59O1xyXG5mdW5jdGlvbiBnZXRPaWRCeU5hbWVkQ3VydmUkMShuYW1lZEN1cnZlKSB7XHJcbiAgICBjb25zdCBvaWQgPSBuYW1lZE9JRHNbbmFtZWRDdXJ2ZV07XHJcbiAgICBpZiAoIW9pZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBjb252ZXJ0IFdlYkNyeXB0byBuYW1lZCBjdXJ2ZSAnJHtuYW1lZEN1cnZlfScgdG8gT0lEYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2lkO1xyXG59XG5cbmNsYXNzIEVjUHJpdmF0ZUtleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInByaXZhdGVcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJFQ1wiLFxyXG4gICAgICAgICAgICBjcnY6IHRoaXMuYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgbmFtZWQgY3VydmUgZnJvbSBKV0suIFByb3BlcnR5ICdjcnYnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihnZXRPaWRCeU5hbWVkQ3VydmUkMShqc29uLmNydikpKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNQdWJsaWNLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwdWJsaWNcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleUluZm8ucHVibGljS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJFQ1wiLFxyXG4gICAgICAgICAgICBjcnY6IHRoaXMuYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgbmFtZWQgY3VydmUgZnJvbSBKV0suIFByb3BlcnR5ICdjcnYnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGpzb24uY3J2KSkpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnRvQVNOKGtleSkudmFsdWVIZXg7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtMVwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTI1NlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtMjU2XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzg0UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0zODRcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGE1MTJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTUxMlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTMyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy0yNTZcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzMzg0UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtMzg0XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzUxMlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTUxMlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IEVjUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIHByaXZhdGVLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBwcml2YXRlS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnByaXZhdGVLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgRWNQdWJsaWNLZXkoKTtcclxuICAgICAgICBwdWJsaWNLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHB1YmxpY0tleS5leHRyYWN0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBjcnlwdG8uZ2VuZXJhdGVLZXlQYWlyU3luYyhcImVjXCIsIHtcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogdGhpcy5nZXRPcGVuU1NMTmFtZWRDdXJ2ZShhbGdvcml0aG0ubmFtZWRDdXJ2ZSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5kYXRhID0ga2V5cy5wcml2YXRlS2V5O1xyXG4gICAgICAgIHB1YmxpY0tleS5kYXRhID0ga2V5cy5wdWJsaWNLZXk7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxyXG4gICAgICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0uaGFzaCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduZXIuc2lnbihvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBlY1NpZ25hdHVyZSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHNpZ25hdHVyZSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNEc2FTaWduYXR1cmUpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZVJhdyA9IGNvcmVfX25hbWVzcGFjZS5FY1V0aWxzLmVuY29kZVNpZ25hdHVyZShlY1NpZ25hdHVyZSwgY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLmdldChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpLnNpemUpO1xyXG4gICAgICAgIHJldHVybiBzaWduYXR1cmVSYXcuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNEc2FTaWduYXR1cmUoKTtcclxuICAgICAgICBjb25zdCBuYW1lZEN1cnZlID0gY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLmdldChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZVBvaW50ID0gY29yZV9fbmFtZXNwYWNlLkVjVXRpbHMuZGVjb2RlU2lnbmF0dXJlKHNpZ25hdHVyZSwgbmFtZWRDdXJ2ZS5zaXplKTtcclxuICAgICAgICBlY1NpZ25hdHVyZS5yID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZVBvaW50LnIpO1xyXG4gICAgICAgIGVjU2lnbmF0dXJlLnMgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlUG9pbnQucyk7XHJcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmVSYXcgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGVjU2lnbmF0dXJlKSk7XHJcbiAgICAgICAgY29uc3Qgb2sgPSBzaWduZXIudmVyaWZ5KG9wdGlvbnMsIGVjU2lnbmF0dXJlUmF3KTtcclxuICAgICAgICByZXR1cm4gb2s7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IHRoaXMuZ2V0T3BlblNTTE5hbWVkQ3VydmUoYmFzZUtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgY29uc3QgZWNkaCA9IGNyeXB0by5jcmVhdGVFQ0RIKGNyeXB0b0FsZyk7XHJcbiAgICAgICAgY29uc3QgYXNuUHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGJhc2VLZXkuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIGNvbnN0IGFzbkVjUHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGFzblByaXZhdGVLZXkucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5KTtcclxuICAgICAgICBlY2RoLnNldFByaXZhdGVLZXkoQnVmZmVyLmZyb20oYXNuRWNQcml2YXRlS2V5LnByaXZhdGVLZXkpKTtcclxuICAgICAgICBjb25zdCBhc25QdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShhbGdvcml0aG0ucHVibGljLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBlY2RoLmNvbXB1dGVTZWNyZXQoQnVmZmVyLmZyb20oYXNuUHVibGljS2V5LnB1YmxpY0tleSkpO1xyXG4gICAgICAgIGlmIChsZW5ndGggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaXRzKS5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoID4+IDMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleS5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNLZXlJbmZvLnB1YmxpY0tleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsIHBrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkoa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShuZXcgVWludDhBcnJheShrZXlEYXRhKSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkoa2V5SW5mby5wdWJsaWNLZXkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRLZXlQYXJhbWV0ZXJzKGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMsIGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShuZXcgVWludDhBcnJheShrZXlEYXRhKSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRLZXlQYXJhbWV0ZXJzKGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzLCBhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3NlcnRLZXlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIG5hbWVkQ3VydmUpIHtcclxuICAgICAgICBpZiAoIXBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5DcnlwdG9FcnJvcihcIktleSBpbmZvIGRvZXNuJ3QgaGF2ZSByZXF1aXJlZCBwYXJhbWV0ZXJzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmFtZWRDdXJ2ZUlkZW50aWZpZXIgPSBcIlwiO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG5hbWVkQ3VydmVJZGVudGlmaWVyID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UocGFyYW1ldGVycywgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcikudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvRXJyb3IoXCJDYW5ub3QgcmVhZCBrZXkgaW5mbyBwYXJhbWV0ZXJzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2V0T2lkQnlOYW1lZEN1cnZlJDEobmFtZWRDdXJ2ZSkgIT09IG5hbWVkQ3VydmVJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvRXJyb3IoXCJLZXkgaW5mbyBwYXJhbWV0ZXIgZG9lc24ndCBtYXRjaCB0byBuYW1lZCBjdXJ2ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihnZXRPaWRCeU5hbWVkQ3VydmUkMShhbGdvcml0aG0ubmFtZWRDdXJ2ZSkpKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVjUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBjb25zdCBuYW1lZEN1cnZlID0gZ2V0T2lkQnlOYW1lZEN1cnZlJDEoYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKG5hbWVkQ3VydmUpKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbktleS52YWx1ZTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWNQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRPcGVuU1NMTmFtZWRDdXJ2ZShjdXJ2ZSkge1xyXG4gICAgICAgIHN3aXRjaCAoY3VydmUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUC0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInByaW1lMjU2djFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIkstMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzZWNwMjU2azFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlAtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzZWNwMzg0cjFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlAtNTIxXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzZWNwNTIxcjFcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJ2ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuRWNDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCJdO1xyXG5FY0NyeXB0by5wcml2YXRlS2V5VXNhZ2VzID0gW1wic2lnblwiLCBcImRlcml2ZUtleVwiLCBcImRlcml2ZUJpdHNcIl07XG5cbmNsYXNzIEVjZHNhUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRWNkc2FQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMubmFtZXM7XHJcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcclxuICAgICAgICAgICAgXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiLFxyXG4gICAgICAgICAgICBcInNoYWtlMTI4XCIsIFwic2hha2UyNTZcIixcclxuICAgICAgICAgICAgXCJTSEEzLTI1NlwiLCBcIlNIQTMtMzg0XCIsIFwiU0hBMy01MTJcIlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFY0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8udmVyaWZ5KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgRUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBFY2RoUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRWNkaFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5uYW1lcztcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVjQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFY0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgRWNQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgRWNQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBFQyBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYml0cyA9IGF3YWl0IEVjQ3J5cHRvLmRlcml2ZUJpdHMoeyAuLi5hbGdvcml0aG0sIHB1YmxpYzogZ2V0Q3J5cHRvS2V5KGFsZ29yaXRobS5wdWJsaWMpIH0sIGdldENyeXB0b0tleShiYXNlS2V5KSwgbGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gYml0cztcclxuICAgIH1cclxufVxuXG5jb25zdCBlZE9JRHMgPSB7XHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRFZDQ0OF06IFwiRWQ0NDhcIixcclxuICAgIFwiZWQ0NDhcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRFZDQ0OCxcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFg0NDhdOiBcIlg0NDhcIixcclxuICAgIFwieDQ0OFwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFg0NDgsXHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRFZDI1NTE5XTogXCJFZDI1NTE5XCIsXHJcbiAgICBcImVkMjU1MTlcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRFZDI1NTE5LFxyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkWDI1NTE5XTogXCJYMjU1MTlcIixcclxuICAgIFwieDI1NTE5XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkWDI1NTE5LFxyXG59O1xyXG5mdW5jdGlvbiBnZXRPaWRCeU5hbWVkQ3VydmUobmFtZWRDdXJ2ZSkge1xyXG4gICAgY29uc3Qgb2lkID0gZWRPSURzW25hbWVkQ3VydmUudG9Mb3dlckNhc2UoKV07XHJcbiAgICBpZiAoIW9pZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBjb252ZXJ0IFdlYkNyeXB0byBuYW1lZCBjdXJ2ZSAnJHtuYW1lZEN1cnZlfScgdG8gT0lEYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2lkO1xyXG59XG5cbmNsYXNzIEVkUHJpdmF0ZUtleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInByaXZhdGVcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJPS1BcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZShqc29uLmNydik7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5DdXJ2ZVByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVkUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGtleUluZm8ucHVibGljS2V5O1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIk9LUFwiLFxyXG4gICAgICAgICAgICBjcnY6IHRoaXMuYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCB7XHJcbiAgICAgICAgICAgIHg6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGtleSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgbmFtZWQgY3VydmUgZnJvbSBKV0suIFByb3BlcnR5ICdjcnYnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghanNvbi54KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgcHJvcGVydHkgZnJvbSBKV0suIFByb3BlcnR5ICd4JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBnZXRPaWRCeU5hbWVkQ3VydmUoanNvbi5jcnYpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLngpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVkQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IEVkUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIHByaXZhdGVLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBwcml2YXRlS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnByaXZhdGVLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgRWRQdWJsaWNLZXkoKTtcclxuICAgICAgICBwdWJsaWNLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHB1YmxpY0tleS5leHRyYWN0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhbGdvcml0aG0ubmFtZWRDdXJ2ZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBjcnlwdG8uZ2VuZXJhdGVLZXlQYWlyU3luYyh0eXBlLCB7XHJcbiAgICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5kYXRhID0ga2V5cy5wcml2YXRlS2V5O1xyXG4gICAgICAgIHB1YmxpY0tleS5kYXRhID0ga2V5cy5wdWJsaWNLZXk7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxyXG4gICAgICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBjcnlwdG8uc2lnbihudWxsLCBCdWZmZXIuZnJvbShkYXRhKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGNvcmVfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG9rID0gY3J5cHRvLnZlcmlmeShudWxsLCBCdWZmZXIuZnJvbShkYXRhKSwgb3B0aW9ucywgQnVmZmVyLmZyb20oc2lnbmF0dXJlKSk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KHtcclxuICAgICAgICAgICAga2V5OiBhbGdvcml0aG0ucHVibGljLmRhdGEsXHJcbiAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0by5jcmVhdGVQcml2YXRlS2V5KHtcclxuICAgICAgICAgICAga2V5OiBiYXNlS2V5LmRhdGEsXHJcbiAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBjcnlwdG8uZGlmZmllSGVsbG1hbih7XHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYml0cykuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCA+PiAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXkuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVibGljS2V5SW5mby5wdWJsaWNLZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCBwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqd2sueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogQ2Fubm90IGdldCByZXF1aXJlZCAneCcgZmlsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGp3ay54KSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShuZXcgVWludDhBcnJheShrZXlEYXRhKSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoa2V5SW5mby5wdWJsaWNLZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShuZXcgVWludDhBcnJheShrZXlEYXRhKSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5DdXJ2ZVByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCAncGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFZFByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZnJvbUpTT04oe1xyXG4gICAgICAgICAgICBjcnY6IGFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBkOiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChhc25LZXkuZCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFZFB1YmxpY0tleSgpO1xyXG4gICAgICAgIGtleS5mcm9tSlNPTih7XHJcbiAgICAgICAgICAgIGNydjogYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIHg6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGFzbktleSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG59XHJcbkVkQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiXTtcclxuRWRDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuXG5jbGFzcyBFZERzYVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVkRHNhUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWRDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6IGFsZ29yaXRobS5uYW1lZEN1cnZlLnJlcGxhY2UoL15lZC9pLCBcIkVkXCIpLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8udmVyaWZ5KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWRDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNkaEVzUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRWNkaEVzUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWRDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6IGFsZ29yaXRobS5uYW1lZEN1cnZlLnRvVXBwZXJDYXNlKCksXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYml0cyA9IGF3YWl0IEVkQ3J5cHRvLmRlcml2ZUJpdHMoeyAuLi5hbGdvcml0aG0sIHB1YmxpYzogZ2V0Q3J5cHRvS2V5KGFsZ29yaXRobS5wdWJsaWMpIH0sIGdldENyeXB0b0tleShiYXNlS2V5KSwgbGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gYml0cztcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWRDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUGJrZGZDcnlwdG9LZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG59XG5cbmNsYXNzIFBia2RmMlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlBia2RmMlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoYWxnb3JpdGhtLnNhbHQpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNoID0gYWxnb3JpdGhtLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcclxuICAgICAgICAgICAgY3J5cHRvLnBia2RmMihnZXRDcnlwdG9LZXkoYmFzZUtleSkuZGF0YSwgQnVmZmVyLmZyb20oc2FsdCksIGFsZ29yaXRobS5pdGVyYXRpb25zLCBsZW5ndGggPj4gMywgaGFzaCwgKGVyciwgZGVyaXZlZEJpdHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoZGVyaXZlZEJpdHMpLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInJhd1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBQYmtkZkNyeXB0b0tleSgpO1xyXG4gICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICBrZXkuYWxnb3JpdGhtID0geyBuYW1lOiB0aGlzLm5hbWUgfTtcclxuICAgICAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAncmF3J1wiKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIFBia2RmQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUEJLREYgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBIbWFjQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxuICAgIGdldCBhbGcoKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuYWxnb3JpdGhtLmhhc2gubmFtZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBgSFMke2hhc2gucmVwbGFjZShcIlNIQS1cIiwgXCJcIil9YDtcclxuICAgIH1cclxuICAgIHNldCBhbGcodmFsdWUpIHtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXHJcbl0sIEhtYWNDcnlwdG9LZXkucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcblxuY2xhc3MgSG1hY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkhtYWNQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IChhbGdvcml0aG0ubGVuZ3RoIHx8IHRoaXMuZ2V0RGVmYXVsdExlbmd0aChhbGdvcml0aG0uaGFzaC5uYW1lKSkgPj4gMyA8PCAzO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBIbWFjQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAga2V5LmRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGtleS5hbGdvcml0aG0uaGFzaCk7XHJcbiAgICAgICAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyeXB0b0FsZywgZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSlcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhtYWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhjcnlwdG9BbGcsIGdldENyeXB0b0tleShrZXkpLmRhdGEpXHJcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLmRpZ2VzdCgpO1xyXG4gICAgICAgIHJldHVybiBobWFjLmNvbXBhcmUoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSkgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IEhtYWNDcnlwdG9LZXkgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0gbmV3IEhtYWNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7XHJcbiAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogYWxnb3JpdGhtLmhhc2gubmFtZSB9LFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDoga2V5LmRhdGEubGVuZ3RoIDw8IDMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBIbWFjQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgSE1BQyBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEhrZGZDcnlwdG9LZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG59XG5cbmNsYXNzIEhrZGZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Ia2RmUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBpZiAoZm9ybWF0LnRvTG93ZXJDYXNlKCkgIT09IFwicmF3XCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcIk9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgSGtkZkNyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IHsgbmFtZTogdGhpcy5uYW1lIH07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMocGFyYW1zLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gcGFyYW1zLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcclxuICAgICAgICBjb25zdCBoYXNoTGVuZ3RoID0gY3J5cHRvLmNyZWF0ZUhhc2goaGFzaCkuZGlnZXN0KCkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBsZW5ndGggLyA4O1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1zLmluZm8pO1xyXG4gICAgICAgIGNvbnN0IFBSSyA9IGNyeXB0by5jcmVhdGVIbWFjKGhhc2gsIGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwYXJhbXMuc2FsdCkpXHJcbiAgICAgICAgICAgIC51cGRhdGUoY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGdldENyeXB0b0tleShiYXNlS2V5KS5kYXRhKSlcclxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtCdWZmZXIuYWxsb2MoMCldO1xyXG4gICAgICAgIGNvbnN0IGJsb2NrQ291bnQgPSBNYXRoLmNlaWwoYnl0ZUxlbmd0aCAvIGhhc2hMZW5ndGgpICsgMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcnlwdG8uY3JlYXRlSG1hYyhoYXNoLCBQUkspXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5jb25jYXQoW2Jsb2Nrc1tpIC0gMV0sIGluZm8sIEJ1ZmZlci5mcm9tKFtpXSldKSlcclxuICAgICAgICAgICAgICAgIC5kaWdlc3QoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJsb2Nrcykuc2xpY2UoMCwgYnl0ZUxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBIa2RmQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgSEtERiBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWtlQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBkaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCksIHsgb3V0cHV0TGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoIH0pXHJcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLmRpZ2VzdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hha2UxMjhQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5TaGFrZTEyOFByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFrZUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFrZTI1NlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlNoYWtlMjU2UHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYWtlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFN1YnRsZUNyeXB0byBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5TdWJ0bGVDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNDYmNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0N0clByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzR2NtUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNDbWFjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNLd1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzRWNiUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBEZXNDYmNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IERlc0VkZTNDYmNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYVNzYVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhUHNzUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FPYWVwUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FFc1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkc2FQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVjZGhQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTFQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTI1NlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzg0UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGE1MTJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFBia2RmMlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgSG1hY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgSGtkZlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYWpvclZlcnNpb24gPSAoX2EgPSAvXnYoXFxkKykvLmV4ZWMocHJvY2Vzc19fbmFtZXNwYWNlLnZlcnNpb24pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV07XHJcbiAgICAgICAgaWYgKG5vZGVNYWpvclZlcnNpb24gJiYgcGFyc2VJbnQobm9kZU1ham9yVmVyc2lvbiwgMTApID49IDEyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hha2UxMjhQcm92aWRlcigpKTtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGFrZTI1NlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYXNoZXMgPSBjcnlwdG9fX25hbWVzcGFjZS5nZXRIYXNoZXMoKTtcclxuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy0yNTZcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzMjU2UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTM4NFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTMzODRQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtNTEyXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzUxMlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZU1ham9yVmVyc2lvbiAmJiBwYXJzZUludChub2RlTWFqb3JWZXJzaW9uLCAxMCkgPj0gMTQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFZERzYVByb3ZpZGVyKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVjZGhFc1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBDcnlwdG8gZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5zdWJ0bGUgPSBuZXcgU3VidGxlQ3J5cHRvKCk7XHJcbiAgICB9XHJcbiAgICBnZXRSYW5kb21WYWx1ZXMoYXJyYXkpIHtcclxuICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhhcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdnZXRSYW5kb21WYWx1ZXMnIG9uICdDcnlwdG8nOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnQXJyYXlCdWZmZXJWaWV3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJyYXkuYnVmZmVyLCBhcnJheS5ieXRlT2Zmc2V0LCBhcnJheS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoYnVmZmVyKTtcclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDcnlwdG9LZXknLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZS5DcnlwdG9LZXk7IH1cbn0pO1xuZXhwb3J0cy5DcnlwdG8gPSBDcnlwdG87XG4iXSwibmFtZXMiOlsiY29yZSIsInJlcXVpcmUiLCJjcnlwdG8iLCJwcm9jZXNzIiwidHNsaWIiLCJqc29uU2NoZW1hIiwicHZ0c3V0aWxzIiwiYXNuMVNjaGVtYSIsIl9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdCIsImUiLCJuIiwiT2JqZWN0IiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImRlZmF1bHQiLCJmcmVlemUiLCJjb3JlX19uYW1lc3BhY2UiLCJjcnlwdG9fX25hbWVzcGFjZSIsInByb2Nlc3NfX25hbWVzcGFjZSIsIkpzb25CYXNlNjRVcmxDb252ZXJ0ZXIiLCJmcm9tSlNPTiIsInZhbHVlIiwiQnVmZmVyIiwiZnJvbSIsIkNvbnZlcnQiLCJGcm9tQmFzZTY0VXJsIiwidG9KU09OIiwiVG9CYXNlNjRVcmwiLCJDcnlwdG9LZXkiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsImRhdGEiLCJhbGxvYyIsImFsZ29yaXRobSIsIm5hbWUiLCJleHRyYWN0YWJsZSIsInR5cGUiLCJ1c2FnZXMiLCJrdHkiLCJhbGciLCJfX2RlY29yYXRlIiwiSnNvblByb3AiLCJKc29uUHJvcFR5cGVzIiwiQm9vbGVhbiIsIm9wdGlvbmFsIiwicHJvdG90eXBlIiwiU3RyaW5nIiwicmVwZWF0ZWQiLCJTeW1tZXRyaWNLZXkiLCJBc3ltbWV0cmljS2V5IiwiQWVzQ3J5cHRvS2V5IiwidG9VcHBlckNhc2UiLCJsZW5ndGgiLCJBbGdvcml0aG1FcnJvciIsImNvbnZlcnRlciIsImtleVN0b3JhZ2UiLCJXZWFrTWFwIiwiZ2V0Q3J5cHRvS2V5Iiwia2V5IiwicmVzIiwiT3BlcmF0aW9uRXJyb3IiLCJzZXRDcnlwdG9LZXkiLCJzZXQiLCJBZXNDcnlwdG8iLCJnZW5lcmF0ZUtleSIsImtleVVzYWdlcyIsInJhbmRvbUJ5dGVzIiwiZXhwb3J0S2V5IiwiZm9ybWF0IiwiRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsIkpzb25TZXJpYWxpemVyIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImltcG9ydEtleSIsImtleURhdGEiLCJKc29uUGFyc2VyIiwidGFyZ2V0U2NoZW1hIiwiZW5jcnlwdCIsImVuY3J5cHRBZXNDQkMiLCJlbmNyeXB0QWVzQ1RSIiwiZW5jcnlwdEFlc0dDTSIsImVuY3J5cHRBZXNLVyIsImVuY3J5cHRBZXNFQ0IiLCJkZWNyeXB0IiwiZGVjcnlwdEFlc0NCQyIsImRlY3J5cHRBZXNDVFIiLCJkZWNyeXB0QWVzR0NNIiwiZGVjcnlwdEFlc0tXIiwiZGVjcnlwdEFlc0VDQiIsImNpcGhlciIsImNyZWF0ZUNpcGhlcml2IiwiaXYiLCJlbmMiLCJ1cGRhdGUiLCJjb25jYXQiLCJmaW5hbCIsImRlY2lwaGVyIiwiY3JlYXRlRGVjaXBoZXJpdiIsImRlYyIsImNvdW50ZXIiLCJhdXRoVGFnTGVuZ3RoIiwidGFnTGVuZ3RoIiwiYWRkaXRpb25hbERhdGEiLCJzZXRBQUQiLCJnZXRBdXRoVGFnIiwic2xpY2UiLCJ0YWciLCJzZXRBdXRoVGFnIiwiQUVTX0tXX0lWIiwiQWVzQ2JjUHJvdmlkZXIiLCJvbkdlbmVyYXRlS2V5Iiwib25FbmNyeXB0Iiwib25EZWNyeXB0Iiwib25FeHBvcnRLZXkiLCJvbkltcG9ydEtleSIsImNoZWNrQ3J5cHRvS2V5Iiwia2V5VXNhZ2UiLCJUeXBlRXJyb3IiLCJ6ZXJvIiwicmIiLCJibG9ja1NpemUiLCJiaXRTaGlmdExlZnQiLCJzaGlmdGVkIiwibGFzdCIsImluZGV4IiwieG9yIiwiYSIsImIiLCJNYXRoIiwibWluIiwib3V0cHV0IiwiYWVzIiwibWVzc2FnZSIsInJlc3VsdCIsImdldE1lc3NhZ2VCbG9jayIsImJsb2NrSW5kZXgiLCJibG9jayIsInN0YXJ0IiwiZW5kIiwiY29weSIsImdldFBhZGRlZE1lc3NhZ2VCbG9jayIsImZpbGwiLCJnZW5lcmF0ZVN1YmtleXMiLCJsIiwic3Via2V5MSIsInN1YmtleTIiLCJhZXNDbWFjIiwic3Via2V5cyIsImJsb2NrQ291bnQiLCJjZWlsIiwibGFzdEJsb2NrQ29tcGxldGVGbGFnIiwibGFzdEJsb2NrIiwibGFzdEJsb2NrSW5kZXgiLCJ4IiwieSIsIkFlc0NtYWNQcm92aWRlciIsIm9uU2lnbiIsIm9uVmVyaWZ5Iiwic2lnbmF0dXJlIiwic2lnbmF0dXJlMiIsInNpZ24iLCJjb21wYXJlIiwiQWVzQ3RyUHJvdmlkZXIiLCJBZXNHY21Qcm92aWRlciIsIkFlc0t3UHJvdmlkZXIiLCJBZXNFY2JQcm92aWRlciIsIkRlc0NyeXB0b0tleSIsIkRlc0NyeXB0byIsImVuY3J5cHREZXNDQkMiLCJlbmNyeXB0RGVzRURFM0NCQyIsImRlY3J5cHREZXNDQkMiLCJkZWNyeXB0RGVzRURFM0NCQyIsIkRlc0NiY1Byb3ZpZGVyIiwiRGVzUHJvdmlkZXIiLCJrZXlTaXplQml0cyIsIml2U2l6ZSIsIkRlc0VkZTNDYmNQcm92aWRlciIsImdldEp3a0FsZ29yaXRobSIsIm1kU2l6ZSIsImV4ZWMiLCJoYXNoIiwiUnNhUHJpdmF0ZUtleSIsImdldEtleSIsImtleUluZm8iLCJBc25QYXJzZXIiLCJwYXJzZSIsImFzbjEiLCJQcml2YXRlS2V5SW5mbyIsInByaXZhdGVLZXkiLCJqc29uIiwia2V5X29wcyIsImV4dCIsImFzc2lnbiIsInByaXZhdGVLZXlBbGdvcml0aG0iLCJwYXJhbWV0ZXJzIiwiQXNuU2VyaWFsaXplciIsInNlcmlhbGl6ZSIsIlJzYVB1YmxpY0tleSIsIlB1YmxpY0tleUluZm8iLCJwdWJsaWNLZXkiLCJwdWJsaWNLZXlBbGdvcml0aG0iLCJSc2FDcnlwdG8iLCJmaWx0ZXIiLCJ1c2FnZSIsInByaXZhdGVLZXlVc2FnZXMiLCJpbmRleE9mIiwicHVibGljS2V5VXNhZ2VzIiwicHVibGljRXhwb25lbnQiLCJieXRlTGVuZ3RoIiwicmVhZEludDMyQkUiLCJnZW5lcmF0ZUtleVBhaXJTeW5jIiwibW9kdWx1c0xlbmd0aCIsInB1YmxpY0tleUVuY29kaW5nIiwicHJpdmF0ZUtleUVuY29kaW5nIiwiandrIiwiYXNuS2V5IiwiaW1wb3J0UHJpdmF0ZUtleSIsImltcG9ydFB1YmxpY0tleSIsInNpZ25Sc2EiLCJ2ZXJpZnkiLCJ2ZXJpZnlTU0EiLCJlbmNyeXB0T0FFUCIsImRlY3J5cHRPQUVQIiwibW9kdWx1cyIsImdldENyeXB0b0FsZ29yaXRobSIsImNyeXB0b0FsZyIsInNpZ25lciIsImNyZWF0ZVNpZ24iLCJwZW0iLCJ0b1N0cmluZyIsIm9wdGlvbnMiLCJwYWRkaW5nIiwiY29uc3RhbnRzIiwiUlNBX1BLQ1MxX1BTU19QQURESU5HIiwic2FsdExlbmd0aCIsImNyZWF0ZVZlcmlmeSIsIm9rIiwiUlNBX1BLQ1MxX09BRVBfUEFERElORyIsImxhYmVsIiwicHVibGljRW5jcnlwdCIsInByaXZhdGVEZWNyeXB0IiwiUnNhU3NhUHJvdmlkZXIiLCJoYXNoQWxnb3JpdGhtcyIsImludGVybmFsS2V5IiwiUnNhUHNzUHJvdmlkZXIiLCJTaGFDcnlwdG8iLCJzaXplIiwiZ2V0QWxnb3JpdGhtTmFtZSIsImRpZ2VzdCIsImhhc2hBbGciLCJjcmVhdGVIYXNoIiwiUnNhT2FlcFByb3ZpZGVyIiwiZGF0YVZpZXciLCJrZXlTaXplIiwiaGFzaFNpemUiLCJkYXRhTGVuZ3RoIiwicHNMZW5ndGgiLCJzZWVkIiwic3ViYXJyYXkiLCJkYXRhQmxvY2siLCJsYWJlbEhhc2giLCJyZXBsYWNlIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwidG9VaW50OEFycmF5IiwicmFuZG9tRmlsbFN5bmMiLCJkYXRhQmxvY2tNYXNrIiwibWdmMSIsImkiLCJzZWVkTWFzayIsInBrY3MwIiwiUlNBX05PX1BBRERJTkciLCJ6IiwicHNFbmQiLCJwc3oiLCJtYXNrIiwiY2h1bmtzIiwic3VibWFzayIsImNodW5rIiwiUnNhRXNQcm92aWRlciIsIlByb3ZpZGVyQ3J5cHRvIiwiY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyIsImNoZWNrUmVxdWlyZWRQcm9wZXJ0eSIsIlRvQmFzZTY0IiwidG9DcnlwdG9PcHRpb25zIiwiUlNBX1BLQ1MxX1BBRERJTkciLCJuYW1lZE9JRHMiLCJnZXRPaWRCeU5hbWVkQ3VydmUkMSIsIm5hbWVkQ3VydmUiLCJvaWQiLCJFY1ByaXZhdGVLZXkiLCJjcnYiLCJPYmplY3RJZGVudGlmaWVyIiwiRWNQdWJsaWNLZXkiLCJ0b0FTTiIsInZhbHVlSGV4IiwiU2hhMVByb3ZpZGVyIiwib25EaWdlc3QiLCJTaGEyNTZQcm92aWRlciIsIlNoYTM4NFByb3ZpZGVyIiwiU2hhNTEyUHJvdmlkZXIiLCJTaGEzMjU2UHJvdmlkZXIiLCJTaGEzMzg0UHJvdmlkZXIiLCJTaGEzNTEyUHJvdmlkZXIiLCJFY0NyeXB0byIsImdldE9wZW5TU0xOYW1lZEN1cnZlIiwiZWNTaWduYXR1cmUiLCJFY0RzYVNpZ25hdHVyZSIsInNpZ25hdHVyZVJhdyIsIkVjVXRpbHMiLCJlbmNvZGVTaWduYXR1cmUiLCJFY0N1cnZlcyIsInNpZ25hdHVyZVBvaW50IiwiZGVjb2RlU2lnbmF0dXJlIiwiciIsInRvQXJyYXlCdWZmZXIiLCJzIiwiZWNTaWduYXR1cmVSYXciLCJkZXJpdmVCaXRzIiwiYmFzZUtleSIsImVjZGgiLCJjcmVhdGVFQ0RIIiwiYXNuUHJpdmF0ZUtleSIsImFzbkVjUHJpdmF0ZUtleSIsInNldFByaXZhdGVLZXkiLCJhc25QdWJsaWNLZXkiLCJwdWJsaWMiLCJiaXRzIiwiY29tcHV0ZVNlY3JldCIsInB1YmxpY0tleUluZm8iLCJhc3NlcnRLZXlQYXJhbWV0ZXJzIiwiQ3J5cHRvRXJyb3IiLCJuYW1lZEN1cnZlSWRlbnRpZmllciIsImN1cnZlIiwiRWNkc2FQcm92aWRlciIsIm5hbWVkQ3VydmVzIiwibmFtZXMiLCJFY2RoUHJvdmlkZXIiLCJvbkRlcml2ZUJpdHMiLCJlZE9JRHMiLCJpZEVkNDQ4IiwiaWRYNDQ4IiwiaWRFZDI1NTE5IiwiaWRYMjU1MTkiLCJnZXRPaWRCeU5hbWVkQ3VydmUiLCJFZFByaXZhdGVLZXkiLCJDdXJ2ZVByaXZhdGVLZXkiLCJFZFB1YmxpY0tleSIsIkVkQ3J5cHRvIiwiY3JlYXRlUHVibGljS2V5IiwiY3JlYXRlUHJpdmF0ZUtleSIsImRpZmZpZUhlbGxtYW4iLCJFZERzYVByb3ZpZGVyIiwiRWNkaEVzUHJvdmlkZXIiLCJQYmtkZkNyeXB0b0tleSIsIlBia2RmMlByb3ZpZGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzYWx0IiwicGJrZGYyIiwiaXRlcmF0aW9ucyIsImVyciIsImRlcml2ZWRCaXRzIiwiSG1hY0NyeXB0b0tleSIsIkhtYWNQcm92aWRlciIsImdldERlZmF1bHRMZW5ndGgiLCJobWFjIiwiY3JlYXRlSG1hYyIsIkhrZGZDcnlwdG9LZXkiLCJIa2RmUHJvdmlkZXIiLCJwYXJhbXMiLCJoYXNoTGVuZ3RoIiwiaW5mbyIsIlBSSyIsImJsb2NrcyIsInB1c2giLCJTaGFrZUNyeXB0byIsIm91dHB1dExlbmd0aCIsIlNoYWtlMTI4UHJvdmlkZXIiLCJTaGFrZTI1NlByb3ZpZGVyIiwiU3VidGxlQ3J5cHRvIiwiX2EiLCJwcm92aWRlcnMiLCJub2RlTWFqb3JWZXJzaW9uIiwidmVyc2lvbiIsInBhcnNlSW50IiwiaGFzaGVzIiwiZ2V0SGFzaGVzIiwiaW5jbHVkZXMiLCJDcnlwdG8iLCJzdWJ0bGUiLCJnZXRSYW5kb21WYWx1ZXMiLCJhcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZU9mZnNldCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@peculiar/webcrypto/build/webcrypto.js\n");

/***/ })

};
;