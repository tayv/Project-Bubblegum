"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webcrypto-core";
exports.ids = ["vendor-chunks/webcrypto-core"];
exports.modules = {

/***/ "(rsc)/../../node_modules/webcrypto-core/build/webcrypto-core.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/webcrypto-core/build/webcrypto-core.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ \nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/../../node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(rsc)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"(rsc)/../../node_modules/tslib/tslib.es6.js\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(rsc)/../../node_modules/@peculiar/json-schema/build/index.js\");\nvar asn1 = __webpack_require__(/*! asn1js */ \"(rsc)/../../node_modules/asn1js/build/index.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar asn1__namespace = /*#__PURE__*/ _interopNamespaceDefault(asn1);\nclass CryptoError extends Error {\n}\nclass AlgorithmError extends CryptoError {\n}\nclass UnsupportedOperationError extends CryptoError {\n    constructor(methodName){\n        super(`Unsupported operation: ${methodName ? `${methodName}` : \"\"}`);\n    }\n}\nclass OperationError extends CryptoError {\n}\nclass RequiredPropertyError extends CryptoError {\n    constructor(propName){\n        super(`${propName}: Missing required property`);\n    }\n}\nclass PemConverter {\n    static toArrayBuffer(pem) {\n        const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/g, \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\");\n        return pvtsutils.Convert.FromBase64(base64);\n    }\n    static toUint8Array(pem) {\n        const bytes = this.toArrayBuffer(pem);\n        return new Uint8Array(bytes);\n    }\n    static fromBufferSource(buffer, tag) {\n        const base64 = pvtsutils.Convert.ToBase64(buffer);\n        let sliced;\n        let offset = 0;\n        const rows = [];\n        while(true){\n            sliced = base64.slice(offset, offset = offset + 64);\n            if (sliced.length) {\n                rows.push(sliced);\n                if (sliced.length < 64) {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        const upperCaseTag = tag.toUpperCase();\n        return `-----BEGIN ${upperCaseTag}-----\\n${rows.join(\"\\n\")}\\n-----END ${upperCaseTag}-----`;\n    }\n    static isPEM(data) {\n        return /-----BEGIN .+-----[A-Za-z0-9+\\/\\+\\=\\s\\n]+-----END .+-----/i.test(data);\n    }\n    static getTagName(pem) {\n        if (!this.isPEM(pem)) {\n            throw new Error(\"Bad parameter. Incoming data is not right PEM\");\n        }\n        const res = /-----BEGIN (.+)-----/.exec(pem);\n        if (!res) {\n            throw new Error(\"Cannot get tag from PEM\");\n        }\n        return res[1];\n    }\n    static hasTagName(pem, tagName) {\n        const tag = this.getTagName(pem);\n        return tagName.toLowerCase() === tag.toLowerCase();\n    }\n    static isCertificate(pem) {\n        return this.hasTagName(pem, \"certificate\");\n    }\n    static isCertificateRequest(pem) {\n        return this.hasTagName(pem, \"certificate request\");\n    }\n    static isCRL(pem) {\n        return this.hasTagName(pem, \"x509 crl\");\n    }\n    static isPublicKey(pem) {\n        return this.hasTagName(pem, \"public key\");\n    }\n}\nfunction isJWK(data) {\n    return typeof data === \"object\" && \"kty\" in data;\n}\nclass ProviderCrypto {\n    async digest(...args) {\n        this.checkDigest.apply(this, args);\n        return this.onDigest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        this.checkAlgorithmName(algorithm);\n    }\n    async onDigest(algorithm, data) {\n        throw new UnsupportedOperationError(\"digest\");\n    }\n    async generateKey(...args) {\n        this.checkGenerateKey.apply(this, args);\n        return this.onGenerateKey.apply(this, args);\n    }\n    checkGenerateKey(algorithm, extractable, keyUsages, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkGenerateKeyParams(algorithm);\n        if (!(keyUsages && keyUsages.length)) {\n            throw new TypeError(`Usages cannot be empty when creating a key.`);\n        }\n        let allowedUsages;\n        if (Array.isArray(this.usages)) {\n            allowedUsages = this.usages;\n        } else {\n            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);\n        }\n        this.checkKeyUsages(keyUsages, allowedUsages);\n    }\n    checkGenerateKeyParams(algorithm) {}\n    async onGenerateKey(algorithm, extractable, keyUsages, ...args) {\n        throw new UnsupportedOperationError(\"generateKey\");\n    }\n    async sign(...args) {\n        this.checkSign.apply(this, args);\n        return this.onSign.apply(this, args);\n    }\n    checkSign(algorithm, key, data, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"sign\");\n    }\n    async onSign(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"sign\");\n    }\n    async verify(...args) {\n        this.checkVerify.apply(this, args);\n        return this.onVerify.apply(this, args);\n    }\n    checkVerify(algorithm, key, signature, data, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"verify\");\n    }\n    async onVerify(algorithm, key, signature, data, ...args) {\n        throw new UnsupportedOperationError(\"verify\");\n    }\n    async encrypt(...args) {\n        this.checkEncrypt.apply(this, args);\n        return this.onEncrypt.apply(this, args);\n    }\n    checkEncrypt(algorithm, key, data, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"encrypt\" : void 0);\n    }\n    async onEncrypt(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"encrypt\");\n    }\n    async decrypt(...args) {\n        this.checkDecrypt.apply(this, args);\n        return this.onDecrypt.apply(this, args);\n    }\n    checkDecrypt(algorithm, key, data, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"decrypt\" : void 0);\n    }\n    async onDecrypt(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"decrypt\");\n    }\n    async deriveBits(...args) {\n        this.checkDeriveBits.apply(this, args);\n        return this.onDeriveBits.apply(this, args);\n    }\n    checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(baseKey, options.keyUsage ? \"deriveBits\" : void 0);\n        if (length % 8 !== 0) {\n            throw new OperationError(\"length: Is not multiple of 8\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length, ...args) {\n        throw new UnsupportedOperationError(\"deriveBits\");\n    }\n    async exportKey(...args) {\n        this.checkExportKey.apply(this, args);\n        return this.onExportKey.apply(this, args);\n    }\n    checkExportKey(format, key, ...args) {\n        this.checkKeyFormat(format);\n        this.checkCryptoKey(key);\n        if (!key.extractable) {\n            throw new CryptoError(\"key: Is not extractable\");\n        }\n    }\n    async onExportKey(format, key, ...args) {\n        throw new UnsupportedOperationError(\"exportKey\");\n    }\n    async importKey(...args) {\n        this.checkImportKey.apply(this, args);\n        return this.onImportKey.apply(this, args);\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        this.checkKeyFormat(format);\n        this.checkKeyData(format, keyData);\n        this.checkAlgorithmName(algorithm);\n        this.checkImportParams(algorithm);\n        if (Array.isArray(this.usages)) {\n            this.checkKeyUsages(keyUsages, this.usages);\n        }\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        throw new UnsupportedOperationError(\"importKey\");\n    }\n    checkAlgorithmName(algorithm) {\n        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n    }\n    checkAlgorithmParams(algorithm) {}\n    checkDerivedKeyParams(algorithm) {}\n    checkKeyUsages(usages, allowed) {\n        for (const usage of usages){\n            if (allowed.indexOf(usage) === -1) {\n                throw new TypeError(\"Cannot create a key using the specified key usages\");\n            }\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        this.checkAlgorithmName(key.algorithm);\n        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {\n            throw new CryptoError(`key does not match that of operation`);\n        }\n    }\n    checkRequiredProperty(data, propName) {\n        if (!(propName in data)) {\n            throw new RequiredPropertyError(propName);\n        }\n    }\n    checkHashAlgorithm(algorithm, hashAlgorithms) {\n        for (const item of hashAlgorithms){\n            if (item.toLowerCase() === algorithm.name.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(\", \")}`);\n    }\n    checkImportParams(algorithm) {}\n    checkKeyFormat(format) {\n        switch(format){\n            case \"raw\":\n            case \"pkcs8\":\n            case \"spki\":\n            case \"jwk\":\n                break;\n            default:\n                throw new TypeError(\"format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'\");\n        }\n    }\n    checkKeyData(format, keyData) {\n        if (!keyData) {\n            throw new TypeError(\"keyData: Cannot be empty on empty on key importing\");\n        }\n        if (format === \"jwk\") {\n            if (!isJWK(keyData)) {\n                throw new TypeError(\"keyData: Is not JsonWebToken\");\n            }\n        } else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {\n            throw new TypeError(\"keyData: Is not ArrayBufferView or ArrayBuffer\");\n        }\n    }\n    prepareData(data) {\n        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n    }\n}\nclass AesProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        switch(algorithm.length){\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new TypeError(\"length: Must be 128, 192, or 256\");\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\nclass AesCbcProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CBC\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n    }\n}\nclass AesCmacProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CMAC\";\n        this.usages = [\n            \"sign\",\n            \"verify\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\nclass AesCtrProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CTR\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"counter\");\n        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {\n            throw new TypeError(\"counter: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.counter.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\nclass AesEcbProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-ECB\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n}\nclass AesGcmProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-GCM\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength < 1) {\n            throw new OperationError(\"iv: Must have length more than 0 and less than 2^64 - 1\");\n        }\n        if (!(\"tagLength\" in algorithm)) {\n            algorithm.tagLength = 128;\n        }\n        switch(algorithm.tagLength){\n            case 32:\n            case 64:\n            case 96:\n            case 104:\n            case 112:\n            case 120:\n            case 128:\n                break;\n            default:\n                throw new OperationError(\"tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128\");\n        }\n    }\n}\nclass AesKwProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-KW\";\n        this.usages = [\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n}\nclass DesProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        if (this.ivSize) {\n            this.checkRequiredProperty(algorithm, \"iv\");\n            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n                throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n            }\n            if (algorithm.iv.byteLength !== this.ivSize) {\n                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);\n            }\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        if (algorithm.length !== this.keySizeBits) {\n            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\nclass RsaProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {\n            throw new TypeError(\"The modulus length must be a multiple of 8 bits and >= 256 and <= 16384\");\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nclass RsaSsaProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSASSA-PKCS1-v1_5\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n    }\n}\nclass RsaPssProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSA-PSS\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"saltLength\");\n        if (typeof algorithm.saltLength !== \"number\") {\n            throw new TypeError(\"saltLength: Is not a Number\");\n        }\n        if (algorithm.saltLength < 0) {\n            throw new RangeError(\"saltLength: Must be positive number\");\n        }\n    }\n}\nclass RsaOaepProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSA-OAEP\";\n        this.usages = {\n            privateKey: [\n                \"decrypt\",\n                \"unwrapKey\"\n            ],\n            publicKey: [\n                \"encrypt\",\n                \"wrapKey\"\n            ]\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {\n            throw new TypeError(\"label: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n}\nclass EllipticProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"namedCurve\");\n        this.checkNamedCurve(algorithm.namedCurve);\n    }\n    checkNamedCurve(namedCurve) {\n        for (const item of this.namedCurves){\n            if (item.toLowerCase() === namedCurve.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(\", \")}`);\n    }\n}\nclass EcdsaProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDSA\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n        this.namedCurves = [\n            \"P-256\",\n            \"P-384\",\n            \"P-521\",\n            \"K-256\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nconst KEY_TYPES = [\n    \"secret\",\n    \"private\",\n    \"public\"\n];\nclass CryptoKey {\n    static create(algorithm, type, extractable, usages) {\n        const key = new this();\n        key.algorithm = algorithm;\n        key.type = type;\n        key.extractable = extractable;\n        key.usages = usages;\n        return key;\n    }\n    static isKeyType(data) {\n        return KEY_TYPES.indexOf(data) !== -1;\n    }\n    get [Symbol.toStringTag]() {\n        return \"CryptoKey\";\n    }\n}\nclass EcdhProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDH\";\n        this.usages = {\n            privateKey: [\n                \"deriveBits\",\n                \"deriveKey\"\n            ],\n            publicKey: []\n        };\n        this.namedCurves = [\n            \"P-256\",\n            \"P-384\",\n            \"P-521\",\n            \"K-256\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"public\");\n        if (!(algorithm.public instanceof CryptoKey)) {\n            throw new TypeError(\"public: Is not a CryptoKey\");\n        }\n        if (algorithm.public.type !== \"public\") {\n            throw new OperationError(\"public: Is not a public key\");\n        }\n        if (algorithm.public.algorithm.name !== this.name) {\n            throw new OperationError(`public: Is not ${this.name} key`);\n        }\n    }\n}\nclass EcdhEsProvider extends EcdhProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDH-ES\";\n        this.namedCurves = [\n            \"X25519\",\n            \"X448\"\n        ];\n    }\n}\nclass EdDsaProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"EdDSA\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n        this.namedCurves = [\n            \"Ed25519\",\n            \"Ed448\"\n        ];\n    }\n}\nlet ObjectIdentifier = class ObjectIdentifier {\n    constructor(value){\n        if (value) {\n            this.value = value;\n        }\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier\n    })\n], ObjectIdentifier.prototype, \"value\", void 0);\nObjectIdentifier = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], ObjectIdentifier);\nclass AlgorithmIdentifier {\n    constructor(params){\n        Object.assign(this, params);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier\n    })\n], AlgorithmIdentifier.prototype, \"algorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], AlgorithmIdentifier.prototype, \"parameters\", void 0);\nclass PrivateKeyInfo {\n    constructor(){\n        this.version = 0;\n        this.privateKeyAlgorithm = new AlgorithmIdentifier();\n        this.privateKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer\n    })\n], PrivateKeyInfo.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: AlgorithmIdentifier\n    })\n], PrivateKeyInfo.prototype, \"privateKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], PrivateKeyInfo.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], PrivateKeyInfo.prototype, \"attributes\", void 0);\nclass PublicKeyInfo {\n    constructor(){\n        this.publicKeyAlgorithm = new AlgorithmIdentifier();\n        this.publicKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: AlgorithmIdentifier\n    })\n], PublicKeyInfo.prototype, \"publicKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.BitString\n    })\n], PublicKeyInfo.prototype, \"publicKey\", void 0);\nconst JsonBase64UrlArrayBufferConverter = {\n    fromJSON: (value)=>pvtsutils.Convert.FromBase64Url(value),\n    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(new Uint8Array(value))\n};\nconst AsnIntegerArrayBufferConverter = {\n    fromASN: (value)=>{\n        const valueHex = value.valueBlock.valueHex;\n        return !new Uint8Array(valueHex)[0] ? value.valueBlock.valueHex.slice(1) : value.valueBlock.valueHex;\n    },\n    toASN: (value)=>{\n        const valueHex = new Uint8Array(value)[0] > 127 ? pvtsutils.combine(new Uint8Array([\n            0\n        ]).buffer, value) : value;\n        return new asn1__namespace.Integer({\n            valueHex\n        });\n    }\n};\nvar index$3 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,\n    JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter\n});\nclass RsaPrivateKey {\n    constructor(){\n        this.version = 0;\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n        this.privateExponent = new ArrayBuffer(0);\n        this.prime1 = new ArrayBuffer(0);\n        this.prime2 = new ArrayBuffer(0);\n        this.exponent1 = new ArrayBuffer(0);\n        this.exponent2 = new ArrayBuffer(0);\n        this.coefficient = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: asn1Schema.AsnIntegerConverter\n    })\n], RsaPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"n\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"e\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"publicExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"d\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"privateExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"p\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"prime1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"q\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"prime2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"dp\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"exponent1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"dq\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"exponent2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"qi\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"coefficient\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], RsaPrivateKey.prototype, \"otherPrimeInfos\", void 0);\nclass RsaPublicKey {\n    constructor(){\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"n\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPublicKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"e\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPublicKey.prototype, \"publicExponent\", void 0);\nlet EcPublicKey = class EcPublicKey {\n    constructor(value){\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        let bytes = new Uint8Array(this.value);\n        if (bytes[0] !== 0x04) {\n            throw new CryptoError(\"Wrong ECPoint. Current version supports only Uncompressed (0x04) point\");\n        }\n        bytes = new Uint8Array(this.value.slice(1));\n        const size = bytes.length / 2;\n        const offset = 0;\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),\n            y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        if (!(\"y\" in json)) {\n            throw new Error(\"y: Missing required property\");\n        }\n        const x = pvtsutils.Convert.FromBase64Url(json.x);\n        const y = pvtsutils.Convert.FromBase64Url(json.y);\n        const value = pvtsutils.combine(new Uint8Array([\n            0x04\n        ]).buffer, x, y);\n        this.value = new Uint8Array(value).buffer;\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EcPublicKey.prototype, \"value\", void 0);\nEcPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EcPublicKey);\nclass EcPrivateKey {\n    constructor(){\n        this.version = 1;\n        this.privateKey = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!(\"d\" in json)) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);\n        if (\"x\" in json) {\n            const publicKey = new EcPublicKey();\n            publicKey.fromJSON(json);\n            const asn = asn1Schema.AsnSerializer.toASN(publicKey);\n            if (\"valueHex\" in asn.valueBlock) {\n                this.publicKey = asn.valueBlock.valueHex;\n            }\n        }\n        return this;\n    }\n    toJSON() {\n        const jwk = {};\n        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);\n        if (this.publicKey) {\n            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());\n        }\n        return jwk;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: asn1Schema.AsnIntegerConverter\n    })\n], EcPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EcPrivateKey.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 0,\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], EcPrivateKey.prototype, \"parameters\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 1,\n        type: asn1Schema.AsnPropTypes.BitString,\n        optional: true\n    })\n], EcPrivateKey.prototype, \"publicKey\", void 0);\nconst AsnIntegerWithoutPaddingConverter = {\n    fromASN: (value)=>{\n        const bytes = new Uint8Array(value.valueBlock.valueHex);\n        return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;\n    },\n    toASN: (value)=>{\n        const bytes = new Uint8Array(value);\n        if (bytes[0] > 127) {\n            const newValue = new Uint8Array(bytes.length + 1);\n            newValue.set(bytes, 1);\n            return new asn1__namespace.Integer({\n                valueHex: newValue.buffer\n            });\n        }\n        return new asn1__namespace.Integer({\n            valueHex: value\n        });\n    }\n};\nvar index$2 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter\n});\nclass EcUtils {\n    static decodePoint(data, pointSize) {\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length === 0 || view[0] !== 4) {\n            throw new Error(\"Only uncompressed point format supported\");\n        }\n        const n = (view.length - 1) / 2;\n        if (n !== Math.ceil(pointSize / 8)) {\n            throw new Error(\"Point does not match field size\");\n        }\n        const xb = view.slice(1, n + 1);\n        const yb = view.slice(n + 1, n + 1 + n);\n        return {\n            x: xb,\n            y: yb\n        };\n    }\n    static encodePoint(point, pointSize) {\n        const size = Math.ceil(pointSize / 8);\n        if (point.x.byteLength !== size || point.y.byteLength !== size) {\n            throw new Error(\"X,Y coordinates don't match point size criteria\");\n        }\n        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);\n        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);\n        const res = new Uint8Array(size * 2 + 1);\n        res[0] = 4;\n        res.set(x, 1);\n        res.set(y, size + 1);\n        return res;\n    }\n    static getSize(pointSize) {\n        return Math.ceil(pointSize / 8);\n    }\n    static encodeSignature(signature, pointSize) {\n        const size = this.getSize(pointSize);\n        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);\n        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);\n        const res = new Uint8Array(size * 2);\n        res.set(this.padStart(r, size));\n        res.set(this.padStart(s, size), size);\n        return res;\n    }\n    static decodeSignature(data, pointSize) {\n        const size = this.getSize(pointSize);\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length !== size * 2) {\n            throw new Error(\"Incorrect size of the signature\");\n        }\n        const r = view.slice(0, size);\n        const s = view.slice(size);\n        return {\n            r: this.trimStart(r),\n            s: this.trimStart(s)\n        };\n    }\n    static trimStart(data) {\n        let i = 0;\n        while(i < data.length - 1 && data[i] === 0){\n            i++;\n        }\n        if (i === 0) {\n            return data;\n        }\n        return data.slice(i, data.length);\n    }\n    static padStart(data, size) {\n        if (size === data.length) {\n            return data;\n        }\n        const res = new Uint8Array(size);\n        res.set(data, size - data.length);\n        return res;\n    }\n}\nclass EcDsaSignature {\n    constructor(){\n        this.r = new ArrayBuffer(0);\n        this.s = new ArrayBuffer(0);\n    }\n    static fromWebCryptoSignature(value) {\n        const pointSize = value.byteLength / 2;\n        const point = EcUtils.decodeSignature(value, pointSize * 8);\n        const ecSignature = new EcDsaSignature();\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);\n        return ecSignature;\n    }\n    toWebCryptoSignature(pointSize) {\n        pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;\n        const signature = EcUtils.encodeSignature(this, pointSize);\n        return signature.buffer;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerWithoutPaddingConverter\n    })\n], EcDsaSignature.prototype, \"r\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerWithoutPaddingConverter\n    })\n], EcDsaSignature.prototype, \"s\", void 0);\nclass OneAsymmetricKey extends PrivateKeyInfo {\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 1,\n        implicit: true,\n        type: asn1Schema.AsnPropTypes.BitString,\n        optional: true\n    })\n], OneAsymmetricKey.prototype, \"publicKey\", void 0);\nlet EdPrivateKey = class EdPrivateKey {\n    constructor(){\n        this.value = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!json.d) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.d);\n        return this;\n    }\n    toJSON() {\n        const jwk = {\n            d: pvtsutils.Convert.ToBase64Url(this.value)\n        };\n        return jwk;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EdPrivateKey.prototype, \"value\", void 0);\nEdPrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EdPrivateKey);\nlet EdPublicKey = class EdPublicKey {\n    constructor(value){\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(this.value)\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.x);\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.BitString\n    })\n], EdPublicKey.prototype, \"value\", void 0);\nEdPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EdPublicKey);\nlet CurvePrivateKey = class CurvePrivateKey {\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    }),\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String,\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], CurvePrivateKey.prototype, \"d\", void 0);\nCurvePrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], CurvePrivateKey);\nconst idSecp256r1 = \"1.2.840.10045.3.1.7\";\nconst idEllipticCurve = \"1.3.132.0\";\nconst idSecp384r1 = `${idEllipticCurve}.34`;\nconst idSecp521r1 = `${idEllipticCurve}.35`;\nconst idSecp256k1 = `${idEllipticCurve}.10`;\nconst idVersionOne = \"1.3.36.3.3.2.8.1.1\";\nconst idBrainpoolP160r1 = `${idVersionOne}.1`;\nconst idBrainpoolP160t1 = `${idVersionOne}.2`;\nconst idBrainpoolP192r1 = `${idVersionOne}.3`;\nconst idBrainpoolP192t1 = `${idVersionOne}.4`;\nconst idBrainpoolP224r1 = `${idVersionOne}.5`;\nconst idBrainpoolP224t1 = `${idVersionOne}.6`;\nconst idBrainpoolP256r1 = `${idVersionOne}.7`;\nconst idBrainpoolP256t1 = `${idVersionOne}.8`;\nconst idBrainpoolP320r1 = `${idVersionOne}.9`;\nconst idBrainpoolP320t1 = `${idVersionOne}.10`;\nconst idBrainpoolP384r1 = `${idVersionOne}.11`;\nconst idBrainpoolP384t1 = `${idVersionOne}.12`;\nconst idBrainpoolP512r1 = `${idVersionOne}.13`;\nconst idBrainpoolP512t1 = `${idVersionOne}.14`;\nconst idX25519 = \"1.3.101.110\";\nconst idX448 = \"1.3.101.111\";\nconst idEd25519 = \"1.3.101.112\";\nconst idEd448 = \"1.3.101.113\";\nvar index$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AlgorithmIdentifier: AlgorithmIdentifier,\n    get CurvePrivateKey () {\n        return CurvePrivateKey;\n    },\n    EcDsaSignature: EcDsaSignature,\n    EcPrivateKey: EcPrivateKey,\n    get EcPublicKey () {\n        return EcPublicKey;\n    },\n    get EdPrivateKey () {\n        return EdPrivateKey;\n    },\n    get EdPublicKey () {\n        return EdPublicKey;\n    },\n    get ObjectIdentifier () {\n        return ObjectIdentifier;\n    },\n    OneAsymmetricKey: OneAsymmetricKey,\n    PrivateKeyInfo: PrivateKeyInfo,\n    PublicKeyInfo: PublicKeyInfo,\n    RsaPrivateKey: RsaPrivateKey,\n    RsaPublicKey: RsaPublicKey,\n    converters: index$2,\n    idBrainpoolP160r1: idBrainpoolP160r1,\n    idBrainpoolP160t1: idBrainpoolP160t1,\n    idBrainpoolP192r1: idBrainpoolP192r1,\n    idBrainpoolP192t1: idBrainpoolP192t1,\n    idBrainpoolP224r1: idBrainpoolP224r1,\n    idBrainpoolP224t1: idBrainpoolP224t1,\n    idBrainpoolP256r1: idBrainpoolP256r1,\n    idBrainpoolP256t1: idBrainpoolP256t1,\n    idBrainpoolP320r1: idBrainpoolP320r1,\n    idBrainpoolP320t1: idBrainpoolP320t1,\n    idBrainpoolP384r1: idBrainpoolP384r1,\n    idBrainpoolP384t1: idBrainpoolP384t1,\n    idBrainpoolP512r1: idBrainpoolP512r1,\n    idBrainpoolP512t1: idBrainpoolP512t1,\n    idEd25519: idEd25519,\n    idEd448: idEd448,\n    idEllipticCurve: idEllipticCurve,\n    idSecp256k1: idSecp256k1,\n    idSecp256r1: idSecp256r1,\n    idSecp384r1: idSecp384r1,\n    idSecp521r1: idSecp521r1,\n    idVersionOne: idVersionOne,\n    idX25519: idX25519,\n    idX448: idX448\n});\nclass EcCurves {\n    constructor(){}\n    static register(item) {\n        const oid = new ObjectIdentifier();\n        oid.value = item.id;\n        const raw = asn1Schema.AsnConvert.serialize(oid);\n        this.items.push({\n            ...item,\n            raw\n        });\n        this.names.push(item.name);\n    }\n    static find(nameOrId) {\n        nameOrId = nameOrId.toUpperCase();\n        for (const item of this.items){\n            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {\n                return item;\n            }\n        }\n        return null;\n    }\n    static get(nameOrId) {\n        const res = this.find(nameOrId);\n        if (!res) {\n            throw new Error(`Unsupported EC named curve '${nameOrId}'`);\n        }\n        return res;\n    }\n}\nEcCurves.items = [];\nEcCurves.names = [];\nEcCurves.register({\n    name: \"P-256\",\n    id: idSecp256r1,\n    size: 256\n});\nEcCurves.register({\n    name: \"P-384\",\n    id: idSecp384r1,\n    size: 384\n});\nEcCurves.register({\n    name: \"P-521\",\n    id: idSecp521r1,\n    size: 521\n});\nEcCurves.register({\n    name: \"K-256\",\n    id: idSecp256k1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP160r1\",\n    id: idBrainpoolP160r1,\n    size: 160\n});\nEcCurves.register({\n    name: \"brainpoolP160t1\",\n    id: idBrainpoolP160t1,\n    size: 160\n});\nEcCurves.register({\n    name: \"brainpoolP192r1\",\n    id: idBrainpoolP192r1,\n    size: 192\n});\nEcCurves.register({\n    name: \"brainpoolP192t1\",\n    id: idBrainpoolP192t1,\n    size: 192\n});\nEcCurves.register({\n    name: \"brainpoolP224r1\",\n    id: idBrainpoolP224r1,\n    size: 224\n});\nEcCurves.register({\n    name: \"brainpoolP224t1\",\n    id: idBrainpoolP224t1,\n    size: 224\n});\nEcCurves.register({\n    name: \"brainpoolP256r1\",\n    id: idBrainpoolP256r1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP256t1\",\n    id: idBrainpoolP256t1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP320r1\",\n    id: idBrainpoolP320r1,\n    size: 320\n});\nEcCurves.register({\n    name: \"brainpoolP320t1\",\n    id: idBrainpoolP320t1,\n    size: 320\n});\nEcCurves.register({\n    name: \"brainpoolP384r1\",\n    id: idBrainpoolP384r1,\n    size: 384\n});\nEcCurves.register({\n    name: \"brainpoolP384t1\",\n    id: idBrainpoolP384t1,\n    size: 384\n});\nEcCurves.register({\n    name: \"brainpoolP512r1\",\n    id: idBrainpoolP512r1,\n    size: 512\n});\nEcCurves.register({\n    name: \"brainpoolP512t1\",\n    id: idBrainpoolP512t1,\n    size: 512\n});\nclass HmacProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"HMAC\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"sign\",\n            \"verify\"\n        ];\n    }\n    getDefaultLength(algName) {\n        switch(algName.toUpperCase()){\n            case \"SHA-1\":\n            case \"SHA-256\":\n            case \"SHA-384\":\n            case \"SHA-512\":\n                return 512;\n            default:\n                throw new Error(`Unknown algorithm name '${algName}'`);\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        if (\"length\" in algorithm) {\n            if (typeof algorithm.length !== \"number\") {\n                throw new TypeError(\"length: Is not a Number\");\n            }\n            if (algorithm.length < 1) {\n                throw new RangeError(\"length: Number is out of range\");\n            }\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nclass Pbkdf2Provider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"PBKDF2\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"deriveBits\",\n            \"deriveKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"iterations\");\n        if (typeof algorithm.iterations !== \"number\") {\n            throw new TypeError(\"iterations: Is not a Number\");\n        }\n        if (algorithm.iterations < 1) {\n            throw new TypeError(\"iterations: Is less than 1\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\nclass HkdfProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"HKDF\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"deriveKey\",\n            \"deriveBits\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"info\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\nclass ShakeProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.usages = [];\n        this.defaultLength = 0;\n    }\n    digest(...args) {\n        args[0] = {\n            length: this.defaultLength,\n            ...args[0]\n        };\n        return super.digest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        super.checkDigest(algorithm, data);\n        const length = algorithm.length || 0;\n        if (typeof length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (length < 0) {\n            throw new TypeError(\"length: Is negative\");\n        }\n    }\n}\nclass Shake128Provider extends ShakeProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"shake128\";\n        this.defaultLength = 16;\n    }\n}\nclass Shake256Provider extends ShakeProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"shake256\";\n        this.defaultLength = 32;\n    }\n}\nclass Crypto {\n    get [Symbol.toStringTag]() {\n        return \"Crypto\";\n    }\n    randomUUID() {\n        const b = this.getRandomValues(new Uint8Array(16));\n        b[6] = b[6] & 0x0f | 0x40;\n        b[8] = b[8] & 0x3f | 0x80;\n        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();\n        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n    }\n}\nclass ProviderStorage {\n    constructor(){\n        this.items = {};\n    }\n    get(algorithmName) {\n        return this.items[algorithmName.toLowerCase()] || null;\n    }\n    set(provider) {\n        this.items[provider.name.toLowerCase()] = provider;\n    }\n    removeAt(algorithmName) {\n        const provider = this.get(algorithmName.toLowerCase());\n        if (provider) {\n            delete this.items[algorithmName];\n        }\n        return provider;\n    }\n    has(name) {\n        return !!this.get(name);\n    }\n    get length() {\n        return Object.keys(this.items).length;\n    }\n    get algorithms() {\n        const algorithms = [];\n        for(const key in this.items){\n            const provider = this.items[key];\n            algorithms.push(provider.name);\n        }\n        return algorithms.sort();\n    }\n}\nclass SubtleCrypto {\n    constructor(){\n        this.providers = new ProviderStorage();\n    }\n    static isHashedAlgorithm(data) {\n        return data && typeof data === \"object\" && \"name\" in data && \"hash\" in data ? true : false;\n    }\n    get [Symbol.toStringTag]() {\n        return \"SubtleCrypto\";\n    }\n    async digest(...args) {\n        this.checkRequiredArguments(args, 2, \"digest\");\n        const [algorithm, data, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);\n        return result;\n    }\n    async generateKey(...args) {\n        this.checkRequiredArguments(args, 3, \"generateKey\");\n        const [algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.generateKey({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, extractable, keyUsages, ...params);\n        return result;\n    }\n    async sign(...args) {\n        this.checkRequiredArguments(args, 3, \"sign\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.sign({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, ...params);\n        return result;\n    }\n    async verify(...args) {\n        this.checkRequiredArguments(args, 4, \"verify\");\n        const [algorithm, key, signature, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.verify({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedSignature, preparedData, ...params);\n        return result;\n    }\n    async encrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"encrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.encrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async decrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"decrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.decrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async deriveBits(...args) {\n        this.checkRequiredArguments(args, 3, \"deriveBits\");\n        const [algorithm, baseKey, length, ...params] = args;\n        this.checkCryptoKey(baseKey);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.deriveBits({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, baseKey, length, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async deriveKey(...args) {\n        this.checkRequiredArguments(args, 5, \"deriveKey\");\n        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;\n        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);\n        const importProvider = this.getProvider(preparedDerivedKeyType.name);\n        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        provider.checkCryptoKey(baseKey, \"deriveKey\");\n        const derivedBits = await provider.deriveBits({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, baseKey, derivedKeyType.length || 512, {\n            keyUsage: false\n        }, ...params);\n        return this.importKey(\"raw\", derivedBits, derivedKeyType, extractable, keyUsages, ...params);\n    }\n    async exportKey(...args) {\n        this.checkRequiredArguments(args, 2, \"exportKey\");\n        const [format, key, ...params] = args;\n        this.checkCryptoKey(key);\n        const provider = this.getProvider(key.algorithm.name);\n        const result = await provider.exportKey(format, key, ...params);\n        return result;\n    }\n    async importKey(...args) {\n        this.checkRequiredArguments(args, 5, \"importKey\");\n        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        if ([\n            \"pkcs8\",\n            \"spki\",\n            \"raw\"\n        ].indexOf(format) !== -1) {\n            const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n            return provider.importKey(format, preparedData, {\n                ...preparedAlgorithm,\n                name: provider.name\n            }, extractable, keyUsages, ...params);\n        } else {\n            if (!keyData.kty) {\n                throw new TypeError(\"keyData: Is not JSON\");\n            }\n        }\n        return provider.importKey(format, keyData, {\n            ...preparedAlgorithm,\n            name: provider.name\n        }, extractable, keyUsages, ...params);\n    }\n    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {\n        let keyData = await this.exportKey(format, key, ...args);\n        if (format === \"jwk\") {\n            const json = JSON.stringify(keyData);\n            keyData = pvtsutils.Convert.FromUtf8String(json);\n        }\n        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        return provider.encrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, wrappingKey, preparedData, {\n            keyUsage: false\n        }, ...args);\n    }\n    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {\n        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        let keyData = await provider.decrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, unwrappingKey, preparedData, {\n            keyUsage: false\n        }, ...args);\n        if (format === \"jwk\") {\n            try {\n                keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));\n            } catch (e) {\n                const error = new TypeError(\"wrappedKey: Is not a JSON\");\n                error.internal = e;\n                throw error;\n            }\n        }\n        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);\n    }\n    checkRequiredArguments(args, size, methodName) {\n        if (args.length < size) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);\n        }\n    }\n    prepareAlgorithm(algorithm) {\n        if (typeof algorithm === \"string\") {\n            return {\n                name: algorithm\n            };\n        }\n        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {\n            const preparedAlgorithm = {\n                ...algorithm\n            };\n            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);\n            return preparedAlgorithm;\n        }\n        return {\n            ...algorithm\n        };\n    }\n    getProvider(name) {\n        const provider = this.providers.get(name);\n        if (!provider) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n        return provider;\n    }\n    checkCryptoKey(key) {\n        if (!(key instanceof CryptoKey)) {\n            throw new TypeError(`Key is not of type 'CryptoKey'`);\n        }\n    }\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    converters: index$3\n});\nconst REQUIRED_FIELDS = [\n    \"crv\",\n    \"e\",\n    \"k\",\n    \"kty\",\n    \"n\",\n    \"x\",\n    \"y\"\n];\nclass JwkUtils {\n    static async thumbprint(hash, jwk, crypto) {\n        const data = this.format(jwk, true);\n        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));\n    }\n    static format(jwk, remove = false) {\n        let res = Object.entries(jwk);\n        if (remove) {\n            res = res.filter((o)=>REQUIRED_FIELDS.includes(o[0]));\n        }\n        res = res.sort(([keyA], [keyB])=>keyA > keyB ? 1 : keyA < keyB ? -1 : 0);\n        return Object.fromEntries(res);\n    }\n}\nObject.defineProperty(exports, \"BufferSourceConverter\", ({\n    enumerable: true,\n    get: function() {\n        return pvtsutils.BufferSourceConverter;\n    }\n}));\nexports.AesCbcProvider = AesCbcProvider;\nexports.AesCmacProvider = AesCmacProvider;\nexports.AesCtrProvider = AesCtrProvider;\nexports.AesEcbProvider = AesEcbProvider;\nexports.AesGcmProvider = AesGcmProvider;\nexports.AesKwProvider = AesKwProvider;\nexports.AesProvider = AesProvider;\nexports.AlgorithmError = AlgorithmError;\nexports.Crypto = Crypto;\nexports.CryptoError = CryptoError;\nexports.CryptoKey = CryptoKey;\nexports.DesProvider = DesProvider;\nexports.EcCurves = EcCurves;\nexports.EcUtils = EcUtils;\nexports.EcdhEsProvider = EcdhEsProvider;\nexports.EcdhProvider = EcdhProvider;\nexports.EcdsaProvider = EcdsaProvider;\nexports.EdDsaProvider = EdDsaProvider;\nexports.EllipticProvider = EllipticProvider;\nexports.HkdfProvider = HkdfProvider;\nexports.HmacProvider = HmacProvider;\nexports.JwkUtils = JwkUtils;\nexports.OperationError = OperationError;\nexports.Pbkdf2Provider = Pbkdf2Provider;\nexports.PemConverter = PemConverter;\nexports.ProviderCrypto = ProviderCrypto;\nexports.ProviderStorage = ProviderStorage;\nexports.RequiredPropertyError = RequiredPropertyError;\nexports.RsaOaepProvider = RsaOaepProvider;\nexports.RsaProvider = RsaProvider;\nexports.RsaPssProvider = RsaPssProvider;\nexports.RsaSsaProvider = RsaSsaProvider;\nexports.Shake128Provider = Shake128Provider;\nexports.Shake256Provider = Shake256Provider;\nexports.ShakeProvider = ShakeProvider;\nexports.SubtleCrypto = SubtleCrypto;\nexports.UnsupportedOperationError = UnsupportedOperationError;\nexports.asn1 = index$1;\nexports.isJWK = isJWK;\nexports.json = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYmNyeXB0by1jb3JlL2J1aWxkL3dlYmNyeXB0by1jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLEdBRUE7QUFFQSxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUN4QixJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUN6QixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxhQUFhSCxtQkFBT0EsQ0FBQztBQUN6QixJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQztBQUVuQixTQUFTSyx5QkFBeUJDLENBQUM7SUFDakMsSUFBSUMsSUFBSUMsT0FBT0MsTUFBTSxDQUFDO0lBQ3RCLElBQUlILEdBQUc7UUFDTEUsT0FBT0UsSUFBSSxDQUFDSixHQUFHSyxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUNoQyxJQUFJQSxNQUFNLFdBQVc7Z0JBQ25CLElBQUlDLElBQUlMLE9BQU9NLHdCQUF3QixDQUFDUixHQUFHTTtnQkFDM0NKLE9BQU9PLGNBQWMsQ0FBQ1IsR0FBR0ssR0FBR0MsRUFBRUcsR0FBRyxHQUFHSCxJQUFJO29CQUN0Q0ksWUFBWTtvQkFDWkQsS0FBSzt3QkFBYyxPQUFPVixDQUFDLENBQUNNLEVBQUU7b0JBQUU7Z0JBQ2xDO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FMLEVBQUVXLE9BQU8sR0FBR1o7SUFDWixPQUFPRSxPQUFPVyxNQUFNLENBQUNaO0FBQ3ZCO0FBRUEsSUFBSWEsa0JBQWtCLFdBQVcsR0FBRWYseUJBQXlCRDtBQUU1RCxNQUFNaUIsb0JBQW9CQztBQUMxQjtBQUVBLE1BQU1DLHVCQUF1QkY7QUFDN0I7QUFFQSxNQUFNRyxrQ0FBa0NIO0lBQ3BDSSxZQUFZQyxVQUFVLENBQUU7UUFDcEIsS0FBSyxDQUFDLENBQUMsdUJBQXVCLEVBQUVBLGFBQWEsQ0FBQyxFQUFFQSxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDdkU7QUFDSjtBQUVBLE1BQU1DLHVCQUF1Qk47QUFDN0I7QUFFQSxN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LGdCQUFnQixHQUFHcEY7QUFDbkJvRixlQUFlLEdBQUc1STtBQUNsQjRJLHNCQUFzQixHQUFHM007QUFDekIyTSxvQkFBb0IsR0FBRzdNO0FBQ3ZCNk0scUJBQXFCLEdBQUdwTjtBQUN4Qm9OLHFCQUFxQixHQUFHMU07QUFDeEIwTSx3QkFBd0IsR0FBR3hOO0FBQzNCd04sb0JBQW9CLEdBQUdsRTtBQUN2QmtFLG9CQUFvQixHQUFHekU7QUFDdkJ5RSxnQkFBZ0IsR0FBR2I7QUFDbkJhLHNCQUFzQixHQUFHL1Y7QUFDekIrVixzQkFBc0IsR0FBR3RFO0FBQ3pCc0Usb0JBQW9CLEdBQUc1VjtBQUN2QjRWLHNCQUFzQixHQUFHdlQ7QUFDekJ1VCx1QkFBdUIsR0FBR3JEO0FBQzFCcUQsNkJBQTZCLEdBQUc5VjtBQUNoQzhWLHVCQUF1QixHQUFHMU47QUFDMUIwTixtQkFBbUIsR0FBR2xPO0FBQ3RCa08sc0JBQXNCLEdBQUc3TjtBQUN6QjZOLHNCQUFzQixHQUFHOU47QUFDekI4Tix3QkFBd0IsR0FBRzlEO0FBQzNCOEQsd0JBQXdCLEdBQUc3RDtBQUMzQjZELHFCQUFxQixHQUFHaEU7QUFDeEJnRSxvQkFBb0IsR0FBRzlDO0FBQ3ZCOEMsaUNBQWlDLEdBQUdsVztBQUNwQ2tXLFlBQVksR0FBR3RGO0FBQ2ZzRixhQUFhLEdBQUd4VDtBQUNoQndULFlBQVksR0FBR2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL3dlYmNyeXB0by1jb3JlL2J1aWxkL3dlYmNyeXB0by1jb3JlLmpzPzFhYzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gQ29weXJpZ2h0IChjKSBQZWN1bGlhciBWZW50dXJlcywgTExDXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBhc24xU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2FzbjEtc2NoZW1hJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzb25TY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvanNvbi1zY2hlbWEnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMWpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGFzbjFfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoYXNuMSk7XG5cbmNsYXNzIENyeXB0b0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBBbGdvcml0aG1FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbn1cblxuY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7bWV0aG9kTmFtZSA/IGAke21ldGhvZE5hbWV9YCA6IFwiXCJ9YCk7XG4gICAgfVxufVxuXG5jbGFzcyBPcGVyYXRpb25FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbn1cblxuY2xhc3MgUmVxdWlyZWRQcm9wZXJ0eUVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BOYW1lKSB7XG4gICAgICAgIHN1cGVyKGAke3Byb3BOYW1lfTogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eWApO1xuICAgIH1cbn1cblxuY2xhc3MgUGVtQ29udmVydGVyIHtcbiAgICBzdGF0aWMgdG9BcnJheUJ1ZmZlcihwZW0pIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gcGVtXG4gICAgICAgICAgICAucmVwbGFjZSgvLXs1fShCRUdJTnxFTkQpIC4qLXs1fS9nLCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCJcXHJcIiwgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKFwiXFxuXCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NChiYXNlNjQpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9VaW50OEFycmF5KHBlbSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMudG9BcnJheUJ1ZmZlcihwZW0pO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlclNvdXJjZShidWZmZXIsIHRhZykge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChidWZmZXIpO1xuICAgICAgICBsZXQgc2xpY2VkO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc2xpY2VkID0gYmFzZTY0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ID0gb2Zmc2V0ICsgNjQpO1xuICAgICAgICAgICAgaWYgKHNsaWNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goc2xpY2VkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYC0tLS0tQkVHSU4gJHt1cHBlckNhc2VUYWd9LS0tLS1cXG4ke3Jvd3Muam9pbihcIlxcblwiKX1cXG4tLS0tLUVORCAke3VwcGVyQ2FzZVRhZ30tLS0tLWA7XG4gICAgfVxuICAgIHN0YXRpYyBpc1BFTShkYXRhKSB7XG4gICAgICAgIHJldHVybiAvLS0tLS1CRUdJTiAuKy0tLS0tW0EtWmEtejAtOStcXC9cXCtcXD1cXHNcXG5dKy0tLS0tRU5EIC4rLS0tLS0vaS50ZXN0KGRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VGFnTmFtZShwZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUEVNKHBlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBwYXJhbWV0ZXIuIEluY29taW5nIGRhdGEgaXMgbm90IHJpZ2h0IFBFTVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSAvLS0tLS1CRUdJTiAoLispLS0tLS0vLmV4ZWMocGVtKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGFnIGZyb20gUEVNXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNbMV07XG4gICAgfVxuICAgIHN0YXRpYyBoYXNUYWdOYW1lKHBlbSwgdGFnTmFtZSkge1xuICAgICAgICBjb25zdCB0YWcgPSB0aGlzLmdldFRhZ05hbWUocGVtKTtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NlcnRpZmljYXRlKHBlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWdOYW1lKHBlbSwgXCJjZXJ0aWZpY2F0ZVwiKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ2VydGlmaWNhdGVSZXF1ZXN0KHBlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWdOYW1lKHBlbSwgXCJjZXJ0aWZpY2F0ZSByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDUkwocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcIng1MDkgY3JsXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQdWJsaWNLZXkocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcInB1YmxpYyBrZXlcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0pXSyhkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwia3R5XCIgaW4gZGF0YTtcbn1cblxuY2xhc3MgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGFzeW5jIGRpZ2VzdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRGlnZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0RpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGlnZXN0XCIpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25HZW5lcmF0ZUtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIGlmICghKGtleVVzYWdlcyAmJiBrZXlVc2FnZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVXNhZ2VzIGNhbm5vdCBiZSBlbXB0eSB3aGVuIGNyZWF0aW5nIGEga2V5LmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbGxvd2VkVXNhZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnVzYWdlcykpIHtcbiAgICAgICAgICAgIGFsbG93ZWRVc2FnZXMgPSB0aGlzLnVzYWdlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbG93ZWRVc2FnZXMgPSB0aGlzLnVzYWdlcy5wcml2YXRlS2V5LmNvbmNhdCh0aGlzLnVzYWdlcy5wdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzLCBhbGxvd2VkVXNhZ2VzKTtcbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJnZW5lcmF0ZUtleVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vblNpZ24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBcInNpZ25cIik7XG4gICAgfVxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSwgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcInNpZ25cIik7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWZXJpZnkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uVmVyaWZ5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja1ZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIFwidmVyaWZ5XCIpO1xuICAgIH1cbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwidmVyaWZ5XCIpO1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0VuY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRW5jcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tFbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhLCBvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZW5jcnlwdFwiIDogdm9pZCAwKTtcbiAgICB9XG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZW5jcnlwdFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkRlY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSwgb3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIG9wdGlvbnMua2V5VXNhZ2UgPyBcImRlY3J5cHRcIiA6IHZvaWQgMCk7XG4gICAgfVxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSwgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImRlY3J5cHRcIik7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUJpdHMoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRGVyaXZlQml0cy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25EZXJpdmVCaXRzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0Rlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgsIG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoYmFzZUtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZGVyaXZlQml0c1wiIDogdm9pZCAwKTtcbiAgICAgICAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogSXMgbm90IG11bHRpcGxlIG9mIDhcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGVyaXZlQml0c1wiKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0V4cG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25FeHBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRXhwb3J0S2V5KGZvcm1hdCwga2V5LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBpZiAoIWtleS5leHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKFwia2V5OiBJcyBub3QgZXh0cmFjdGFibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJleHBvcnRLZXlcIik7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbXBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uSW1wb3J0S2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrS2V5Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlEYXRhKGZvcm1hdCwga2V5RGF0YSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy51c2FnZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrS2V5VXNhZ2VzKGtleVVzYWdlcywgdGhpcy51c2FnZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiaW1wb3J0S2V5XCIpO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKFwiVW5yZWNvZ25pemVkIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICB9XG4gICAgY2hlY2tLZXlVc2FnZXModXNhZ2VzLCBhbGxvd2VkKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXNhZ2Ugb2YgdXNhZ2VzKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZC5pbmRleE9mKHVzYWdlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGtleSB1c2luZyB0aGUgc3BlY2lmaWVkIGtleSB1c2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKGtleVVzYWdlICYmIGtleS51c2FnZXMuaW5kZXhPZihrZXlVc2FnZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvRXJyb3IoYGtleSBkb2VzIG5vdCBtYXRjaCB0aGF0IG9mIG9wZXJhdGlvbmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrUmVxdWlyZWRQcm9wZXJ0eShkYXRhLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkUHJvcGVydHlFcnJvcihwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobSwgaGFzaEFsZ29yaXRobXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGhhc2hBbGdvcml0aG1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSBhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgaGFzaDogTXVzdCBiZSBvbmUgb2YgJHtoYXNoQWxnb3JpdGhtcy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSkge1xuICAgIH1cbiAgICBjaGVja0tleUZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOlxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZvcm1hdDogSXMgaW52YWxpZCB2YWx1ZS4gTXVzdCBiZSAnandrJywgJ3JhdycsICdzcGtpJywgb3IgJ3BrY3M4J1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0tleURhdGEoZm9ybWF0LCBrZXlEYXRhKSB7XG4gICAgICAgIGlmICgha2V5RGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IENhbm5vdCBiZSBlbXB0eSBvbiBlbXB0eSBvbiBrZXkgaW1wb3J0aW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNKV0soa2V5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogSXMgbm90IEpzb25XZWJUb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShrZXlEYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IElzIG5vdCBBcnJheUJ1ZmZlclZpZXcgb3IgQXJyYXlCdWZmZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZURhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgIH1cbn1cblxuY2xhc3MgQWVzUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3Qgb2YgdHlwZSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgICAgIGNhc2UgMTkyOlxuICAgICAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IE11c3QgYmUgMTI4LCAxOTIsIG9yIDI1NlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Rlcml2ZWRLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pO1xuICAgIH1cbn1cblxuY2xhc3MgQWVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUNCQ1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdlwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLml2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5pdikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5pdi5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBNdXN0IGhhdmUgbGVuZ3RoIDE2IGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBZXNDbWFjUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUNNQUNcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJzaWduXCIsIFwidmVyaWZ5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJsZW5ndGg6IE11c3QgYmUgbW9yZSB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0N0clByb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1DVFJcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiY291bnRlclwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLmNvdW50ZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLmNvdW50ZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvdW50ZXI6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5jb3VudGVyLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IE11c3QgaGF2ZSBsZW5ndGggMTYgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJsZW5ndGg6IE11c3QgYmUgbW9yZSB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0VjYlByb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1FQ0JcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxufVxuXG5jbGFzcyBBZXNHY21Qcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtR0NNXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml2XCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uaXYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLml2KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLml2LmJ5dGVMZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJpdjogTXVzdCBoYXZlIGxlbmd0aCBtb3JlIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDJeNjQgLSAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKFwidGFnTGVuZ3RoXCIgaW4gYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgYWxnb3JpdGhtLnRhZ0xlbmd0aCA9IDEyODtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS50YWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgICAgIGNhc2UgMTA0OlxuICAgICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJ0YWdMZW5ndGg6IE11c3QgYmUgb25lIG9mIDMyLCA2NCwgOTYsIDEwNCwgMTEyLCAxMjAgb3IgMTI4XCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBZXNLd1Byb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1LV1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxufVxuXG5jbGFzcyBEZXNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAodGhpcy5pdlNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdlwiKTtcbiAgICAgICAgICAgIGlmICghKGFsZ29yaXRobS5pdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uaXYpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGdvcml0aG0uaXYuYnl0ZUxlbmd0aCAhPT0gdGhpcy5pdlNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpdjogTXVzdCBoYXZlIGxlbmd0aCAke3RoaXMuaXZTaXplfSBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJsZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IG9mIHR5cGUgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGVuZ3RoICE9PSB0aGlzLmtleVNpemVCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYGFsZ29yaXRobS5sZW5ndGg6IE11c3QgYmUgJHt0aGlzLmtleVNpemVCaXRzfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgfVxufVxuXG5jbGFzcyBSc2FQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwicHVibGljRXhwb25lbnRcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCAmJiBhbGdvcml0aG0ucHVibGljRXhwb25lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNaXNzaW5nIG9yIG5vdCBhIFVpbnQ4QXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChhbGdvcml0aG0ucHVibGljRXhwb25lbnQpO1xuICAgICAgICBpZiAoIShwdWJsaWNFeHBvbmVudCA9PT0gXCJBdz09XCIgfHwgcHVibGljRXhwb25lbnQgPT09IFwiQVFBQlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNdXN0IGJlIFszXSBvciBbMSwwLDFdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJtb2R1bHVzTGVuZ3RoXCIpO1xuICAgICAgICBpZiAoYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggJSA4XG4gICAgICAgICAgICB8fCBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA8IDI1NlxuICAgICAgICAgICAgfHwgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPiAxNjM4NCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBtb2R1bHVzIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOCBiaXRzIGFuZCA+PSAyNTYgYW5kIDw9IDE2Mzg0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgIH1cbn1cblxuY2xhc3MgUnNhU3NhUHJvdmlkZXIgZXh0ZW5kcyBSc2FQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBU1NBLVBLQ1MxLXYxXzVcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBSc2FQc3NQcm92aWRlciBleHRlbmRzIFJzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0EtUFNTXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wic2lnblwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1widmVyaWZ5XCJdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInNhbHRMZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLnNhbHRMZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0TGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5zYWx0TGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzYWx0TGVuZ3RoOiBNdXN0IGJlIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUnNhT2FlcFByb3ZpZGVyIGV4dGVuZHMgUnNhUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQS1PQUVQXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1wiZW5jcnlwdFwiLCBcIndyYXBLZXlcIl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAoYWxnb3JpdGhtLmxhYmVsXG4gICAgICAgICAgICAmJiAhKGFsZ29yaXRobS5sYWJlbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0ubGFiZWwpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxhYmVsOiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBFbGxpcHRpY1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJuYW1lZEN1cnZlXCIpO1xuICAgICAgICB0aGlzLmNoZWNrTmFtZWRDdXJ2ZShhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XG4gICAgfVxuICAgIGNoZWNrTmFtZWRDdXJ2ZShuYW1lZEN1cnZlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm5hbWVkQ3VydmVzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSBuYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBuYW1lZEN1cnZlOiBNdXN0IGJlIG9uZSBvZiAke3RoaXMubmFtZWRDdXJ2ZXMuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cblxuY2xhc3MgRWNkc2FQcm92aWRlciBleHRlbmRzIEVsbGlwdGljUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVDRFNBXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJQLTI1NlwiLCBcIlAtMzg0XCIsIFwiUC01MjFcIiwgXCJLLTI1NlwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgfVxufVxuXG5jb25zdCBLRVlfVFlQRVMgPSBbXCJzZWNyZXRcIiwgXCJwcml2YXRlXCIsIFwicHVibGljXCJdO1xuY2xhc3MgQ3J5cHRvS2V5IHtcbiAgICBzdGF0aWMgY3JlYXRlKGFsZ29yaXRobSwgdHlwZSwgZXh0cmFjdGFibGUsIHVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgdGhpcygpO1xuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICBrZXkudHlwZSA9IHR5cGU7XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0gdXNhZ2VzO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBzdGF0aWMgaXNLZXlUeXBlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEtFWV9UWVBFUy5pbmRleE9mKGRhdGEpICE9PSAtMTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJDcnlwdG9LZXlcIjtcbiAgICB9XG59XG5cbmNsYXNzIEVjZGhQcm92aWRlciBleHRlbmRzIEVsbGlwdGljUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVDREhcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJkZXJpdmVCaXRzXCIsIFwiZGVyaXZlS2V5XCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIlAtMjU2XCIsIFwiUC0zODRcIiwgXCJQLTUyMVwiLCBcIkstMjU2XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInB1YmxpY1wiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnB1YmxpYyBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWM6IElzIG5vdCBhIENyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLnB1YmxpYy50eXBlICE9PSBcInB1YmxpY1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJwdWJsaWM6IElzIG5vdCBhIHB1YmxpYyBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5wdWJsaWMuYWxnb3JpdGhtLm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBwdWJsaWM6IElzIG5vdCAke3RoaXMubmFtZX0ga2V5YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEVjZGhFc1Byb3ZpZGVyIGV4dGVuZHMgRWNkaFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJFQ0RILUVTXCI7XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJYMjU1MTlcIiwgXCJYNDQ4XCJdO1xuICAgIH1cbn1cblxuY2xhc3MgRWREc2FQcm92aWRlciBleHRlbmRzIEVsbGlwdGljUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVkRFNBXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wic2lnblwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1widmVyaWZ5XCJdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gW1wiRWQyNTUxOVwiLCBcIkVkNDQ4XCJdO1xuICAgIH1cbn1cblxubGV0IE9iamVjdElkZW50aWZpZXIgPSBjbGFzcyBPYmplY3RJZGVudGlmaWVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyIH0pXG5dLCBPYmplY3RJZGVudGlmaWVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuT2JqZWN0SWRlbnRpZmllciA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgT2JqZWN0SWRlbnRpZmllcik7XG5cbmNsYXNzIEFsZ29yaXRobUlkZW50aWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtcyk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHtcbiAgICAgICAgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2JqZWN0SWRlbnRpZmllcixcbiAgICB9KVxuXSwgQWxnb3JpdGhtSWRlbnRpZmllci5wcm90b3R5cGUsIFwiYWxnb3JpdGhtXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3Aoe1xuICAgICAgICB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5BbnksXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIH0pXG5dLCBBbGdvcml0aG1JZGVudGlmaWVyLnByb3RvdHlwZSwgXCJwYXJhbWV0ZXJzXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFByaXZhdGVLZXlJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5QWxnb3JpdGhtID0gbmV3IEFsZ29yaXRobUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBBbGdvcml0aG1JZGVudGlmaWVyIH0pXG5dLCBQcml2YXRlS2V5SW5mby5wcm90b3R5cGUsIFwicHJpdmF0ZUtleUFsZ29yaXRobVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJwcml2YXRlS2V5XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5BbnksIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQcml2YXRlS2V5SW5mby5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiLCB2b2lkIDApO1xuXG5jbGFzcyBQdWJsaWNLZXlJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXlBbGdvcml0aG0gPSBuZXcgQWxnb3JpdGhtSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBBbGdvcml0aG1JZGVudGlmaWVyIH0pXG5dLCBQdWJsaWNLZXlJbmZvLnByb3RvdHlwZSwgXCJwdWJsaWNLZXlBbGdvcml0aG1cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZyB9KVxuXSwgUHVibGljS2V5SW5mby5wcm90b3R5cGUsIFwicHVibGljS2V5XCIsIHZvaWQgMCk7XG5cbmNvbnN0IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKHZhbHVlKSxcbiAgICB0b0pTT046ICh2YWx1ZSkgPT4gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwobmV3IFVpbnQ4QXJyYXkodmFsdWUpKSxcbn07XG5cbmNvbnN0IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVIZXggPSB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICByZXR1cm4gIShuZXcgVWludDhBcnJheSh2YWx1ZUhleClbMF0pXG4gICAgICAgICAgICA/IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXguc2xpY2UoMSlcbiAgICAgICAgICAgIDogdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICB9LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVIZXggPSBuZXcgVWludDhBcnJheSh2YWx1ZSlbMF0gPiAxMjdcbiAgICAgICAgICAgID8gcHZ0c3V0aWxzLmNvbWJpbmUobmV3IFVpbnQ4QXJyYXkoWzBdKS5idWZmZXIsIHZhbHVlKVxuICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xX19uYW1lc3BhY2UuSW50ZWdlcih7IHZhbHVlSGV4IH0pO1xuICAgIH0sXG59O1xuXG52YXIgaW5kZXgkMyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlcixcbiAgSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXJcbn0pO1xuXG5jbGFzcyBSc2FQcml2YXRlS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5tb2R1bHVzID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnB1YmxpY0V4cG9uZW50ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnByaXZhdGVFeHBvbmVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wcmltZTEgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHJpbWUyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLmV4cG9uZW50MSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5leHBvbmVudDIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMuY29lZmZpY2llbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBhc24xU2NoZW1hLkFzbkludGVnZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcIm5cIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcIm1vZHVsdXNcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImVcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInB1YmxpY0V4cG9uZW50XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJkXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwcml2YXRlRXhwb25lbnRcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcInBcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaW1lMVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwicVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpbWUyXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJkcFwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiZXhwb25lbnQxXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJkcVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiZXhwb25lbnQyXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJxaVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiY29lZmZpY2llbnRcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcIm90aGVyUHJpbWVJbmZvc1wiLCB2b2lkIDApO1xuXG5jbGFzcyBSc2FQdWJsaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZHVsdXMgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHVibGljRXhwb25lbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiblwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHVibGljS2V5LnByb3RvdHlwZSwgXCJtb2R1bHVzXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJlXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQdWJsaWNLZXkucHJvdG90eXBlLCBcInB1YmxpY0V4cG9uZW50XCIsIHZvaWQgMCk7XG5cbmxldCBFY1B1YmxpY0tleSA9IGNsYXNzIEVjUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAoYnl0ZXNbMF0gIT09IDB4MDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9FcnJvcihcIldyb25nIEVDUG9pbnQuIEN1cnJlbnQgdmVyc2lvbiBzdXBwb3J0cyBvbmx5IFVuY29tcHJlc3NlZCAoMHgwNCkgcG9pbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJ5dGVzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChieXRlcy5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKSksXG4gICAgICAgICAgICB5OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChieXRlcy5idWZmZXIuc2xpY2Uob2Zmc2V0ICsgc2l6ZSwgb2Zmc2V0ICsgc2l6ZSArIHNpemUpKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCEoXCJ4XCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIng6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJ5XCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInk6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcbiAgICAgICAgY29uc3QgeSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi55KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwdnRzdXRpbHMuY29tYmluZShuZXcgVWludDhBcnJheShbMHgwNF0pLmJ1ZmZlciwgeCwgeSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgVWludDhBcnJheSh2YWx1ZSkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIEVjUHVibGljS2V5LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuRWNQdWJsaWNLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEVjUHVibGljS2V5KTtcblxuY2xhc3MgRWNQcml2YXRlS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghKFwiZFwiIGluIGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkOiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi5kKTtcbiAgICAgICAgaWYgKFwieFwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xuICAgICAgICAgICAgcHVibGljS2V5LmZyb21KU09OKGpzb24pO1xuICAgICAgICAgICAgY29uc3QgYXNuID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnRvQVNOKHB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAoXCJ2YWx1ZUhleFwiIGluIGFzbi52YWx1ZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqd2sgPSB7fTtcbiAgICAgICAgandrLmQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oandrLCBuZXcgRWNQdWJsaWNLZXkodGhpcy5wdWJsaWNLZXkpLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gandrO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogYXNuMVNjaGVtYS5Bc25JbnRlZ2VyQ29udmVydGVyIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaXZhdGVLZXlcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IGNvbnRleHQ6IDAsIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicGFyYW1ldGVyc1wiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgY29udGV4dDogMSwgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nLCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRWNQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwgdm9pZCAwKTtcblxuY29uc3QgQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXgpO1xuICAgICAgICByZXR1cm4gKGJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgPyBieXRlcy5idWZmZXIuc2xpY2UoMSlcbiAgICAgICAgICAgIDogYnl0ZXMuYnVmZmVyO1xuICAgIH0sXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKGJ5dGVzWzBdID4gMTI3KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgbmV3VmFsdWUuc2V0KGJ5dGVzLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMV9fbmFtZXNwYWNlLkludGVnZXIoeyB2YWx1ZUhleDogbmV3VmFsdWUuYnVmZmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgYXNuMV9fbmFtZXNwYWNlLkludGVnZXIoeyB2YWx1ZUhleDogdmFsdWUgfSk7XG4gICAgfSxcbn07XG5cbnZhciBpbmRleCQyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlcjogQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyXG59KTtcblxuY2xhc3MgRWNVdGlscyB7XG4gICAgc3RhdGljIGRlY29kZVBvaW50KGRhdGEsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIGlmICgodmlldy5sZW5ndGggPT09IDApIHx8ICh2aWV3WzBdICE9PSA0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB1bmNvbXByZXNzZWQgcG9pbnQgZm9ybWF0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gKHZpZXcubGVuZ3RoIC0gMSkgLyAyO1xuICAgICAgICBpZiAobiAhPT0gKE1hdGguY2VpbChwb2ludFNpemUgLyA4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvaW50IGRvZXMgbm90IG1hdGNoIGZpZWxkIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeGIgPSB2aWV3LnNsaWNlKDEsIG4gKyAxKTtcbiAgICAgICAgY29uc3QgeWIgPSB2aWV3LnNsaWNlKG4gKyAxLCBuICsgMSArIG4pO1xuICAgICAgICByZXR1cm4geyB4OiB4YiwgeTogeWIgfTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVBvaW50KHBvaW50LCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguY2VpbChwb2ludFNpemUgLyA4KTtcbiAgICAgICAgaWYgKHBvaW50LnguYnl0ZUxlbmd0aCAhPT0gc2l6ZSB8fCBwb2ludC55LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlgsWSBjb29yZGluYXRlcyBkb24ndCBtYXRjaCBwb2ludCBzaXplIGNyaXRlcmlhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwb2ludC54KTtcbiAgICAgICAgY29uc3QgeSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBvaW50LnkpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzaXplICogMiArIDEpO1xuICAgICAgICByZXNbMF0gPSA0O1xuICAgICAgICByZXMuc2V0KHgsIDEpO1xuICAgICAgICByZXMuc2V0KHksIHNpemUgKyAxKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGdldFNpemUocG9pbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocG9pbnRTaXplIC8gOCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVTaWduYXR1cmUoc2lnbmF0dXJlLCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZShwb2ludFNpemUpO1xuICAgICAgICBjb25zdCByID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoc2lnbmF0dXJlLnIpO1xuICAgICAgICBjb25zdCBzID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoc2lnbmF0dXJlLnMpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzaXplICogMik7XG4gICAgICAgIHJlcy5zZXQodGhpcy5wYWRTdGFydChyLCBzaXplKSk7XG4gICAgICAgIHJlcy5zZXQodGhpcy5wYWRTdGFydChzLCBzaXplKSwgc2l6ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGVTaWduYXR1cmUoZGF0YSwgcG9pbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUocG9pbnRTaXplKTtcbiAgICAgICAgY29uc3QgdmlldyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBpZiAodmlldy5sZW5ndGggIT09IChzaXplICogMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBzaXplIG9mIHRoZSBzaWduYXR1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHZpZXcuc2xpY2UoMCwgc2l6ZSk7XG4gICAgICAgIGNvbnN0IHMgPSB2aWV3LnNsaWNlKHNpemUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogdGhpcy50cmltU3RhcnQociksXG4gICAgICAgICAgICBzOiB0aGlzLnRyaW1TdGFydChzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHRyaW1TdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKChpIDwgZGF0YS5sZW5ndGggLSAxKSAmJiAoZGF0YVtpXSA9PT0gMCkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoaSwgZGF0YS5sZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFkU3RhcnQoZGF0YSwgc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICByZXMuc2V0KGRhdGEsIHNpemUgLSBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG5jbGFzcyBFY0RzYVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5zID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVdlYkNyeXB0b1NpZ25hdHVyZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBwb2ludFNpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBFY1V0aWxzLmRlY29kZVNpZ25hdHVyZSh2YWx1ZSwgcG9pbnRTaXplICogOCk7XG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gbmV3IEVjRHNhU2lnbmF0dXJlKCk7XG4gICAgICAgIGVjU2lnbmF0dXJlLnIgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocG9pbnQucik7XG4gICAgICAgIGVjU2lnbmF0dXJlLnMgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocG9pbnQucyk7XG4gICAgICAgIHJldHVybiBlY1NpZ25hdHVyZTtcbiAgICB9XG4gICAgdG9XZWJDcnlwdG9TaWduYXR1cmUocG9pbnRTaXplKSB7XG4gICAgICAgIHBvaW50U2l6ZSAhPT0gbnVsbCAmJiBwb2ludFNpemUgIT09IHZvaWQgMCA/IHBvaW50U2l6ZSA6IChwb2ludFNpemUgPSBNYXRoLm1heCh0aGlzLnIuYnl0ZUxlbmd0aCwgdGhpcy5zLmJ5dGVMZW5ndGgpICogOCk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IEVjVXRpbHMuZW5jb2RlU2lnbmF0dXJlKHRoaXMsIHBvaW50U2l6ZSk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmUuYnVmZmVyO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyIH0pXG5dLCBFY0RzYVNpZ25hdHVyZS5wcm90b3R5cGUsIFwiclwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIgfSlcbl0sIEVjRHNhU2lnbmF0dXJlLnByb3RvdHlwZSwgXCJzXCIsIHZvaWQgMCk7XG5cbmNsYXNzIE9uZUFzeW1tZXRyaWNLZXkgZXh0ZW5kcyBQcml2YXRlS2V5SW5mbyB7XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyBjb250ZXh0OiAxLCBpbXBsaWNpdDogdHJ1ZSwgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nLCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT25lQXN5bW1ldHJpY0tleS5wcm90b3R5cGUsIFwicHVibGljS2V5XCIsIHZvaWQgMCk7XG5cbmxldCBFZFByaXZhdGVLZXkgPSBjbGFzcyBFZFByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbi5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkOiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24uZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGp3ayA9IHtcbiAgICAgICAgICAgIGQ6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKHRoaXMudmFsdWUpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gandrO1xuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgRWRQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuRWRQcml2YXRlS2V5ID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBFZFByaXZhdGVLZXkpO1xuXG5sZXQgRWRQdWJsaWNLZXkgPSBjbGFzcyBFZFB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghKFwieFwiIGluIGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4OiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcgfSlcbl0sIEVkUHVibGljS2V5LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuRWRQdWJsaWNLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEVkUHVibGljS2V5KTtcblxubGV0IEN1cnZlUHJpdmF0ZUtleSA9IGNsYXNzIEN1cnZlUHJpdmF0ZUtleSB7XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBDdXJ2ZVByaXZhdGVLZXkucHJvdG90eXBlLCBcImRcIiwgdm9pZCAwKTtcbkN1cnZlUHJpdmF0ZUtleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgQ3VydmVQcml2YXRlS2V5KTtcblxuY29uc3QgaWRTZWNwMjU2cjEgPSBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIjtcbmNvbnN0IGlkRWxsaXB0aWNDdXJ2ZSA9IFwiMS4zLjEzMi4wXCI7XG5jb25zdCBpZFNlY3AzODRyMSA9IGAke2lkRWxsaXB0aWNDdXJ2ZX0uMzRgO1xuY29uc3QgaWRTZWNwNTIxcjEgPSBgJHtpZEVsbGlwdGljQ3VydmV9LjM1YDtcbmNvbnN0IGlkU2VjcDI1NmsxID0gYCR7aWRFbGxpcHRpY0N1cnZlfS4xMGA7XG5jb25zdCBpZFZlcnNpb25PbmUgPSBcIjEuMy4zNi4zLjMuMi44LjEuMVwiO1xuY29uc3QgaWRCcmFpbnBvb2xQMTYwcjEgPSBgJHtpZFZlcnNpb25PbmV9LjFgO1xuY29uc3QgaWRCcmFpbnBvb2xQMTYwdDEgPSBgJHtpZFZlcnNpb25PbmV9LjJgO1xuY29uc3QgaWRCcmFpbnBvb2xQMTkycjEgPSBgJHtpZFZlcnNpb25PbmV9LjNgO1xuY29uc3QgaWRCcmFpbnBvb2xQMTkydDEgPSBgJHtpZFZlcnNpb25PbmV9LjRgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjI0cjEgPSBgJHtpZFZlcnNpb25PbmV9LjVgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjI0dDEgPSBgJHtpZFZlcnNpb25PbmV9LjZgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjU2cjEgPSBgJHtpZFZlcnNpb25PbmV9LjdgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjU2dDEgPSBgJHtpZFZlcnNpb25PbmV9LjhgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzIwcjEgPSBgJHtpZFZlcnNpb25PbmV9LjlgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzIwdDEgPSBgJHtpZFZlcnNpb25PbmV9LjEwYDtcbmNvbnN0IGlkQnJhaW5wb29sUDM4NHIxID0gYCR7aWRWZXJzaW9uT25lfS4xMWA7XG5jb25zdCBpZEJyYWlucG9vbFAzODR0MSA9IGAke2lkVmVyc2lvbk9uZX0uMTJgO1xuY29uc3QgaWRCcmFpbnBvb2xQNTEycjEgPSBgJHtpZFZlcnNpb25PbmV9LjEzYDtcbmNvbnN0IGlkQnJhaW5wb29sUDUxMnQxID0gYCR7aWRWZXJzaW9uT25lfS4xNGA7XG5jb25zdCBpZFgyNTUxOSA9IFwiMS4zLjEwMS4xMTBcIjtcbmNvbnN0IGlkWDQ0OCA9IFwiMS4zLjEwMS4xMTFcIjtcbmNvbnN0IGlkRWQyNTUxOSA9IFwiMS4zLjEwMS4xMTJcIjtcbmNvbnN0IGlkRWQ0NDggPSBcIjEuMy4xMDEuMTEzXCI7XG5cbnZhciBpbmRleCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFsZ29yaXRobUlkZW50aWZpZXI6IEFsZ29yaXRobUlkZW50aWZpZXIsXG4gIGdldCBDdXJ2ZVByaXZhdGVLZXkgKCkgeyByZXR1cm4gQ3VydmVQcml2YXRlS2V5OyB9LFxuICBFY0RzYVNpZ25hdHVyZTogRWNEc2FTaWduYXR1cmUsXG4gIEVjUHJpdmF0ZUtleTogRWNQcml2YXRlS2V5LFxuICBnZXQgRWNQdWJsaWNLZXkgKCkgeyByZXR1cm4gRWNQdWJsaWNLZXk7IH0sXG4gIGdldCBFZFByaXZhdGVLZXkgKCkgeyByZXR1cm4gRWRQcml2YXRlS2V5OyB9LFxuICBnZXQgRWRQdWJsaWNLZXkgKCkgeyByZXR1cm4gRWRQdWJsaWNLZXk7IH0sXG4gIGdldCBPYmplY3RJZGVudGlmaWVyICgpIHsgcmV0dXJuIE9iamVjdElkZW50aWZpZXI7IH0sXG4gIE9uZUFzeW1tZXRyaWNLZXk6IE9uZUFzeW1tZXRyaWNLZXksXG4gIFByaXZhdGVLZXlJbmZvOiBQcml2YXRlS2V5SW5mbyxcbiAgUHVibGljS2V5SW5mbzogUHVibGljS2V5SW5mbyxcbiAgUnNhUHJpdmF0ZUtleTogUnNhUHJpdmF0ZUtleSxcbiAgUnNhUHVibGljS2V5OiBSc2FQdWJsaWNLZXksXG4gIGNvbnZlcnRlcnM6IGluZGV4JDIsXG4gIGlkQnJhaW5wb29sUDE2MHIxOiBpZEJyYWlucG9vbFAxNjByMSxcbiAgaWRCcmFpbnBvb2xQMTYwdDE6IGlkQnJhaW5wb29sUDE2MHQxLFxuICBpZEJyYWlucG9vbFAxOTJyMTogaWRCcmFpbnBvb2xQMTkycjEsXG4gIGlkQnJhaW5wb29sUDE5MnQxOiBpZEJyYWlucG9vbFAxOTJ0MSxcbiAgaWRCcmFpbnBvb2xQMjI0cjE6IGlkQnJhaW5wb29sUDIyNHIxLFxuICBpZEJyYWlucG9vbFAyMjR0MTogaWRCcmFpbnBvb2xQMjI0dDEsXG4gIGlkQnJhaW5wb29sUDI1NnIxOiBpZEJyYWlucG9vbFAyNTZyMSxcbiAgaWRCcmFpbnBvb2xQMjU2dDE6IGlkQnJhaW5wb29sUDI1NnQxLFxuICBpZEJyYWlucG9vbFAzMjByMTogaWRCcmFpbnBvb2xQMzIwcjEsXG4gIGlkQnJhaW5wb29sUDMyMHQxOiBpZEJyYWlucG9vbFAzMjB0MSxcbiAgaWRCcmFpbnBvb2xQMzg0cjE6IGlkQnJhaW5wb29sUDM4NHIxLFxuICBpZEJyYWlucG9vbFAzODR0MTogaWRCcmFpbnBvb2xQMzg0dDEsXG4gIGlkQnJhaW5wb29sUDUxMnIxOiBpZEJyYWlucG9vbFA1MTJyMSxcbiAgaWRCcmFpbnBvb2xQNTEydDE6IGlkQnJhaW5wb29sUDUxMnQxLFxuICBpZEVkMjU1MTk6IGlkRWQyNTUxOSxcbiAgaWRFZDQ0ODogaWRFZDQ0OCxcbiAgaWRFbGxpcHRpY0N1cnZlOiBpZEVsbGlwdGljQ3VydmUsXG4gIGlkU2VjcDI1NmsxOiBpZFNlY3AyNTZrMSxcbiAgaWRTZWNwMjU2cjE6IGlkU2VjcDI1NnIxLFxuICBpZFNlY3AzODRyMTogaWRTZWNwMzg0cjEsXG4gIGlkU2VjcDUyMXIxOiBpZFNlY3A1MjFyMSxcbiAgaWRWZXJzaW9uT25lOiBpZFZlcnNpb25PbmUsXG4gIGlkWDI1NTE5OiBpZFgyNTUxOSxcbiAgaWRYNDQ4OiBpZFg0NDhcbn0pO1xuXG5jbGFzcyBFY0N1cnZlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICBzdGF0aWMgcmVnaXN0ZXIoaXRlbSkge1xuICAgICAgICBjb25zdCBvaWQgPSBuZXcgT2JqZWN0SWRlbnRpZmllcigpO1xuICAgICAgICBvaWQudmFsdWUgPSBpdGVtLmlkO1xuICAgICAgICBjb25zdCByYXcgPSBhc24xU2NoZW1hLkFzbkNvbnZlcnQuc2VyaWFsaXplKG9pZCk7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgcmF3LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lcy5wdXNoKGl0ZW0ubmFtZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kKG5hbWVPcklkKSB7XG4gICAgICAgIG5hbWVPcklkID0gbmFtZU9ySWQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gbmFtZU9ySWQgfHwgaXRlbS5pZC50b1VwcGVyQ2FzZSgpID09PSBuYW1lT3JJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5hbWVPcklkKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZmluZChuYW1lT3JJZCk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEVDIG5hbWVkIGN1cnZlICcke25hbWVPcklkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbkVjQ3VydmVzLml0ZW1zID0gW107XG5FY0N1cnZlcy5uYW1lcyA9IFtdO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIlAtMjU2XCIsIGlkOiBpZFNlY3AyNTZyMSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIlAtMzg0XCIsIGlkOiBpZFNlY3AzODRyMSwgc2l6ZTogMzg0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIlAtNTIxXCIsIGlkOiBpZFNlY3A1MjFyMSwgc2l6ZTogNTIxIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIkstMjU2XCIsIGlkOiBpZFNlY3AyNTZrMSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxNjByMVwiLCBpZDogaWRCcmFpbnBvb2xQMTYwcjEsIHNpemU6IDE2MCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMTYwdDFcIiwgaWQ6IGlkQnJhaW5wb29sUDE2MHQxLCBzaXplOiAxNjAgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE5MnIxXCIsIGlkOiBpZEJyYWlucG9vbFAxOTJyMSwgc2l6ZTogMTkyIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxOTJ0MVwiLCBpZDogaWRCcmFpbnBvb2xQMTkydDEsIHNpemU6IDE5MiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjI0cjFcIiwgaWQ6IGlkQnJhaW5wb29sUDIyNHIxLCBzaXplOiAyMjQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDIyNHQxXCIsIGlkOiBpZEJyYWlucG9vbFAyMjR0MSwgc2l6ZTogMjI0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyNTZyMVwiLCBpZDogaWRCcmFpbnBvb2xQMjU2cjEsIHNpemU6IDI1NiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjU2dDFcIiwgaWQ6IGlkQnJhaW5wb29sUDI1NnQxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDMyMHIxXCIsIGlkOiBpZEJyYWlucG9vbFAzMjByMSwgc2l6ZTogMzIwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAzMjB0MVwiLCBpZDogaWRCcmFpbnBvb2xQMzIwdDEsIHNpemU6IDMyMCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzg0cjFcIiwgaWQ6IGlkQnJhaW5wb29sUDM4NHIxLCBzaXplOiAzODQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDM4NHQxXCIsIGlkOiBpZEJyYWlucG9vbFAzODR0MSwgc2l6ZTogMzg0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFA1MTJyMVwiLCBpZDogaWRCcmFpbnBvb2xQNTEycjEsIHNpemU6IDUxMiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQNTEydDFcIiwgaWQ6IGlkQnJhaW5wb29sUDUxMnQxLCBzaXplOiA1MTIgfSk7XG5cbmNsYXNzIEhtYWNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJITUFDXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJzaWduXCIsIFwidmVyaWZ5XCJdO1xuICAgIH1cbiAgICBnZXREZWZhdWx0TGVuZ3RoKGFsZ05hbWUpIHtcbiAgICAgICAgc3dpdGNoIChhbGdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiA1MTI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbGdvcml0aG0gbmFtZSAnJHthbGdOYW1lfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICBpZiAoXCJsZW5ndGhcIiBpbiBhbGdvcml0aG0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGdvcml0aG0ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibGVuZ3RoOiBOdW1iZXIgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgIH1cbn1cblxuY2xhc3MgUGJrZGYyUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUEJLREYyXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJkZXJpdmVCaXRzXCIsIFwiZGVyaXZlS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInNhbHRcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5zYWx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5zYWx0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdGVyYXRpb25zXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5pdGVyYXRpb25zICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9uczogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uaXRlcmF0aW9ucyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25zOiBJcyBsZXNzIHRoYW4gMVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICBzdXBlci5jaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIGlmIChleHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZXh0cmFjdGFibGU6IE11c3QgYmUgJ2ZhbHNlJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSGtkZlByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkhLREZcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImRlcml2ZUtleVwiLCBcImRlcml2ZUJpdHNcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwic2FsdFwiKTtcbiAgICAgICAgaWYgKCFwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGFsZ29yaXRobS5zYWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHQ6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImluZm9cIik7XG4gICAgICAgIGlmICghcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShhbGdvcml0aG0uaW5mbykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgaWYgKGV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJleHRyYWN0YWJsZTogTXVzdCBiZSAnZmFsc2UnXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSAwO1xuICAgIH1cbiAgICBkaWdlc3QoLi4uYXJncykge1xuICAgICAgICBhcmdzWzBdID0geyBsZW5ndGg6IHRoaXMuZGVmYXVsdExlbmd0aCwgLi4uYXJnc1swXSB9O1xuICAgICAgICByZXR1cm4gc3VwZXIuZGlnZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0RpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tEaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYWxnb3JpdGhtLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBuZWdhdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2hha2UxMjhQcm92aWRlciBleHRlbmRzIFNoYWtlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcInNoYWtlMTI4XCI7XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IDE2O1xuICAgIH1cbn1cblxuY2xhc3MgU2hha2UyNTZQcm92aWRlciBleHRlbmRzIFNoYWtlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcInNoYWtlMjU2XCI7XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IDMyO1xuICAgIH1cbn1cblxuY2xhc3MgQ3J5cHRvIHtcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkNyeXB0b1wiO1xuICAgIH1cbiAgICByYW5kb21VVUlEKCkge1xuICAgICAgICBjb25zdCBiID0gdGhpcy5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcbiAgICAgICAgYls2XSA9IChiWzZdICYgMHgwZikgfCAweDQwO1xuICAgICAgICBiWzhdID0gKGJbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgICAgIGNvbnN0IHV1aWQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0hleChiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7dXVpZC5zdWJzdHJpbmcoMCwgOCl9LSR7dXVpZC5zdWJzdHJpbmcoOCwgMTIpfS0ke3V1aWQuc3Vic3RyaW5nKDEyLCAxNil9LSR7dXVpZC5zdWJzdHJpbmcoMTYsIDIwKX0tJHt1dWlkLnN1YnN0cmluZygyMCl9YDtcbiAgICB9XG59XG5cbmNsYXNzIFByb3ZpZGVyU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB9XG4gICAgZ2V0KGFsZ29yaXRobU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbYWxnb3JpdGhtTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5pdGVtc1twcm92aWRlci5uYW1lLnRvTG93ZXJDYXNlKCldID0gcHJvdmlkZXI7XG4gICAgfVxuICAgIHJlbW92ZUF0KGFsZ29yaXRobU5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldChhbGdvcml0aG1OYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLml0ZW1zW2FsZ29yaXRobU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgaGFzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLml0ZW1zKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBhbGdvcml0aG1zKCkge1xuICAgICAgICBjb25zdCBhbGdvcml0aG1zID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5pdGVtc1trZXldO1xuICAgICAgICAgICAgYWxnb3JpdGhtcy5wdXNoKHByb3ZpZGVyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGdvcml0aG1zLnNvcnQoKTtcbiAgICB9XG59XG5cbmNsYXNzIFN1YnRsZUNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IFByb3ZpZGVyU3RvcmFnZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNIYXNoZWRBbGdvcml0aG0oZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICYmIFwibmFtZVwiIGluIGRhdGFcbiAgICAgICAgICAgICYmIFwiaGFzaFwiIGluIGRhdGFcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJTdWJ0bGVDcnlwdG9cIjtcbiAgICB9XG4gICAgYXN5bmMgZGlnZXN0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDIsIFwiZGlnZXN0XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmRpZ2VzdChwcmVwYXJlZEFsZ29yaXRobSwgcHJlcGFyZWREYXRhLCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImdlbmVyYXRlS2V5XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5nZW5lcmF0ZUtleSh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24oLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJzaWduXCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5zaWduKHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwga2V5LCBwcmVwYXJlZERhdGEsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCA0LCBcInZlcmlmeVwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRTaWduYXR1cmUgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci52ZXJpZnkoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkU2lnbmF0dXJlLCBwcmVwYXJlZERhdGEsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJlbmNyeXB0XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5lbmNyeXB0KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwga2V5LCBwcmVwYXJlZERhdGEsIHsga2V5VXNhZ2U6IHRydWUgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImRlY3J5cHRcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmRlY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogdHJ1ZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZXJpdmVCaXRzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZGVyaXZlQml0c1wiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShiYXNlS2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5kZXJpdmVCaXRzKHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgYmFzZUtleSwgbGVuZ3RoLCB7IGtleVVzYWdlOiB0cnVlIH0sIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCA1LCBcImRlcml2ZUtleVwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwgYmFzZUtleSwgZGVyaXZlZEtleVR5cGUsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERlcml2ZWRLZXlUeXBlID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGRlcml2ZWRLZXlUeXBlKTtcbiAgICAgICAgY29uc3QgaW1wb3J0UHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkRGVyaXZlZEtleVR5cGUubmFtZSk7XG4gICAgICAgIGltcG9ydFByb3ZpZGVyLmNoZWNrRGVyaXZlZEtleVBhcmFtcyhwcmVwYXJlZERlcml2ZWRLZXlUeXBlKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBwcm92aWRlci5jaGVja0NyeXB0b0tleShiYXNlS2V5LCBcImRlcml2ZUtleVwiKTtcbiAgICAgICAgY29uc3QgZGVyaXZlZEJpdHMgPSBhd2FpdCBwcm92aWRlci5kZXJpdmVCaXRzKHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgYmFzZUtleSwgZGVyaXZlZEtleVR5cGUubGVuZ3RoIHx8IDUxMiwgeyBrZXlVc2FnZTogZmFsc2UgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0S2V5KFwicmF3XCIsIGRlcml2ZWRCaXRzLCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDIsIFwiZXhwb3J0S2V5XCIpO1xuICAgICAgICBjb25zdCBbZm9ybWF0LCBrZXksIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihrZXkuYWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5leHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCA1LCBcImltcG9ydEtleVwiKTtcbiAgICAgICAgY29uc3QgW2Zvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBpZiAoW1wicGtjczhcIiwgXCJzcGtpXCIsIFwicmF3XCJdLmluZGV4T2YoZm9ybWF0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihrZXlEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5pbXBvcnRLZXkoZm9ybWF0LCBwcmVwYXJlZERhdGEsIHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgha2V5RGF0YS5rdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogSXMgbm90IEpTT05cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgd3JhcEtleShmb3JtYXQsIGtleSwgd3JhcHBpbmdLZXksIHdyYXBBbGdvcml0aG0sIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGtleURhdGEgPSBhd2FpdCB0aGlzLmV4cG9ydEtleShmb3JtYXQsIGtleSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShrZXlEYXRhKTtcbiAgICAgICAgICAgIGtleURhdGEgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tVXRmOFN0cmluZyhqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobSh3cmFwQWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGtleURhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5lbmNyeXB0KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgd3JhcHBpbmdLZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogZmFsc2UgfSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHVud3JhcEtleShmb3JtYXQsIHdyYXBwZWRLZXksIHVud3JhcHBpbmdLZXksIHVud3JhcEFsZ29yaXRobSwgdW53cmFwcGVkS2V5QWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKHVud3JhcEFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcih3cmFwcGVkS2V5KTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBsZXQga2V5RGF0YSA9IGF3YWl0IHByb3ZpZGVyLmRlY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCB1bndyYXBwaW5nS2V5LCBwcmVwYXJlZERhdGEsIHsga2V5VXNhZ2U6IGZhbHNlIH0sIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImp3a1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGtleURhdGEgPSBKU09OLnBhcnNlKHB2dHN1dGlscy5Db252ZXJ0LlRvVXRmOFN0cmluZyhrZXlEYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihcIndyYXBwZWRLZXk6IElzIG5vdCBhIEpTT05cIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuaW50ZXJuYWwgPSBlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHVud3JhcHBlZEtleUFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncyk7XG4gICAgfVxuICAgIGNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgc2l6ZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHttZXRob2ROYW1lfScgb24gJ1N1YnRsZUNyeXB0byc6ICR7c2l6ZX0gYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3MubGVuZ3RofSBwcmVzZW50YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWxnb3JpdGhtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3VidGxlQ3J5cHRvLmlzSGFzaGVkQWxnb3JpdGhtKGFsZ29yaXRobSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0geyAuLi5hbGdvcml0aG0gfTtcbiAgICAgICAgICAgIHByZXBhcmVkQWxnb3JpdGhtLmhhc2ggPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVkQWxnb3JpdGhtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmFsZ29yaXRobSB9O1xuICAgIH1cbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBLZXkgaXMgbm90IG9mIHR5cGUgJ0NyeXB0b0tleSdgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbnZlcnRlcnM6IGluZGV4JDNcbn0pO1xuXG5jb25zdCBSRVFVSVJFRF9GSUVMRFMgPSBbXCJjcnZcIiwgXCJlXCIsIFwia1wiLCBcImt0eVwiLCBcIm5cIiwgXCJ4XCIsIFwieVwiXTtcbmNsYXNzIEp3a1V0aWxzIHtcbiAgICBzdGF0aWMgYXN5bmMgdGh1bWJwcmludChoYXNoLCBqd2ssIGNyeXB0bykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5mb3JtYXQoandrLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGlnZXN0KGhhc2gsIHB2dHN1dGlscy5Db252ZXJ0LkZyb21CaW5hcnkoSlNPTi5zdHJpbmdpZnkoZGF0YSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZvcm1hdChqd2ssIHJlbW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXMgPSBPYmplY3QuZW50cmllcyhqd2spO1xuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICByZXMgPSByZXMuZmlsdGVyKG8gPT4gUkVRVUlSRURfRklFTERTLmluY2x1ZGVzKG9bMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSByZXMuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IGtleUEgPiBrZXlCID8gMSA6IGtleUEgPCBrZXlCID8gLTEgOiAwKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhyZXMpO1xuICAgIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCdWZmZXJTb3VyY2VDb252ZXJ0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlcjsgfVxufSk7XG5leHBvcnRzLkFlc0NiY1Byb3ZpZGVyID0gQWVzQ2JjUHJvdmlkZXI7XG5leHBvcnRzLkFlc0NtYWNQcm92aWRlciA9IEFlc0NtYWNQcm92aWRlcjtcbmV4cG9ydHMuQWVzQ3RyUHJvdmlkZXIgPSBBZXNDdHJQcm92aWRlcjtcbmV4cG9ydHMuQWVzRWNiUHJvdmlkZXIgPSBBZXNFY2JQcm92aWRlcjtcbmV4cG9ydHMuQWVzR2NtUHJvdmlkZXIgPSBBZXNHY21Qcm92aWRlcjtcbmV4cG9ydHMuQWVzS3dQcm92aWRlciA9IEFlc0t3UHJvdmlkZXI7XG5leHBvcnRzLkFlc1Byb3ZpZGVyID0gQWVzUHJvdmlkZXI7XG5leHBvcnRzLkFsZ29yaXRobUVycm9yID0gQWxnb3JpdGhtRXJyb3I7XG5leHBvcnRzLkNyeXB0byA9IENyeXB0bztcbmV4cG9ydHMuQ3J5cHRvRXJyb3IgPSBDcnlwdG9FcnJvcjtcbmV4cG9ydHMuQ3J5cHRvS2V5ID0gQ3J5cHRvS2V5O1xuZXhwb3J0cy5EZXNQcm92aWRlciA9IERlc1Byb3ZpZGVyO1xuZXhwb3J0cy5FY0N1cnZlcyA9IEVjQ3VydmVzO1xuZXhwb3J0cy5FY1V0aWxzID0gRWNVdGlscztcbmV4cG9ydHMuRWNkaEVzUHJvdmlkZXIgPSBFY2RoRXNQcm92aWRlcjtcbmV4cG9ydHMuRWNkaFByb3ZpZGVyID0gRWNkaFByb3ZpZGVyO1xuZXhwb3J0cy5FY2RzYVByb3ZpZGVyID0gRWNkc2FQcm92aWRlcjtcbmV4cG9ydHMuRWREc2FQcm92aWRlciA9IEVkRHNhUHJvdmlkZXI7XG5leHBvcnRzLkVsbGlwdGljUHJvdmlkZXIgPSBFbGxpcHRpY1Byb3ZpZGVyO1xuZXhwb3J0cy5Ia2RmUHJvdmlkZXIgPSBIa2RmUHJvdmlkZXI7XG5leHBvcnRzLkhtYWNQcm92aWRlciA9IEhtYWNQcm92aWRlcjtcbmV4cG9ydHMuSndrVXRpbHMgPSBKd2tVdGlscztcbmV4cG9ydHMuT3BlcmF0aW9uRXJyb3IgPSBPcGVyYXRpb25FcnJvcjtcbmV4cG9ydHMuUGJrZGYyUHJvdmlkZXIgPSBQYmtkZjJQcm92aWRlcjtcbmV4cG9ydHMuUGVtQ29udmVydGVyID0gUGVtQ29udmVydGVyO1xuZXhwb3J0cy5Qcm92aWRlckNyeXB0byA9IFByb3ZpZGVyQ3J5cHRvO1xuZXhwb3J0cy5Qcm92aWRlclN0b3JhZ2UgPSBQcm92aWRlclN0b3JhZ2U7XG5leHBvcnRzLlJlcXVpcmVkUHJvcGVydHlFcnJvciA9IFJlcXVpcmVkUHJvcGVydHlFcnJvcjtcbmV4cG9ydHMuUnNhT2FlcFByb3ZpZGVyID0gUnNhT2FlcFByb3ZpZGVyO1xuZXhwb3J0cy5Sc2FQcm92aWRlciA9IFJzYVByb3ZpZGVyO1xuZXhwb3J0cy5Sc2FQc3NQcm92aWRlciA9IFJzYVBzc1Byb3ZpZGVyO1xuZXhwb3J0cy5Sc2FTc2FQcm92aWRlciA9IFJzYVNzYVByb3ZpZGVyO1xuZXhwb3J0cy5TaGFrZTEyOFByb3ZpZGVyID0gU2hha2UxMjhQcm92aWRlcjtcbmV4cG9ydHMuU2hha2UyNTZQcm92aWRlciA9IFNoYWtlMjU2UHJvdmlkZXI7XG5leHBvcnRzLlNoYWtlUHJvdmlkZXIgPSBTaGFrZVByb3ZpZGVyO1xuZXhwb3J0cy5TdWJ0bGVDcnlwdG8gPSBTdWJ0bGVDcnlwdG87XG5leHBvcnRzLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IgPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yO1xuZXhwb3J0cy5hc24xID0gaW5kZXgkMTtcbmV4cG9ydHMuaXNKV0sgPSBpc0pXSztcbmV4cG9ydHMuanNvbiA9IGluZGV4O1xuIl0sIm5hbWVzIjpbInB2dHN1dGlscyIsInJlcXVpcmUiLCJhc24xU2NoZW1hIiwidHNsaWIiLCJqc29uU2NoZW1hIiwiYXNuMSIsIl9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdCIsImUiLCJuIiwiT2JqZWN0IiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImRlZmF1bHQiLCJmcmVlemUiLCJhc24xX19uYW1lc3BhY2UiLCJDcnlwdG9FcnJvciIsIkVycm9yIiwiQWxnb3JpdGhtRXJyb3IiLCJVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRob2ROYW1lIiwiT3BlcmF0aW9uRXJyb3IiLCJSZXF1aXJlZFByb3BlcnR5RXJyb3IiLCJwcm9wTmFtZSIsIlBlbUNvbnZlcnRlciIsInRvQXJyYXlCdWZmZXIiLCJwZW0iLCJiYXNlNjQiLCJyZXBsYWNlIiwiQ29udmVydCIsIkZyb21CYXNlNjQiLCJ0b1VpbnQ4QXJyYXkiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJmcm9tQnVmZmVyU291cmNlIiwiYnVmZmVyIiwidGFnIiwiVG9CYXNlNjQiLCJzbGljZWQiLCJvZmZzZXQiLCJyb3dzIiwic2xpY2UiLCJsZW5ndGgiLCJwdXNoIiwidXBwZXJDYXNlVGFnIiwidG9VcHBlckNhc2UiLCJqb2luIiwiaXNQRU0iLCJkYXRhIiwidGVzdCIsImdldFRhZ05hbWUiLCJyZXMiLCJleGVjIiwiaGFzVGFnTmFtZSIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsImlzQ2VydGlmaWNhdGUiLCJpc0NlcnRpZmljYXRlUmVxdWVzdCIsImlzQ1JMIiwiaXNQdWJsaWNLZXkiLCJpc0pXSyIsIlByb3ZpZGVyQ3J5cHRvIiwiZGlnZXN0IiwiYXJncyIsImNoZWNrRGlnZXN0IiwiYXBwbHkiLCJvbkRpZ2VzdCIsImFsZ29yaXRobSIsImNoZWNrQWxnb3JpdGhtTmFtZSIsImdlbmVyYXRlS2V5IiwiY2hlY2tHZW5lcmF0ZUtleSIsIm9uR2VuZXJhdGVLZXkiLCJleHRyYWN0YWJsZSIsImtleVVzYWdlcyIsImNoZWNrR2VuZXJhdGVLZXlQYXJhbXMiLCJUeXBlRXJyb3IiLCJhbGxvd2VkVXNhZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwidXNhZ2VzIiwicHJpdmF0ZUtleSIsImNvbmNhdCIsInB1YmxpY0tleSIsImNoZWNrS2V5VXNhZ2VzIiwic2lnbiIsImNoZWNrU2lnbiIsIm9uU2lnbiIsImtleSIsImNoZWNrQWxnb3JpdGhtUGFyYW1zIiwiY2hlY2tDcnlwdG9LZXkiLCJ2ZXJpZnkiLCJjaGVja1ZlcmlmeSIsIm9uVmVyaWZ5Iiwic2lnbmF0dXJlIiwiZW5jcnlwdCIsImNoZWNrRW5jcnlwdCIsIm9uRW5jcnlwdCIsIm9wdGlvbnMiLCJrZXlVc2FnZSIsImRlY3J5cHQiLCJjaGVja0RlY3J5cHQiLCJvbkRlY3J5cHQiLCJkZXJpdmVCaXRzIiwiY2hlY2tEZXJpdmVCaXRzIiwib25EZXJpdmVCaXRzIiwiYmFzZUtleSIsImV4cG9ydEtleSIsImNoZWNrRXhwb3J0S2V5Iiwib25FeHBvcnRLZXkiLCJmb3JtYXQiLCJjaGVja0tleUZvcm1hdCIsImltcG9ydEtleSIsImNoZWNrSW1wb3J0S2V5Iiwib25JbXBvcnRLZXkiLCJrZXlEYXRhIiwiY2hlY2tLZXlEYXRhIiwiY2hlY2tJbXBvcnRQYXJhbXMiLCJuYW1lIiwiY2hlY2tEZXJpdmVkS2V5UGFyYW1zIiwiYWxsb3dlZCIsInVzYWdlIiwiaW5kZXhPZiIsImNoZWNrUmVxdWlyZWRQcm9wZXJ0eSIsImNoZWNrSGFzaEFsZ29yaXRobSIsImhhc2hBbGdvcml0aG1zIiwiaXRlbSIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsImlzQnVmZmVyU291cmNlIiwicHJlcGFyZURhdGEiLCJBZXNQcm92aWRlciIsIkFlc0NiY1Byb3ZpZGVyIiwiYXJndW1lbnRzIiwiaXYiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ5dGVMZW5ndGgiLCJBZXNDbWFjUHJvdmlkZXIiLCJBZXNDdHJQcm92aWRlciIsImNvdW50ZXIiLCJBZXNFY2JQcm92aWRlciIsIkFlc0djbVByb3ZpZGVyIiwidGFnTGVuZ3RoIiwiQWVzS3dQcm92aWRlciIsIkRlc1Byb3ZpZGVyIiwiaXZTaXplIiwia2V5U2l6ZUJpdHMiLCJSc2FQcm92aWRlciIsImhhc2giLCJwdWJsaWNFeHBvbmVudCIsIm1vZHVsdXNMZW5ndGgiLCJSc2FTc2FQcm92aWRlciIsIlJzYVBzc1Byb3ZpZGVyIiwic2FsdExlbmd0aCIsIlJhbmdlRXJyb3IiLCJSc2FPYWVwUHJvdmlkZXIiLCJsYWJlbCIsIkVsbGlwdGljUHJvdmlkZXIiLCJjaGVja05hbWVkQ3VydmUiLCJuYW1lZEN1cnZlIiwibmFtZWRDdXJ2ZXMiLCJFY2RzYVByb3ZpZGVyIiwiS0VZX1RZUEVTIiwiQ3J5cHRvS2V5IiwidHlwZSIsImlzS2V5VHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiRWNkaFByb3ZpZGVyIiwicHVibGljIiwiRWNkaEVzUHJvdmlkZXIiLCJFZERzYVByb3ZpZGVyIiwiT2JqZWN0SWRlbnRpZmllciIsInZhbHVlIiwiX19kZWNvcmF0ZSIsIkFzblByb3AiLCJBc25Qcm9wVHlwZXMiLCJwcm90b3R5cGUiLCJBc25UeXBlIiwiQXNuVHlwZVR5cGVzIiwiQ2hvaWNlIiwiQWxnb3JpdGhtSWRlbnRpZmllciIsInBhcmFtcyIsImFzc2lnbiIsIkFueSIsIm9wdGlvbmFsIiwiUHJpdmF0ZUtleUluZm8iLCJ2ZXJzaW9uIiwicHJpdmF0ZUtleUFsZ29yaXRobSIsIkludGVnZXIiLCJPY3RldFN0cmluZyIsIlB1YmxpY0tleUluZm8iLCJwdWJsaWNLZXlBbGdvcml0aG0iLCJCaXRTdHJpbmciLCJKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIiLCJmcm9tSlNPTiIsIkZyb21CYXNlNjRVcmwiLCJ0b0pTT04iLCJUb0Jhc2U2NFVybCIsIkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciIsImZyb21BU04iLCJ2YWx1ZUhleCIsInZhbHVlQmxvY2siLCJ0b0FTTiIsImNvbWJpbmUiLCJpbmRleCQzIiwiX19wcm90b19fIiwiUnNhUHJpdmF0ZUtleSIsIm1vZHVsdXMiLCJwcml2YXRlRXhwb25lbnQiLCJwcmltZTEiLCJwcmltZTIiLCJleHBvbmVudDEiLCJleHBvbmVudDIiLCJjb2VmZmljaWVudCIsImNvbnZlcnRlciIsIkFzbkludGVnZXJDb252ZXJ0ZXIiLCJKc29uUHJvcCIsIlJzYVB1YmxpY0tleSIsIkVjUHVibGljS2V5Iiwic2l6ZSIsImpzb24iLCJ4IiwieSIsIkVjUHJpdmF0ZUtleSIsImFzbiIsIkFzblNlcmlhbGl6ZXIiLCJqd2siLCJjb250ZXh0IiwiQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyIiwibmV3VmFsdWUiLCJzZXQiLCJpbmRleCQyIiwiRWNVdGlscyIsImRlY29kZVBvaW50IiwicG9pbnRTaXplIiwidmlldyIsIk1hdGgiLCJjZWlsIiwieGIiLCJ5YiIsImVuY29kZVBvaW50IiwicG9pbnQiLCJnZXRTaXplIiwiZW5jb2RlU2lnbmF0dXJlIiwiciIsInMiLCJwYWRTdGFydCIsImRlY29kZVNpZ25hdHVyZSIsInRyaW1TdGFydCIsImkiLCJFY0RzYVNpZ25hdHVyZSIsImZyb21XZWJDcnlwdG9TaWduYXR1cmUiLCJlY1NpZ25hdHVyZSIsInRvV2ViQ3J5cHRvU2lnbmF0dXJlIiwibWF4IiwiT25lQXN5bW1ldHJpY0tleSIsImltcGxpY2l0IiwiRWRQcml2YXRlS2V5IiwiRWRQdWJsaWNLZXkiLCJDdXJ2ZVByaXZhdGVLZXkiLCJKc29uUHJvcFR5cGVzIiwiU3RyaW5nIiwiaWRTZWNwMjU2cjEiLCJpZEVsbGlwdGljQ3VydmUiLCJpZFNlY3AzODRyMSIsImlkU2VjcDUyMXIxIiwiaWRTZWNwMjU2azEiLCJpZFZlcnNpb25PbmUiLCJpZEJyYWlucG9vbFAxNjByMSIsImlkQnJhaW5wb29sUDE2MHQxIiwiaWRCcmFpbnBvb2xQMTkycjEiLCJpZEJyYWlucG9vbFAxOTJ0MSIsImlkQnJhaW5wb29sUDIyNHIxIiwiaWRCcmFpbnBvb2xQMjI0dDEiLCJpZEJyYWlucG9vbFAyNTZyMSIsImlkQnJhaW5wb29sUDI1NnQxIiwiaWRCcmFpbnBvb2xQMzIwcjEiLCJpZEJyYWlucG9vbFAzMjB0MSIsImlkQnJhaW5wb29sUDM4NHIxIiwiaWRCcmFpbnBvb2xQMzg0dDEiLCJpZEJyYWlucG9vbFA1MTJyMSIsImlkQnJhaW5wb29sUDUxMnQxIiwiaWRYMjU1MTkiLCJpZFg0NDgiLCJpZEVkMjU1MTkiLCJpZEVkNDQ4IiwiaW5kZXgkMSIsImNvbnZlcnRlcnMiLCJFY0N1cnZlcyIsInJlZ2lzdGVyIiwib2lkIiwiaWQiLCJyYXciLCJBc25Db252ZXJ0Iiwic2VyaWFsaXplIiwiaXRlbXMiLCJuYW1lcyIsImZpbmQiLCJuYW1lT3JJZCIsIkhtYWNQcm92aWRlciIsImdldERlZmF1bHRMZW5ndGgiLCJhbGdOYW1lIiwiUGJrZGYyUHJvdmlkZXIiLCJzYWx0IiwiaXRlcmF0aW9ucyIsIlN5bnRheEVycm9yIiwiSGtkZlByb3ZpZGVyIiwiaW5mbyIsIlNoYWtlUHJvdmlkZXIiLCJkZWZhdWx0TGVuZ3RoIiwiU2hha2UxMjhQcm92aWRlciIsIlNoYWtlMjU2UHJvdmlkZXIiLCJDcnlwdG8iLCJyYW5kb21VVUlEIiwiYiIsImdldFJhbmRvbVZhbHVlcyIsInV1aWQiLCJUb0hleCIsInN1YnN0cmluZyIsIlByb3ZpZGVyU3RvcmFnZSIsImFsZ29yaXRobU5hbWUiLCJwcm92aWRlciIsInJlbW92ZUF0IiwiaGFzIiwiYWxnb3JpdGhtcyIsInNvcnQiLCJTdWJ0bGVDcnlwdG8iLCJwcm92aWRlcnMiLCJpc0hhc2hlZEFsZ29yaXRobSIsImNoZWNrUmVxdWlyZWRBcmd1bWVudHMiLCJwcmVwYXJlZEFsZ29yaXRobSIsInByZXBhcmVBbGdvcml0aG0iLCJwcmVwYXJlZERhdGEiLCJnZXRQcm92aWRlciIsInJlc3VsdCIsInByZXBhcmVkU2lnbmF0dXJlIiwiZGVyaXZlS2V5IiwiZGVyaXZlZEtleVR5cGUiLCJwcmVwYXJlZERlcml2ZWRLZXlUeXBlIiwiaW1wb3J0UHJvdmlkZXIiLCJkZXJpdmVkQml0cyIsImt0eSIsIndyYXBLZXkiLCJ3cmFwcGluZ0tleSIsIndyYXBBbGdvcml0aG0iLCJKU09OIiwic3RyaW5naWZ5IiwiRnJvbVV0ZjhTdHJpbmciLCJ1bndyYXBLZXkiLCJ3cmFwcGVkS2V5IiwidW53cmFwcGluZ0tleSIsInVud3JhcEFsZ29yaXRobSIsInVud3JhcHBlZEtleUFsZ29yaXRobSIsInBhcnNlIiwiVG9VdGY4U3RyaW5nIiwiZXJyb3IiLCJpbnRlcm5hbCIsImluZGV4IiwiUkVRVUlSRURfRklFTERTIiwiSndrVXRpbHMiLCJ0aHVtYnByaW50IiwiY3J5cHRvIiwic3VidGxlIiwiRnJvbUJpbmFyeSIsInJlbW92ZSIsImVudHJpZXMiLCJmaWx0ZXIiLCJvIiwiaW5jbHVkZXMiLCJrZXlBIiwia2V5QiIsImZyb21FbnRyaWVzIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/webcrypto-core/build/webcrypto-core.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/webcrypto-core/build/webcrypto-core.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/webcrypto-core/build/webcrypto-core.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\n\n\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(ssr)/../../node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(ssr)/../../node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/../../node_modules/tslib/tslib.es6.js\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(ssr)/../../node_modules/@peculiar/json-schema/build/index.js\");\nvar asn1 = __webpack_require__(/*! asn1js */ \"(ssr)/../../node_modules/asn1js/build/index.js\");\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar asn1__namespace = /*#__PURE__*/_interopNamespaceDefault(asn1);\n\nclass CryptoError extends Error {\n}\n\nclass AlgorithmError extends CryptoError {\n}\n\nclass UnsupportedOperationError extends CryptoError {\n    constructor(methodName) {\n        super(`Unsupported operation: ${methodName ? `${methodName}` : \"\"}`);\n    }\n}\n\nclass OperationError extends CryptoError {\n}\n\nclass RequiredPropertyError extends CryptoError {\n    constructor(propName) {\n        super(`${propName}: Missing required property`);\n    }\n}\n\nclass PemConverter {\n    static toArrayBuffer(pem) {\n        const base64 = pem\n            .replace(/-{5}(BEGIN|END) .*-{5}/g, \"\")\n            .replace(\"\\r\", \"\")\n            .replace(\"\\n\", \"\");\n        return pvtsutils.Convert.FromBase64(base64);\n    }\n    static toUint8Array(pem) {\n        const bytes = this.toArrayBuffer(pem);\n        return new Uint8Array(bytes);\n    }\n    static fromBufferSource(buffer, tag) {\n        const base64 = pvtsutils.Convert.ToBase64(buffer);\n        let sliced;\n        let offset = 0;\n        const rows = [];\n        while (true) {\n            sliced = base64.slice(offset, offset = offset + 64);\n            if (sliced.length) {\n                rows.push(sliced);\n                if (sliced.length < 64) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        const upperCaseTag = tag.toUpperCase();\n        return `-----BEGIN ${upperCaseTag}-----\\n${rows.join(\"\\n\")}\\n-----END ${upperCaseTag}-----`;\n    }\n    static isPEM(data) {\n        return /-----BEGIN .+-----[A-Za-z0-9+\\/\\+\\=\\s\\n]+-----END .+-----/i.test(data);\n    }\n    static getTagName(pem) {\n        if (!this.isPEM(pem)) {\n            throw new Error(\"Bad parameter. Incoming data is not right PEM\");\n        }\n        const res = /-----BEGIN (.+)-----/.exec(pem);\n        if (!res) {\n            throw new Error(\"Cannot get tag from PEM\");\n        }\n        return res[1];\n    }\n    static hasTagName(pem, tagName) {\n        const tag = this.getTagName(pem);\n        return tagName.toLowerCase() === tag.toLowerCase();\n    }\n    static isCertificate(pem) {\n        return this.hasTagName(pem, \"certificate\");\n    }\n    static isCertificateRequest(pem) {\n        return this.hasTagName(pem, \"certificate request\");\n    }\n    static isCRL(pem) {\n        return this.hasTagName(pem, \"x509 crl\");\n    }\n    static isPublicKey(pem) {\n        return this.hasTagName(pem, \"public key\");\n    }\n}\n\nfunction isJWK(data) {\n    return typeof data === \"object\" && \"kty\" in data;\n}\n\nclass ProviderCrypto {\n    async digest(...args) {\n        this.checkDigest.apply(this, args);\n        return this.onDigest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        this.checkAlgorithmName(algorithm);\n    }\n    async onDigest(algorithm, data) {\n        throw new UnsupportedOperationError(\"digest\");\n    }\n    async generateKey(...args) {\n        this.checkGenerateKey.apply(this, args);\n        return this.onGenerateKey.apply(this, args);\n    }\n    checkGenerateKey(algorithm, extractable, keyUsages, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkGenerateKeyParams(algorithm);\n        if (!(keyUsages && keyUsages.length)) {\n            throw new TypeError(`Usages cannot be empty when creating a key.`);\n        }\n        let allowedUsages;\n        if (Array.isArray(this.usages)) {\n            allowedUsages = this.usages;\n        }\n        else {\n            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);\n        }\n        this.checkKeyUsages(keyUsages, allowedUsages);\n    }\n    checkGenerateKeyParams(algorithm) {\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages, ...args) {\n        throw new UnsupportedOperationError(\"generateKey\");\n    }\n    async sign(...args) {\n        this.checkSign.apply(this, args);\n        return this.onSign.apply(this, args);\n    }\n    checkSign(algorithm, key, data, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"sign\");\n    }\n    async onSign(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"sign\");\n    }\n    async verify(...args) {\n        this.checkVerify.apply(this, args);\n        return this.onVerify.apply(this, args);\n    }\n    checkVerify(algorithm, key, signature, data, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"verify\");\n    }\n    async onVerify(algorithm, key, signature, data, ...args) {\n        throw new UnsupportedOperationError(\"verify\");\n    }\n    async encrypt(...args) {\n        this.checkEncrypt.apply(this, args);\n        return this.onEncrypt.apply(this, args);\n    }\n    checkEncrypt(algorithm, key, data, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"encrypt\" : void 0);\n    }\n    async onEncrypt(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"encrypt\");\n    }\n    async decrypt(...args) {\n        this.checkDecrypt.apply(this, args);\n        return this.onDecrypt.apply(this, args);\n    }\n    checkDecrypt(algorithm, key, data, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"decrypt\" : void 0);\n    }\n    async onDecrypt(algorithm, key, data, ...args) {\n        throw new UnsupportedOperationError(\"decrypt\");\n    }\n    async deriveBits(...args) {\n        this.checkDeriveBits.apply(this, args);\n        return this.onDeriveBits.apply(this, args);\n    }\n    checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(baseKey, options.keyUsage ? \"deriveBits\" : void 0);\n        if (length % 8 !== 0) {\n            throw new OperationError(\"length: Is not multiple of 8\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length, ...args) {\n        throw new UnsupportedOperationError(\"deriveBits\");\n    }\n    async exportKey(...args) {\n        this.checkExportKey.apply(this, args);\n        return this.onExportKey.apply(this, args);\n    }\n    checkExportKey(format, key, ...args) {\n        this.checkKeyFormat(format);\n        this.checkCryptoKey(key);\n        if (!key.extractable) {\n            throw new CryptoError(\"key: Is not extractable\");\n        }\n    }\n    async onExportKey(format, key, ...args) {\n        throw new UnsupportedOperationError(\"exportKey\");\n    }\n    async importKey(...args) {\n        this.checkImportKey.apply(this, args);\n        return this.onImportKey.apply(this, args);\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        this.checkKeyFormat(format);\n        this.checkKeyData(format, keyData);\n        this.checkAlgorithmName(algorithm);\n        this.checkImportParams(algorithm);\n        if (Array.isArray(this.usages)) {\n            this.checkKeyUsages(keyUsages, this.usages);\n        }\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        throw new UnsupportedOperationError(\"importKey\");\n    }\n    checkAlgorithmName(algorithm) {\n        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n    }\n    checkAlgorithmParams(algorithm) {\n    }\n    checkDerivedKeyParams(algorithm) {\n    }\n    checkKeyUsages(usages, allowed) {\n        for (const usage of usages) {\n            if (allowed.indexOf(usage) === -1) {\n                throw new TypeError(\"Cannot create a key using the specified key usages\");\n            }\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        this.checkAlgorithmName(key.algorithm);\n        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {\n            throw new CryptoError(`key does not match that of operation`);\n        }\n    }\n    checkRequiredProperty(data, propName) {\n        if (!(propName in data)) {\n            throw new RequiredPropertyError(propName);\n        }\n    }\n    checkHashAlgorithm(algorithm, hashAlgorithms) {\n        for (const item of hashAlgorithms) {\n            if (item.toLowerCase() === algorithm.name.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(\", \")}`);\n    }\n    checkImportParams(algorithm) {\n    }\n    checkKeyFormat(format) {\n        switch (format) {\n            case \"raw\":\n            case \"pkcs8\":\n            case \"spki\":\n            case \"jwk\":\n                break;\n            default:\n                throw new TypeError(\"format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'\");\n        }\n    }\n    checkKeyData(format, keyData) {\n        if (!keyData) {\n            throw new TypeError(\"keyData: Cannot be empty on empty on key importing\");\n        }\n        if (format === \"jwk\") {\n            if (!isJWK(keyData)) {\n                throw new TypeError(\"keyData: Is not JsonWebToken\");\n            }\n        }\n        else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {\n            throw new TypeError(\"keyData: Is not ArrayBufferView or ArrayBuffer\");\n        }\n    }\n    prepareData(data) {\n        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n    }\n}\n\nclass AesProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        switch (algorithm.length) {\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new TypeError(\"length: Must be 128, 192, or 256\");\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\n\nclass AesCbcProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-CBC\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n    }\n}\n\nclass AesCmacProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-CMAC\";\n        this.usages = [\"sign\", \"verify\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\n\nclass AesCtrProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-CTR\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"counter\");\n        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {\n            throw new TypeError(\"counter: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.counter.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\n\nclass AesEcbProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-ECB\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n}\n\nclass AesGcmProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-GCM\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength < 1) {\n            throw new OperationError(\"iv: Must have length more than 0 and less than 2^64 - 1\");\n        }\n        if (!(\"tagLength\" in algorithm)) {\n            algorithm.tagLength = 128;\n        }\n        switch (algorithm.tagLength) {\n            case 32:\n            case 64:\n            case 96:\n            case 104:\n            case 112:\n            case 120:\n            case 128:\n                break;\n            default:\n                throw new OperationError(\"tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128\");\n        }\n    }\n}\n\nclass AesKwProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-KW\";\n        this.usages = [\"wrapKey\", \"unwrapKey\"];\n    }\n}\n\nclass DesProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        if (this.ivSize) {\n            this.checkRequiredProperty(algorithm, \"iv\");\n            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n                throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n            }\n            if (algorithm.iv.byteLength !== this.ivSize) {\n                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);\n            }\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        if (algorithm.length !== this.keySizeBits) {\n            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\n\nclass RsaProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        if (algorithm.modulusLength % 8\n            || algorithm.modulusLength < 256\n            || algorithm.modulusLength > 16384) {\n            throw new TypeError(\"The modulus length must be a multiple of 8 bits and >= 256 and <= 16384\");\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\n\nclass RsaSsaProvider extends RsaProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSASSA-PKCS1-v1_5\";\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n    }\n}\n\nclass RsaPssProvider extends RsaProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSA-PSS\";\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"saltLength\");\n        if (typeof algorithm.saltLength !== \"number\") {\n            throw new TypeError(\"saltLength: Is not a Number\");\n        }\n        if (algorithm.saltLength < 0) {\n            throw new RangeError(\"saltLength: Must be positive number\");\n        }\n    }\n}\n\nclass RsaOaepProvider extends RsaProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSA-OAEP\";\n        this.usages = {\n            privateKey: [\"decrypt\", \"unwrapKey\"],\n            publicKey: [\"encrypt\", \"wrapKey\"],\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        if (algorithm.label\n            && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {\n            throw new TypeError(\"label: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n}\n\nclass EllipticProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"namedCurve\");\n        this.checkNamedCurve(algorithm.namedCurve);\n    }\n    checkNamedCurve(namedCurve) {\n        for (const item of this.namedCurves) {\n            if (item.toLowerCase() === namedCurve.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(\", \")}`);\n    }\n}\n\nclass EcdsaProvider extends EllipticProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"ECDSA\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n        this.namedCurves = [\"P-256\", \"P-384\", \"P-521\", \"K-256\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\n\nconst KEY_TYPES = [\"secret\", \"private\", \"public\"];\nclass CryptoKey {\n    static create(algorithm, type, extractable, usages) {\n        const key = new this();\n        key.algorithm = algorithm;\n        key.type = type;\n        key.extractable = extractable;\n        key.usages = usages;\n        return key;\n    }\n    static isKeyType(data) {\n        return KEY_TYPES.indexOf(data) !== -1;\n    }\n    get [Symbol.toStringTag]() {\n        return \"CryptoKey\";\n    }\n}\n\nclass EcdhProvider extends EllipticProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"ECDH\";\n        this.usages = {\n            privateKey: [\"deriveBits\", \"deriveKey\"],\n            publicKey: [],\n        };\n        this.namedCurves = [\"P-256\", \"P-384\", \"P-521\", \"K-256\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"public\");\n        if (!(algorithm.public instanceof CryptoKey)) {\n            throw new TypeError(\"public: Is not a CryptoKey\");\n        }\n        if (algorithm.public.type !== \"public\") {\n            throw new OperationError(\"public: Is not a public key\");\n        }\n        if (algorithm.public.algorithm.name !== this.name) {\n            throw new OperationError(`public: Is not ${this.name} key`);\n        }\n    }\n}\n\nclass EcdhEsProvider extends EcdhProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"ECDH-ES\";\n        this.namedCurves = [\"X25519\", \"X448\"];\n    }\n}\n\nclass EdDsaProvider extends EllipticProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"EdDSA\";\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n        this.namedCurves = [\"Ed25519\", \"Ed448\"];\n    }\n}\n\nlet ObjectIdentifier = class ObjectIdentifier {\n    constructor(value) {\n        if (value) {\n            this.value = value;\n        }\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.ObjectIdentifier })\n], ObjectIdentifier.prototype, \"value\", void 0);\nObjectIdentifier = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], ObjectIdentifier);\n\nclass AlgorithmIdentifier {\n    constructor(params) {\n        Object.assign(this, params);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier,\n    })\n], AlgorithmIdentifier.prototype, \"algorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true,\n    })\n], AlgorithmIdentifier.prototype, \"parameters\", void 0);\n\nclass PrivateKeyInfo {\n    constructor() {\n        this.version = 0;\n        this.privateKeyAlgorithm = new AlgorithmIdentifier();\n        this.privateKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer })\n], PrivateKeyInfo.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: AlgorithmIdentifier })\n], PrivateKeyInfo.prototype, \"privateKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], PrivateKeyInfo.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Any, optional: true })\n], PrivateKeyInfo.prototype, \"attributes\", void 0);\n\nclass PublicKeyInfo {\n    constructor() {\n        this.publicKeyAlgorithm = new AlgorithmIdentifier();\n        this.publicKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: AlgorithmIdentifier })\n], PublicKeyInfo.prototype, \"publicKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.BitString })\n], PublicKeyInfo.prototype, \"publicKey\", void 0);\n\nconst JsonBase64UrlArrayBufferConverter = {\n    fromJSON: (value) => pvtsutils.Convert.FromBase64Url(value),\n    toJSON: (value) => pvtsutils.Convert.ToBase64Url(new Uint8Array(value)),\n};\n\nconst AsnIntegerArrayBufferConverter = {\n    fromASN: (value) => {\n        const valueHex = value.valueBlock.valueHex;\n        return !(new Uint8Array(valueHex)[0])\n            ? value.valueBlock.valueHex.slice(1)\n            : value.valueBlock.valueHex;\n    },\n    toASN: (value) => {\n        const valueHex = new Uint8Array(value)[0] > 127\n            ? pvtsutils.combine(new Uint8Array([0]).buffer, value)\n            : value;\n        return new asn1__namespace.Integer({ valueHex });\n    },\n};\n\nvar index$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,\n  JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter\n});\n\nclass RsaPrivateKey {\n    constructor() {\n        this.version = 0;\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n        this.privateExponent = new ArrayBuffer(0);\n        this.prime1 = new ArrayBuffer(0);\n        this.prime2 = new ArrayBuffer(0);\n        this.exponent1 = new ArrayBuffer(0);\n        this.exponent2 = new ArrayBuffer(0);\n        this.coefficient = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: asn1Schema.AsnIntegerConverter })\n], RsaPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"n\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"e\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"publicExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"d\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"privateExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"p\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"prime1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"q\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"prime2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"dp\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"exponent1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"dq\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"exponent2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"qi\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"coefficient\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Any, optional: true })\n], RsaPrivateKey.prototype, \"otherPrimeInfos\", void 0);\n\nclass RsaPublicKey {\n    constructor() {\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"n\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPublicKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"e\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPublicKey.prototype, \"publicExponent\", void 0);\n\nlet EcPublicKey = class EcPublicKey {\n    constructor(value) {\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        let bytes = new Uint8Array(this.value);\n        if (bytes[0] !== 0x04) {\n            throw new CryptoError(\"Wrong ECPoint. Current version supports only Uncompressed (0x04) point\");\n        }\n        bytes = new Uint8Array(this.value.slice(1));\n        const size = bytes.length / 2;\n        const offset = 0;\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),\n            y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size)),\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        if (!(\"y\" in json)) {\n            throw new Error(\"y: Missing required property\");\n        }\n        const x = pvtsutils.Convert.FromBase64Url(json.x);\n        const y = pvtsutils.Convert.FromBase64Url(json.y);\n        const value = pvtsutils.combine(new Uint8Array([0x04]).buffer, x, y);\n        this.value = new Uint8Array(value).buffer;\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], EcPublicKey.prototype, \"value\", void 0);\nEcPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], EcPublicKey);\n\nclass EcPrivateKey {\n    constructor() {\n        this.version = 1;\n        this.privateKey = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!(\"d\" in json)) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);\n        if (\"x\" in json) {\n            const publicKey = new EcPublicKey();\n            publicKey.fromJSON(json);\n            const asn = asn1Schema.AsnSerializer.toASN(publicKey);\n            if (\"valueHex\" in asn.valueBlock) {\n                this.publicKey = asn.valueBlock.valueHex;\n            }\n        }\n        return this;\n    }\n    toJSON() {\n        const jwk = {};\n        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);\n        if (this.publicKey) {\n            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());\n        }\n        return jwk;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: asn1Schema.AsnIntegerConverter })\n], EcPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], EcPrivateKey.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ context: 0, type: asn1Schema.AsnPropTypes.Any, optional: true })\n], EcPrivateKey.prototype, \"parameters\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ context: 1, type: asn1Schema.AsnPropTypes.BitString, optional: true })\n], EcPrivateKey.prototype, \"publicKey\", void 0);\n\nconst AsnIntegerWithoutPaddingConverter = {\n    fromASN: (value) => {\n        const bytes = new Uint8Array(value.valueBlock.valueHex);\n        return (bytes[0] === 0)\n            ? bytes.buffer.slice(1)\n            : bytes.buffer;\n    },\n    toASN: (value) => {\n        const bytes = new Uint8Array(value);\n        if (bytes[0] > 127) {\n            const newValue = new Uint8Array(bytes.length + 1);\n            newValue.set(bytes, 1);\n            return new asn1__namespace.Integer({ valueHex: newValue.buffer });\n        }\n        return new asn1__namespace.Integer({ valueHex: value });\n    },\n};\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter\n});\n\nclass EcUtils {\n    static decodePoint(data, pointSize) {\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if ((view.length === 0) || (view[0] !== 4)) {\n            throw new Error(\"Only uncompressed point format supported\");\n        }\n        const n = (view.length - 1) / 2;\n        if (n !== (Math.ceil(pointSize / 8))) {\n            throw new Error(\"Point does not match field size\");\n        }\n        const xb = view.slice(1, n + 1);\n        const yb = view.slice(n + 1, n + 1 + n);\n        return { x: xb, y: yb };\n    }\n    static encodePoint(point, pointSize) {\n        const size = Math.ceil(pointSize / 8);\n        if (point.x.byteLength !== size || point.y.byteLength !== size) {\n            throw new Error(\"X,Y coordinates don't match point size criteria\");\n        }\n        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);\n        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);\n        const res = new Uint8Array(size * 2 + 1);\n        res[0] = 4;\n        res.set(x, 1);\n        res.set(y, size + 1);\n        return res;\n    }\n    static getSize(pointSize) {\n        return Math.ceil(pointSize / 8);\n    }\n    static encodeSignature(signature, pointSize) {\n        const size = this.getSize(pointSize);\n        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);\n        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);\n        const res = new Uint8Array(size * 2);\n        res.set(this.padStart(r, size));\n        res.set(this.padStart(s, size), size);\n        return res;\n    }\n    static decodeSignature(data, pointSize) {\n        const size = this.getSize(pointSize);\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length !== (size * 2)) {\n            throw new Error(\"Incorrect size of the signature\");\n        }\n        const r = view.slice(0, size);\n        const s = view.slice(size);\n        return {\n            r: this.trimStart(r),\n            s: this.trimStart(s),\n        };\n    }\n    static trimStart(data) {\n        let i = 0;\n        while ((i < data.length - 1) && (data[i] === 0)) {\n            i++;\n        }\n        if (i === 0) {\n            return data;\n        }\n        return data.slice(i, data.length);\n    }\n    static padStart(data, size) {\n        if (size === data.length) {\n            return data;\n        }\n        const res = new Uint8Array(size);\n        res.set(data, size - data.length);\n        return res;\n    }\n}\n\nclass EcDsaSignature {\n    constructor() {\n        this.r = new ArrayBuffer(0);\n        this.s = new ArrayBuffer(0);\n    }\n    static fromWebCryptoSignature(value) {\n        const pointSize = value.byteLength / 2;\n        const point = EcUtils.decodeSignature(value, pointSize * 8);\n        const ecSignature = new EcDsaSignature();\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);\n        return ecSignature;\n    }\n    toWebCryptoSignature(pointSize) {\n        pointSize !== null && pointSize !== void 0 ? pointSize : (pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8);\n        const signature = EcUtils.encodeSignature(this, pointSize);\n        return signature.buffer;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })\n], EcDsaSignature.prototype, \"r\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })\n], EcDsaSignature.prototype, \"s\", void 0);\n\nclass OneAsymmetricKey extends PrivateKeyInfo {\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ context: 1, implicit: true, type: asn1Schema.AsnPropTypes.BitString, optional: true })\n], OneAsymmetricKey.prototype, \"publicKey\", void 0);\n\nlet EdPrivateKey = class EdPrivateKey {\n    constructor() {\n        this.value = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!json.d) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.d);\n        return this;\n    }\n    toJSON() {\n        const jwk = {\n            d: pvtsutils.Convert.ToBase64Url(this.value),\n        };\n        return jwk;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], EdPrivateKey.prototype, \"value\", void 0);\nEdPrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], EdPrivateKey);\n\nlet EdPublicKey = class EdPublicKey {\n    constructor(value) {\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(this.value),\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.x);\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.BitString })\n], EdPublicKey.prototype, \"value\", void 0);\nEdPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], EdPublicKey);\n\nlet CurvePrivateKey = class CurvePrivateKey {\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString }),\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, converter: JsonBase64UrlArrayBufferConverter })\n], CurvePrivateKey.prototype, \"d\", void 0);\nCurvePrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], CurvePrivateKey);\n\nconst idSecp256r1 = \"1.2.840.10045.3.1.7\";\nconst idEllipticCurve = \"1.3.132.0\";\nconst idSecp384r1 = `${idEllipticCurve}.34`;\nconst idSecp521r1 = `${idEllipticCurve}.35`;\nconst idSecp256k1 = `${idEllipticCurve}.10`;\nconst idVersionOne = \"1.3.36.3.3.2.8.1.1\";\nconst idBrainpoolP160r1 = `${idVersionOne}.1`;\nconst idBrainpoolP160t1 = `${idVersionOne}.2`;\nconst idBrainpoolP192r1 = `${idVersionOne}.3`;\nconst idBrainpoolP192t1 = `${idVersionOne}.4`;\nconst idBrainpoolP224r1 = `${idVersionOne}.5`;\nconst idBrainpoolP224t1 = `${idVersionOne}.6`;\nconst idBrainpoolP256r1 = `${idVersionOne}.7`;\nconst idBrainpoolP256t1 = `${idVersionOne}.8`;\nconst idBrainpoolP320r1 = `${idVersionOne}.9`;\nconst idBrainpoolP320t1 = `${idVersionOne}.10`;\nconst idBrainpoolP384r1 = `${idVersionOne}.11`;\nconst idBrainpoolP384t1 = `${idVersionOne}.12`;\nconst idBrainpoolP512r1 = `${idVersionOne}.13`;\nconst idBrainpoolP512t1 = `${idVersionOne}.14`;\nconst idX25519 = \"1.3.101.110\";\nconst idX448 = \"1.3.101.111\";\nconst idEd25519 = \"1.3.101.112\";\nconst idEd448 = \"1.3.101.113\";\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AlgorithmIdentifier: AlgorithmIdentifier,\n  get CurvePrivateKey () { return CurvePrivateKey; },\n  EcDsaSignature: EcDsaSignature,\n  EcPrivateKey: EcPrivateKey,\n  get EcPublicKey () { return EcPublicKey; },\n  get EdPrivateKey () { return EdPrivateKey; },\n  get EdPublicKey () { return EdPublicKey; },\n  get ObjectIdentifier () { return ObjectIdentifier; },\n  OneAsymmetricKey: OneAsymmetricKey,\n  PrivateKeyInfo: PrivateKeyInfo,\n  PublicKeyInfo: PublicKeyInfo,\n  RsaPrivateKey: RsaPrivateKey,\n  RsaPublicKey: RsaPublicKey,\n  converters: index$2,\n  idBrainpoolP160r1: idBrainpoolP160r1,\n  idBrainpoolP160t1: idBrainpoolP160t1,\n  idBrainpoolP192r1: idBrainpoolP192r1,\n  idBrainpoolP192t1: idBrainpoolP192t1,\n  idBrainpoolP224r1: idBrainpoolP224r1,\n  idBrainpoolP224t1: idBrainpoolP224t1,\n  idBrainpoolP256r1: idBrainpoolP256r1,\n  idBrainpoolP256t1: idBrainpoolP256t1,\n  idBrainpoolP320r1: idBrainpoolP320r1,\n  idBrainpoolP320t1: idBrainpoolP320t1,\n  idBrainpoolP384r1: idBrainpoolP384r1,\n  idBrainpoolP384t1: idBrainpoolP384t1,\n  idBrainpoolP512r1: idBrainpoolP512r1,\n  idBrainpoolP512t1: idBrainpoolP512t1,\n  idEd25519: idEd25519,\n  idEd448: idEd448,\n  idEllipticCurve: idEllipticCurve,\n  idSecp256k1: idSecp256k1,\n  idSecp256r1: idSecp256r1,\n  idSecp384r1: idSecp384r1,\n  idSecp521r1: idSecp521r1,\n  idVersionOne: idVersionOne,\n  idX25519: idX25519,\n  idX448: idX448\n});\n\nclass EcCurves {\n    constructor() { }\n    static register(item) {\n        const oid = new ObjectIdentifier();\n        oid.value = item.id;\n        const raw = asn1Schema.AsnConvert.serialize(oid);\n        this.items.push({\n            ...item,\n            raw,\n        });\n        this.names.push(item.name);\n    }\n    static find(nameOrId) {\n        nameOrId = nameOrId.toUpperCase();\n        for (const item of this.items) {\n            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {\n                return item;\n            }\n        }\n        return null;\n    }\n    static get(nameOrId) {\n        const res = this.find(nameOrId);\n        if (!res) {\n            throw new Error(`Unsupported EC named curve '${nameOrId}'`);\n        }\n        return res;\n    }\n}\nEcCurves.items = [];\nEcCurves.names = [];\nEcCurves.register({ name: \"P-256\", id: idSecp256r1, size: 256 });\nEcCurves.register({ name: \"P-384\", id: idSecp384r1, size: 384 });\nEcCurves.register({ name: \"P-521\", id: idSecp521r1, size: 521 });\nEcCurves.register({ name: \"K-256\", id: idSecp256k1, size: 256 });\nEcCurves.register({ name: \"brainpoolP160r1\", id: idBrainpoolP160r1, size: 160 });\nEcCurves.register({ name: \"brainpoolP160t1\", id: idBrainpoolP160t1, size: 160 });\nEcCurves.register({ name: \"brainpoolP192r1\", id: idBrainpoolP192r1, size: 192 });\nEcCurves.register({ name: \"brainpoolP192t1\", id: idBrainpoolP192t1, size: 192 });\nEcCurves.register({ name: \"brainpoolP224r1\", id: idBrainpoolP224r1, size: 224 });\nEcCurves.register({ name: \"brainpoolP224t1\", id: idBrainpoolP224t1, size: 224 });\nEcCurves.register({ name: \"brainpoolP256r1\", id: idBrainpoolP256r1, size: 256 });\nEcCurves.register({ name: \"brainpoolP256t1\", id: idBrainpoolP256t1, size: 256 });\nEcCurves.register({ name: \"brainpoolP320r1\", id: idBrainpoolP320r1, size: 320 });\nEcCurves.register({ name: \"brainpoolP320t1\", id: idBrainpoolP320t1, size: 320 });\nEcCurves.register({ name: \"brainpoolP384r1\", id: idBrainpoolP384r1, size: 384 });\nEcCurves.register({ name: \"brainpoolP384t1\", id: idBrainpoolP384t1, size: 384 });\nEcCurves.register({ name: \"brainpoolP512r1\", id: idBrainpoolP512r1, size: 512 });\nEcCurves.register({ name: \"brainpoolP512t1\", id: idBrainpoolP512t1, size: 512 });\n\nclass HmacProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"HMAC\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = [\"sign\", \"verify\"];\n    }\n    getDefaultLength(algName) {\n        switch (algName.toUpperCase()) {\n            case \"SHA-1\":\n            case \"SHA-256\":\n            case \"SHA-384\":\n            case \"SHA-512\":\n                return 512;\n            default:\n                throw new Error(`Unknown algorithm name '${algName}'`);\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        if (\"length\" in algorithm) {\n            if (typeof algorithm.length !== \"number\") {\n                throw new TypeError(\"length: Is not a Number\");\n            }\n            if (algorithm.length < 1) {\n                throw new RangeError(\"length: Number is out of range\");\n            }\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\n\nclass Pbkdf2Provider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"PBKDF2\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = [\"deriveBits\", \"deriveKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"iterations\");\n        if (typeof algorithm.iterations !== \"number\") {\n            throw new TypeError(\"iterations: Is not a Number\");\n        }\n        if (algorithm.iterations < 1) {\n            throw new TypeError(\"iterations: Is less than 1\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\n\nclass HkdfProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"HKDF\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = [\"deriveKey\", \"deriveBits\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"info\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\n\nclass ShakeProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.usages = [];\n        this.defaultLength = 0;\n    }\n    digest(...args) {\n        args[0] = { length: this.defaultLength, ...args[0] };\n        return super.digest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        super.checkDigest(algorithm, data);\n        const length = algorithm.length || 0;\n        if (typeof length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (length < 0) {\n            throw new TypeError(\"length: Is negative\");\n        }\n    }\n}\n\nclass Shake128Provider extends ShakeProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"shake128\";\n        this.defaultLength = 16;\n    }\n}\n\nclass Shake256Provider extends ShakeProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"shake256\";\n        this.defaultLength = 32;\n    }\n}\n\nclass Crypto {\n    get [Symbol.toStringTag]() {\n        return \"Crypto\";\n    }\n    randomUUID() {\n        const b = this.getRandomValues(new Uint8Array(16));\n        b[6] = (b[6] & 0x0f) | 0x40;\n        b[8] = (b[8] & 0x3f) | 0x80;\n        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();\n        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n    }\n}\n\nclass ProviderStorage {\n    constructor() {\n        this.items = {};\n    }\n    get(algorithmName) {\n        return this.items[algorithmName.toLowerCase()] || null;\n    }\n    set(provider) {\n        this.items[provider.name.toLowerCase()] = provider;\n    }\n    removeAt(algorithmName) {\n        const provider = this.get(algorithmName.toLowerCase());\n        if (provider) {\n            delete this.items[algorithmName];\n        }\n        return provider;\n    }\n    has(name) {\n        return !!this.get(name);\n    }\n    get length() {\n        return Object.keys(this.items).length;\n    }\n    get algorithms() {\n        const algorithms = [];\n        for (const key in this.items) {\n            const provider = this.items[key];\n            algorithms.push(provider.name);\n        }\n        return algorithms.sort();\n    }\n}\n\nclass SubtleCrypto {\n    constructor() {\n        this.providers = new ProviderStorage();\n    }\n    static isHashedAlgorithm(data) {\n        return data\n            && typeof data === \"object\"\n            && \"name\" in data\n            && \"hash\" in data\n            ? true\n            : false;\n    }\n    get [Symbol.toStringTag]() {\n        return \"SubtleCrypto\";\n    }\n    async digest(...args) {\n        this.checkRequiredArguments(args, 2, \"digest\");\n        const [algorithm, data, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);\n        return result;\n    }\n    async generateKey(...args) {\n        this.checkRequiredArguments(args, 3, \"generateKey\");\n        const [algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.generateKey({ ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n        return result;\n    }\n    async sign(...args) {\n        this.checkRequiredArguments(args, 3, \"sign\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.sign({ ...preparedAlgorithm, name: provider.name }, key, preparedData, ...params);\n        return result;\n    }\n    async verify(...args) {\n        this.checkRequiredArguments(args, 4, \"verify\");\n        const [algorithm, key, signature, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.verify({ ...preparedAlgorithm, name: provider.name }, key, preparedSignature, preparedData, ...params);\n        return result;\n    }\n    async encrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"encrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.encrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);\n        return result;\n    }\n    async decrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"decrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);\n        return result;\n    }\n    async deriveBits(...args) {\n        this.checkRequiredArguments(args, 3, \"deriveBits\");\n        const [algorithm, baseKey, length, ...params] = args;\n        this.checkCryptoKey(baseKey);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, length, { keyUsage: true }, ...params);\n        return result;\n    }\n    async deriveKey(...args) {\n        this.checkRequiredArguments(args, 5, \"deriveKey\");\n        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;\n        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);\n        const importProvider = this.getProvider(preparedDerivedKeyType.name);\n        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        provider.checkCryptoKey(baseKey, \"deriveKey\");\n        const derivedBits = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, derivedKeyType.length || 512, { keyUsage: false }, ...params);\n        return this.importKey(\"raw\", derivedBits, derivedKeyType, extractable, keyUsages, ...params);\n    }\n    async exportKey(...args) {\n        this.checkRequiredArguments(args, 2, \"exportKey\");\n        const [format, key, ...params] = args;\n        this.checkCryptoKey(key);\n        const provider = this.getProvider(key.algorithm.name);\n        const result = await provider.exportKey(format, key, ...params);\n        return result;\n    }\n    async importKey(...args) {\n        this.checkRequiredArguments(args, 5, \"importKey\");\n        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        if ([\"pkcs8\", \"spki\", \"raw\"].indexOf(format) !== -1) {\n            const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n            return provider.importKey(format, preparedData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n        }\n        else {\n            if (!keyData.kty) {\n                throw new TypeError(\"keyData: Is not JSON\");\n            }\n        }\n        return provider.importKey(format, keyData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n    }\n    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {\n        let keyData = await this.exportKey(format, key, ...args);\n        if (format === \"jwk\") {\n            const json = JSON.stringify(keyData);\n            keyData = pvtsutils.Convert.FromUtf8String(json);\n        }\n        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        return provider.encrypt({ ...preparedAlgorithm, name: provider.name }, wrappingKey, preparedData, { keyUsage: false }, ...args);\n    }\n    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {\n        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        let keyData = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, unwrappingKey, preparedData, { keyUsage: false }, ...args);\n        if (format === \"jwk\") {\n            try {\n                keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));\n            }\n            catch (e) {\n                const error = new TypeError(\"wrappedKey: Is not a JSON\");\n                error.internal = e;\n                throw error;\n            }\n        }\n        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);\n    }\n    checkRequiredArguments(args, size, methodName) {\n        if (args.length < size) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);\n        }\n    }\n    prepareAlgorithm(algorithm) {\n        if (typeof algorithm === \"string\") {\n            return {\n                name: algorithm,\n            };\n        }\n        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {\n            const preparedAlgorithm = { ...algorithm };\n            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);\n            return preparedAlgorithm;\n        }\n        return { ...algorithm };\n    }\n    getProvider(name) {\n        const provider = this.providers.get(name);\n        if (!provider) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n        return provider;\n    }\n    checkCryptoKey(key) {\n        if (!(key instanceof CryptoKey)) {\n            throw new TypeError(`Key is not of type 'CryptoKey'`);\n        }\n    }\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  converters: index$3\n});\n\nconst REQUIRED_FIELDS = [\"crv\", \"e\", \"k\", \"kty\", \"n\", \"x\", \"y\"];\nclass JwkUtils {\n    static async thumbprint(hash, jwk, crypto) {\n        const data = this.format(jwk, true);\n        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));\n    }\n    static format(jwk, remove = false) {\n        let res = Object.entries(jwk);\n        if (remove) {\n            res = res.filter(o => REQUIRED_FIELDS.includes(o[0]));\n        }\n        res = res.sort(([keyA], [keyB]) => keyA > keyB ? 1 : keyA < keyB ? -1 : 0);\n        return Object.fromEntries(res);\n    }\n}\n\nObject.defineProperty(exports, \"BufferSourceConverter\", ({\n  enumerable: true,\n  get: function () { return pvtsutils.BufferSourceConverter; }\n}));\nexports.AesCbcProvider = AesCbcProvider;\nexports.AesCmacProvider = AesCmacProvider;\nexports.AesCtrProvider = AesCtrProvider;\nexports.AesEcbProvider = AesEcbProvider;\nexports.AesGcmProvider = AesGcmProvider;\nexports.AesKwProvider = AesKwProvider;\nexports.AesProvider = AesProvider;\nexports.AlgorithmError = AlgorithmError;\nexports.Crypto = Crypto;\nexports.CryptoError = CryptoError;\nexports.CryptoKey = CryptoKey;\nexports.DesProvider = DesProvider;\nexports.EcCurves = EcCurves;\nexports.EcUtils = EcUtils;\nexports.EcdhEsProvider = EcdhEsProvider;\nexports.EcdhProvider = EcdhProvider;\nexports.EcdsaProvider = EcdsaProvider;\nexports.EdDsaProvider = EdDsaProvider;\nexports.EllipticProvider = EllipticProvider;\nexports.HkdfProvider = HkdfProvider;\nexports.HmacProvider = HmacProvider;\nexports.JwkUtils = JwkUtils;\nexports.OperationError = OperationError;\nexports.Pbkdf2Provider = Pbkdf2Provider;\nexports.PemConverter = PemConverter;\nexports.ProviderCrypto = ProviderCrypto;\nexports.ProviderStorage = ProviderStorage;\nexports.RequiredPropertyError = RequiredPropertyError;\nexports.RsaOaepProvider = RsaOaepProvider;\nexports.RsaProvider = RsaProvider;\nexports.RsaPssProvider = RsaPssProvider;\nexports.RsaSsaProvider = RsaSsaProvider;\nexports.Shake128Provider = Shake128Provider;\nexports.Shake256Provider = Shake256Provider;\nexports.ShakeProvider = ShakeProvider;\nexports.SubtleCrypto = SubtleCrypto;\nexports.UnsupportedOperationError = UnsupportedOperationError;\nexports.asn1 = index$1;\nexports.isJWK = isJWK;\nexports.json = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYmNyeXB0by1jb3JlL2J1aWxkL3dlYmNyeXB0by1jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBVztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDaEQsWUFBWSxtQkFBTyxDQUFDLDBEQUFPO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNoRCxXQUFXLG1CQUFPLENBQUMsOERBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQixXQUFXLE9BQU87QUFDMUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLGdCQUFnQixFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxTQUFTLGdCQUFnQixhQUFhLGFBQWE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMEJBQTBCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEI7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBZ0Q7QUFDekU7QUFDQTtBQUNBLHlCQUF5QixzQ0FBc0M7QUFD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b0JBQW9CLDJDQUEyQztBQUMvRCxvQkFBb0IsMkNBQTJDO0FBQy9ELG9CQUFvQiwyQ0FBMkM7QUFDL0Qsb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNuQixzQkFBc0I7QUFDdEIsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGlDQUFpQztBQUNqQyxZQUFZO0FBQ1osYUFBYTtBQUNiLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWJibGVndW0vLi4vLi4vbm9kZV9tb2R1bGVzL3dlYmNyeXB0by1jb3JlL2J1aWxkL3dlYmNyeXB0by1jb3JlLmpzP2Y1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gQ29weXJpZ2h0IChjKSBQZWN1bGlhciBWZW50dXJlcywgTExDXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBhc24xU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2FzbjEtc2NoZW1hJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzb25TY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvanNvbi1zY2hlbWEnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMWpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGFzbjFfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoYXNuMSk7XG5cbmNsYXNzIENyeXB0b0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBBbGdvcml0aG1FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbn1cblxuY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7bWV0aG9kTmFtZSA/IGAke21ldGhvZE5hbWV9YCA6IFwiXCJ9YCk7XG4gICAgfVxufVxuXG5jbGFzcyBPcGVyYXRpb25FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbn1cblxuY2xhc3MgUmVxdWlyZWRQcm9wZXJ0eUVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BOYW1lKSB7XG4gICAgICAgIHN1cGVyKGAke3Byb3BOYW1lfTogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eWApO1xuICAgIH1cbn1cblxuY2xhc3MgUGVtQ29udmVydGVyIHtcbiAgICBzdGF0aWMgdG9BcnJheUJ1ZmZlcihwZW0pIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gcGVtXG4gICAgICAgICAgICAucmVwbGFjZSgvLXs1fShCRUdJTnxFTkQpIC4qLXs1fS9nLCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCJcXHJcIiwgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKFwiXFxuXCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NChiYXNlNjQpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9VaW50OEFycmF5KHBlbSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMudG9BcnJheUJ1ZmZlcihwZW0pO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlclNvdXJjZShidWZmZXIsIHRhZykge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChidWZmZXIpO1xuICAgICAgICBsZXQgc2xpY2VkO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc2xpY2VkID0gYmFzZTY0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ID0gb2Zmc2V0ICsgNjQpO1xuICAgICAgICAgICAgaWYgKHNsaWNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goc2xpY2VkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYC0tLS0tQkVHSU4gJHt1cHBlckNhc2VUYWd9LS0tLS1cXG4ke3Jvd3Muam9pbihcIlxcblwiKX1cXG4tLS0tLUVORCAke3VwcGVyQ2FzZVRhZ30tLS0tLWA7XG4gICAgfVxuICAgIHN0YXRpYyBpc1BFTShkYXRhKSB7XG4gICAgICAgIHJldHVybiAvLS0tLS1CRUdJTiAuKy0tLS0tW0EtWmEtejAtOStcXC9cXCtcXD1cXHNcXG5dKy0tLS0tRU5EIC4rLS0tLS0vaS50ZXN0KGRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VGFnTmFtZShwZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUEVNKHBlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBwYXJhbWV0ZXIuIEluY29taW5nIGRhdGEgaXMgbm90IHJpZ2h0IFBFTVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSAvLS0tLS1CRUdJTiAoLispLS0tLS0vLmV4ZWMocGVtKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGFnIGZyb20gUEVNXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNbMV07XG4gICAgfVxuICAgIHN0YXRpYyBoYXNUYWdOYW1lKHBlbSwgdGFnTmFtZSkge1xuICAgICAgICBjb25zdCB0YWcgPSB0aGlzLmdldFRhZ05hbWUocGVtKTtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NlcnRpZmljYXRlKHBlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWdOYW1lKHBlbSwgXCJjZXJ0aWZpY2F0ZVwiKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ2VydGlmaWNhdGVSZXF1ZXN0KHBlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWdOYW1lKHBlbSwgXCJjZXJ0aWZpY2F0ZSByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDUkwocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcIng1MDkgY3JsXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQdWJsaWNLZXkocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcInB1YmxpYyBrZXlcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0pXSyhkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwia3R5XCIgaW4gZGF0YTtcbn1cblxuY2xhc3MgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGFzeW5jIGRpZ2VzdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRGlnZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0RpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGlnZXN0XCIpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25HZW5lcmF0ZUtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIGlmICghKGtleVVzYWdlcyAmJiBrZXlVc2FnZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVXNhZ2VzIGNhbm5vdCBiZSBlbXB0eSB3aGVuIGNyZWF0aW5nIGEga2V5LmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbGxvd2VkVXNhZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnVzYWdlcykpIHtcbiAgICAgICAgICAgIGFsbG93ZWRVc2FnZXMgPSB0aGlzLnVzYWdlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbG93ZWRVc2FnZXMgPSB0aGlzLnVzYWdlcy5wcml2YXRlS2V5LmNvbmNhdCh0aGlzLnVzYWdlcy5wdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzLCBhbGxvd2VkVXNhZ2VzKTtcbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJnZW5lcmF0ZUtleVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vblNpZ24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBcInNpZ25cIik7XG4gICAgfVxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSwgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcInNpZ25cIik7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWZXJpZnkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uVmVyaWZ5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja1ZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIFwidmVyaWZ5XCIpO1xuICAgIH1cbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwidmVyaWZ5XCIpO1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0VuY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRW5jcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tFbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhLCBvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZW5jcnlwdFwiIDogdm9pZCAwKTtcbiAgICB9XG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZW5jcnlwdFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkRlY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSwgb3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIG9wdGlvbnMua2V5VXNhZ2UgPyBcImRlY3J5cHRcIiA6IHZvaWQgMCk7XG4gICAgfVxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSwgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImRlY3J5cHRcIik7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUJpdHMoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRGVyaXZlQml0cy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25EZXJpdmVCaXRzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0Rlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgsIG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoYmFzZUtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZGVyaXZlQml0c1wiIDogdm9pZCAwKTtcbiAgICAgICAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogSXMgbm90IG11bHRpcGxlIG9mIDhcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGVyaXZlQml0c1wiKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0V4cG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25FeHBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRXhwb3J0S2V5KGZvcm1hdCwga2V5LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBpZiAoIWtleS5leHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKFwia2V5OiBJcyBub3QgZXh0cmFjdGFibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJleHBvcnRLZXlcIik7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbXBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uSW1wb3J0S2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrS2V5Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlEYXRhKGZvcm1hdCwga2V5RGF0YSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy51c2FnZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrS2V5VXNhZ2VzKGtleVVzYWdlcywgdGhpcy51c2FnZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiaW1wb3J0S2V5XCIpO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKFwiVW5yZWNvZ25pemVkIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICB9XG4gICAgY2hlY2tLZXlVc2FnZXModXNhZ2VzLCBhbGxvd2VkKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXNhZ2Ugb2YgdXNhZ2VzKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZC5pbmRleE9mKHVzYWdlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGtleSB1c2luZyB0aGUgc3BlY2lmaWVkIGtleSB1c2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKGtleVVzYWdlICYmIGtleS51c2FnZXMuaW5kZXhPZihrZXlVc2FnZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvRXJyb3IoYGtleSBkb2VzIG5vdCBtYXRjaCB0aGF0IG9mIG9wZXJhdGlvbmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrUmVxdWlyZWRQcm9wZXJ0eShkYXRhLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkUHJvcGVydHlFcnJvcihwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobSwgaGFzaEFsZ29yaXRobXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGhhc2hBbGdvcml0aG1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSBhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgaGFzaDogTXVzdCBiZSBvbmUgb2YgJHtoYXNoQWxnb3JpdGhtcy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSkge1xuICAgIH1cbiAgICBjaGVja0tleUZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOlxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZvcm1hdDogSXMgaW52YWxpZCB2YWx1ZS4gTXVzdCBiZSAnandrJywgJ3JhdycsICdzcGtpJywgb3IgJ3BrY3M4J1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0tleURhdGEoZm9ybWF0LCBrZXlEYXRhKSB7XG4gICAgICAgIGlmICgha2V5RGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IENhbm5vdCBiZSBlbXB0eSBvbiBlbXB0eSBvbiBrZXkgaW1wb3J0aW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNKV0soa2V5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogSXMgbm90IEpzb25XZWJUb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShrZXlEYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IElzIG5vdCBBcnJheUJ1ZmZlclZpZXcgb3IgQXJyYXlCdWZmZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZURhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgIH1cbn1cblxuY2xhc3MgQWVzUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3Qgb2YgdHlwZSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgICAgIGNhc2UgMTkyOlxuICAgICAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IE11c3QgYmUgMTI4LCAxOTIsIG9yIDI1NlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Rlcml2ZWRLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pO1xuICAgIH1cbn1cblxuY2xhc3MgQWVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUNCQ1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdlwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLml2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5pdikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5pdi5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBNdXN0IGhhdmUgbGVuZ3RoIDE2IGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBZXNDbWFjUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUNNQUNcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJzaWduXCIsIFwidmVyaWZ5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJsZW5ndGg6IE11c3QgYmUgbW9yZSB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0N0clByb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1DVFJcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiY291bnRlclwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLmNvdW50ZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLmNvdW50ZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvdW50ZXI6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5jb3VudGVyLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IE11c3QgaGF2ZSBsZW5ndGggMTYgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJsZW5ndGg6IE11c3QgYmUgbW9yZSB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0VjYlByb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1FQ0JcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxufVxuXG5jbGFzcyBBZXNHY21Qcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtR0NNXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml2XCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uaXYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLml2KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLml2LmJ5dGVMZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJpdjogTXVzdCBoYXZlIGxlbmd0aCBtb3JlIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDJeNjQgLSAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKFwidGFnTGVuZ3RoXCIgaW4gYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgYWxnb3JpdGhtLnRhZ0xlbmd0aCA9IDEyODtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS50YWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgICAgIGNhc2UgMTA0OlxuICAgICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJ0YWdMZW5ndGg6IE11c3QgYmUgb25lIG9mIDMyLCA2NCwgOTYsIDEwNCwgMTEyLCAxMjAgb3IgMTI4XCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBZXNLd1Byb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1LV1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxufVxuXG5jbGFzcyBEZXNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAodGhpcy5pdlNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdlwiKTtcbiAgICAgICAgICAgIGlmICghKGFsZ29yaXRobS5pdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uaXYpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGdvcml0aG0uaXYuYnl0ZUxlbmd0aCAhPT0gdGhpcy5pdlNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpdjogTXVzdCBoYXZlIGxlbmd0aCAke3RoaXMuaXZTaXplfSBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJsZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IG9mIHR5cGUgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGVuZ3RoICE9PSB0aGlzLmtleVNpemVCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYGFsZ29yaXRobS5sZW5ndGg6IE11c3QgYmUgJHt0aGlzLmtleVNpemVCaXRzfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgfVxufVxuXG5jbGFzcyBSc2FQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwicHVibGljRXhwb25lbnRcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCAmJiBhbGdvcml0aG0ucHVibGljRXhwb25lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNaXNzaW5nIG9yIG5vdCBhIFVpbnQ4QXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChhbGdvcml0aG0ucHVibGljRXhwb25lbnQpO1xuICAgICAgICBpZiAoIShwdWJsaWNFeHBvbmVudCA9PT0gXCJBdz09XCIgfHwgcHVibGljRXhwb25lbnQgPT09IFwiQVFBQlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNdXN0IGJlIFszXSBvciBbMSwwLDFdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJtb2R1bHVzTGVuZ3RoXCIpO1xuICAgICAgICBpZiAoYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggJSA4XG4gICAgICAgICAgICB8fCBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA8IDI1NlxuICAgICAgICAgICAgfHwgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPiAxNjM4NCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBtb2R1bHVzIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOCBiaXRzIGFuZCA+PSAyNTYgYW5kIDw9IDE2Mzg0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgIH1cbn1cblxuY2xhc3MgUnNhU3NhUHJvdmlkZXIgZXh0ZW5kcyBSc2FQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBU1NBLVBLQ1MxLXYxXzVcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBSc2FQc3NQcm92aWRlciBleHRlbmRzIFJzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0EtUFNTXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wic2lnblwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1widmVyaWZ5XCJdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInNhbHRMZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLnNhbHRMZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0TGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5zYWx0TGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzYWx0TGVuZ3RoOiBNdXN0IGJlIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUnNhT2FlcFByb3ZpZGVyIGV4dGVuZHMgUnNhUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQS1PQUVQXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1wiZW5jcnlwdFwiLCBcIndyYXBLZXlcIl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAoYWxnb3JpdGhtLmxhYmVsXG4gICAgICAgICAgICAmJiAhKGFsZ29yaXRobS5sYWJlbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0ubGFiZWwpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxhYmVsOiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBFbGxpcHRpY1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJuYW1lZEN1cnZlXCIpO1xuICAgICAgICB0aGlzLmNoZWNrTmFtZWRDdXJ2ZShhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XG4gICAgfVxuICAgIGNoZWNrTmFtZWRDdXJ2ZShuYW1lZEN1cnZlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm5hbWVkQ3VydmVzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSBuYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBuYW1lZEN1cnZlOiBNdXN0IGJlIG9uZSBvZiAke3RoaXMubmFtZWRDdXJ2ZXMuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cblxuY2xhc3MgRWNkc2FQcm92aWRlciBleHRlbmRzIEVsbGlwdGljUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVDRFNBXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJQLTI1NlwiLCBcIlAtMzg0XCIsIFwiUC01MjFcIiwgXCJLLTI1NlwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgfVxufVxuXG5jb25zdCBLRVlfVFlQRVMgPSBbXCJzZWNyZXRcIiwgXCJwcml2YXRlXCIsIFwicHVibGljXCJdO1xuY2xhc3MgQ3J5cHRvS2V5IHtcbiAgICBzdGF0aWMgY3JlYXRlKGFsZ29yaXRobSwgdHlwZSwgZXh0cmFjdGFibGUsIHVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgdGhpcygpO1xuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICBrZXkudHlwZSA9IHR5cGU7XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0gdXNhZ2VzO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBzdGF0aWMgaXNLZXlUeXBlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEtFWV9UWVBFUy5pbmRleE9mKGRhdGEpICE9PSAtMTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJDcnlwdG9LZXlcIjtcbiAgICB9XG59XG5cbmNsYXNzIEVjZGhQcm92aWRlciBleHRlbmRzIEVsbGlwdGljUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVDREhcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJkZXJpdmVCaXRzXCIsIFwiZGVyaXZlS2V5XCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIlAtMjU2XCIsIFwiUC0zODRcIiwgXCJQLTUyMVwiLCBcIkstMjU2XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInB1YmxpY1wiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnB1YmxpYyBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWM6IElzIG5vdCBhIENyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLnB1YmxpYy50eXBlICE9PSBcInB1YmxpY1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJwdWJsaWM6IElzIG5vdCBhIHB1YmxpYyBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5wdWJsaWMuYWxnb3JpdGhtLm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBwdWJsaWM6IElzIG5vdCAke3RoaXMubmFtZX0ga2V5YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEVjZGhFc1Byb3ZpZGVyIGV4dGVuZHMgRWNkaFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJFQ0RILUVTXCI7XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJYMjU1MTlcIiwgXCJYNDQ4XCJdO1xuICAgIH1cbn1cblxuY2xhc3MgRWREc2FQcm92aWRlciBleHRlbmRzIEVsbGlwdGljUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVkRFNBXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wic2lnblwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1widmVyaWZ5XCJdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gW1wiRWQyNTUxOVwiLCBcIkVkNDQ4XCJdO1xuICAgIH1cbn1cblxubGV0IE9iamVjdElkZW50aWZpZXIgPSBjbGFzcyBPYmplY3RJZGVudGlmaWVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyIH0pXG5dLCBPYmplY3RJZGVudGlmaWVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuT2JqZWN0SWRlbnRpZmllciA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgT2JqZWN0SWRlbnRpZmllcik7XG5cbmNsYXNzIEFsZ29yaXRobUlkZW50aWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtcyk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHtcbiAgICAgICAgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2JqZWN0SWRlbnRpZmllcixcbiAgICB9KVxuXSwgQWxnb3JpdGhtSWRlbnRpZmllci5wcm90b3R5cGUsIFwiYWxnb3JpdGhtXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3Aoe1xuICAgICAgICB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5BbnksXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIH0pXG5dLCBBbGdvcml0aG1JZGVudGlmaWVyLnByb3RvdHlwZSwgXCJwYXJhbWV0ZXJzXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFByaXZhdGVLZXlJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5QWxnb3JpdGhtID0gbmV3IEFsZ29yaXRobUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBBbGdvcml0aG1JZGVudGlmaWVyIH0pXG5dLCBQcml2YXRlS2V5SW5mby5wcm90b3R5cGUsIFwicHJpdmF0ZUtleUFsZ29yaXRobVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJwcml2YXRlS2V5XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5BbnksIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQcml2YXRlS2V5SW5mby5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiLCB2b2lkIDApO1xuXG5jbGFzcyBQdWJsaWNLZXlJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXlBbGdvcml0aG0gPSBuZXcgQWxnb3JpdGhtSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBBbGdvcml0aG1JZGVudGlmaWVyIH0pXG5dLCBQdWJsaWNLZXlJbmZvLnByb3RvdHlwZSwgXCJwdWJsaWNLZXlBbGdvcml0aG1cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZyB9KVxuXSwgUHVibGljS2V5SW5mby5wcm90b3R5cGUsIFwicHVibGljS2V5XCIsIHZvaWQgMCk7XG5cbmNvbnN0IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKHZhbHVlKSxcbiAgICB0b0pTT046ICh2YWx1ZSkgPT4gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwobmV3IFVpbnQ4QXJyYXkodmFsdWUpKSxcbn07XG5cbmNvbnN0IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVIZXggPSB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICByZXR1cm4gIShuZXcgVWludDhBcnJheSh2YWx1ZUhleClbMF0pXG4gICAgICAgICAgICA/IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXguc2xpY2UoMSlcbiAgICAgICAgICAgIDogdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICB9LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVIZXggPSBuZXcgVWludDhBcnJheSh2YWx1ZSlbMF0gPiAxMjdcbiAgICAgICAgICAgID8gcHZ0c3V0aWxzLmNvbWJpbmUobmV3IFVpbnQ4QXJyYXkoWzBdKS5idWZmZXIsIHZhbHVlKVxuICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xX19uYW1lc3BhY2UuSW50ZWdlcih7IHZhbHVlSGV4IH0pO1xuICAgIH0sXG59O1xuXG52YXIgaW5kZXgkMyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlcixcbiAgSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXJcbn0pO1xuXG5jbGFzcyBSc2FQcml2YXRlS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5tb2R1bHVzID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnB1YmxpY0V4cG9uZW50ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnByaXZhdGVFeHBvbmVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wcmltZTEgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHJpbWUyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLmV4cG9uZW50MSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5leHBvbmVudDIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMuY29lZmZpY2llbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBhc24xU2NoZW1hLkFzbkludGVnZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcIm5cIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcIm1vZHVsdXNcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImVcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInB1YmxpY0V4cG9uZW50XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJkXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwcml2YXRlRXhwb25lbnRcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcInBcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaW1lMVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwicVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpbWUyXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJkcFwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiZXhwb25lbnQxXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJkcVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiZXhwb25lbnQyXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJxaVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiY29lZmZpY2llbnRcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcIm90aGVyUHJpbWVJbmZvc1wiLCB2b2lkIDApO1xuXG5jbGFzcyBSc2FQdWJsaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZHVsdXMgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHVibGljRXhwb25lbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiblwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHVibGljS2V5LnByb3RvdHlwZSwgXCJtb2R1bHVzXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJlXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQdWJsaWNLZXkucHJvdG90eXBlLCBcInB1YmxpY0V4cG9uZW50XCIsIHZvaWQgMCk7XG5cbmxldCBFY1B1YmxpY0tleSA9IGNsYXNzIEVjUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAoYnl0ZXNbMF0gIT09IDB4MDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9FcnJvcihcIldyb25nIEVDUG9pbnQuIEN1cnJlbnQgdmVyc2lvbiBzdXBwb3J0cyBvbmx5IFVuY29tcHJlc3NlZCAoMHgwNCkgcG9pbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJ5dGVzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChieXRlcy5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKSksXG4gICAgICAgICAgICB5OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChieXRlcy5idWZmZXIuc2xpY2Uob2Zmc2V0ICsgc2l6ZSwgb2Zmc2V0ICsgc2l6ZSArIHNpemUpKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCEoXCJ4XCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIng6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJ5XCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInk6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcbiAgICAgICAgY29uc3QgeSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi55KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwdnRzdXRpbHMuY29tYmluZShuZXcgVWludDhBcnJheShbMHgwNF0pLmJ1ZmZlciwgeCwgeSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgVWludDhBcnJheSh2YWx1ZSkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIEVjUHVibGljS2V5LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuRWNQdWJsaWNLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEVjUHVibGljS2V5KTtcblxuY2xhc3MgRWNQcml2YXRlS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghKFwiZFwiIGluIGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkOiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi5kKTtcbiAgICAgICAgaWYgKFwieFwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xuICAgICAgICAgICAgcHVibGljS2V5LmZyb21KU09OKGpzb24pO1xuICAgICAgICAgICAgY29uc3QgYXNuID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnRvQVNOKHB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAoXCJ2YWx1ZUhleFwiIGluIGFzbi52YWx1ZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqd2sgPSB7fTtcbiAgICAgICAgandrLmQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oandrLCBuZXcgRWNQdWJsaWNLZXkodGhpcy5wdWJsaWNLZXkpLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gandrO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogYXNuMVNjaGVtYS5Bc25JbnRlZ2VyQ29udmVydGVyIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaXZhdGVLZXlcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IGNvbnRleHQ6IDAsIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicGFyYW1ldGVyc1wiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgY29udGV4dDogMSwgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nLCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRWNQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwgdm9pZCAwKTtcblxuY29uc3QgQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXgpO1xuICAgICAgICByZXR1cm4gKGJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgPyBieXRlcy5idWZmZXIuc2xpY2UoMSlcbiAgICAgICAgICAgIDogYnl0ZXMuYnVmZmVyO1xuICAgIH0sXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKGJ5dGVzWzBdID4gMTI3KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgbmV3VmFsdWUuc2V0KGJ5dGVzLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMV9fbmFtZXNwYWNlLkludGVnZXIoeyB2YWx1ZUhleDogbmV3VmFsdWUuYnVmZmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgYXNuMV9fbmFtZXNwYWNlLkludGVnZXIoeyB2YWx1ZUhleDogdmFsdWUgfSk7XG4gICAgfSxcbn07XG5cbnZhciBpbmRleCQyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlcjogQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyXG59KTtcblxuY2xhc3MgRWNVdGlscyB7XG4gICAgc3RhdGljIGRlY29kZVBvaW50KGRhdGEsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIGlmICgodmlldy5sZW5ndGggPT09IDApIHx8ICh2aWV3WzBdICE9PSA0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB1bmNvbXByZXNzZWQgcG9pbnQgZm9ybWF0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gKHZpZXcubGVuZ3RoIC0gMSkgLyAyO1xuICAgICAgICBpZiAobiAhPT0gKE1hdGguY2VpbChwb2ludFNpemUgLyA4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvaW50IGRvZXMgbm90IG1hdGNoIGZpZWxkIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeGIgPSB2aWV3LnNsaWNlKDEsIG4gKyAxKTtcbiAgICAgICAgY29uc3QgeWIgPSB2aWV3LnNsaWNlKG4gKyAxLCBuICsgMSArIG4pO1xuICAgICAgICByZXR1cm4geyB4OiB4YiwgeTogeWIgfTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVBvaW50KHBvaW50LCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguY2VpbChwb2ludFNpemUgLyA4KTtcbiAgICAgICAgaWYgKHBvaW50LnguYnl0ZUxlbmd0aCAhPT0gc2l6ZSB8fCBwb2ludC55LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlgsWSBjb29yZGluYXRlcyBkb24ndCBtYXRjaCBwb2ludCBzaXplIGNyaXRlcmlhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwb2ludC54KTtcbiAgICAgICAgY29uc3QgeSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBvaW50LnkpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzaXplICogMiArIDEpO1xuICAgICAgICByZXNbMF0gPSA0O1xuICAgICAgICByZXMuc2V0KHgsIDEpO1xuICAgICAgICByZXMuc2V0KHksIHNpemUgKyAxKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGdldFNpemUocG9pbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocG9pbnRTaXplIC8gOCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVTaWduYXR1cmUoc2lnbmF0dXJlLCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZShwb2ludFNpemUpO1xuICAgICAgICBjb25zdCByID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoc2lnbmF0dXJlLnIpO1xuICAgICAgICBjb25zdCBzID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoc2lnbmF0dXJlLnMpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzaXplICogMik7XG4gICAgICAgIHJlcy5zZXQodGhpcy5wYWRTdGFydChyLCBzaXplKSk7XG4gICAgICAgIHJlcy5zZXQodGhpcy5wYWRTdGFydChzLCBzaXplKSwgc2l6ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGVTaWduYXR1cmUoZGF0YSwgcG9pbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUocG9pbnRTaXplKTtcbiAgICAgICAgY29uc3QgdmlldyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBpZiAodmlldy5sZW5ndGggIT09IChzaXplICogMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBzaXplIG9mIHRoZSBzaWduYXR1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHZpZXcuc2xpY2UoMCwgc2l6ZSk7XG4gICAgICAgIGNvbnN0IHMgPSB2aWV3LnNsaWNlKHNpemUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogdGhpcy50cmltU3RhcnQociksXG4gICAgICAgICAgICBzOiB0aGlzLnRyaW1TdGFydChzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHRyaW1TdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKChpIDwgZGF0YS5sZW5ndGggLSAxKSAmJiAoZGF0YVtpXSA9PT0gMCkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoaSwgZGF0YS5sZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFkU3RhcnQoZGF0YSwgc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICByZXMuc2V0KGRhdGEsIHNpemUgLSBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG5jbGFzcyBFY0RzYVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5zID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVdlYkNyeXB0b1NpZ25hdHVyZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBwb2ludFNpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBFY1V0aWxzLmRlY29kZVNpZ25hdHVyZSh2YWx1ZSwgcG9pbnRTaXplICogOCk7XG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gbmV3IEVjRHNhU2lnbmF0dXJlKCk7XG4gICAgICAgIGVjU2lnbmF0dXJlLnIgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocG9pbnQucik7XG4gICAgICAgIGVjU2lnbmF0dXJlLnMgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocG9pbnQucyk7XG4gICAgICAgIHJldHVybiBlY1NpZ25hdHVyZTtcbiAgICB9XG4gICAgdG9XZWJDcnlwdG9TaWduYXR1cmUocG9pbnRTaXplKSB7XG4gICAgICAgIHBvaW50U2l6ZSAhPT0gbnVsbCAmJiBwb2ludFNpemUgIT09IHZvaWQgMCA/IHBvaW50U2l6ZSA6IChwb2ludFNpemUgPSBNYXRoLm1heCh0aGlzLnIuYnl0ZUxlbmd0aCwgdGhpcy5zLmJ5dGVMZW5ndGgpICogOCk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IEVjVXRpbHMuZW5jb2RlU2lnbmF0dXJlKHRoaXMsIHBvaW50U2l6ZSk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmUuYnVmZmVyO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyIH0pXG5dLCBFY0RzYVNpZ25hdHVyZS5wcm90b3R5cGUsIFwiclwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIgfSlcbl0sIEVjRHNhU2lnbmF0dXJlLnByb3RvdHlwZSwgXCJzXCIsIHZvaWQgMCk7XG5cbmNsYXNzIE9uZUFzeW1tZXRyaWNLZXkgZXh0ZW5kcyBQcml2YXRlS2V5SW5mbyB7XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyBjb250ZXh0OiAxLCBpbXBsaWNpdDogdHJ1ZSwgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nLCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT25lQXN5bW1ldHJpY0tleS5wcm90b3R5cGUsIFwicHVibGljS2V5XCIsIHZvaWQgMCk7XG5cbmxldCBFZFByaXZhdGVLZXkgPSBjbGFzcyBFZFByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbi5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkOiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24uZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGp3ayA9IHtcbiAgICAgICAgICAgIGQ6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKHRoaXMudmFsdWUpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gandrO1xuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgRWRQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuRWRQcml2YXRlS2V5ID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBFZFByaXZhdGVLZXkpO1xuXG5sZXQgRWRQdWJsaWNLZXkgPSBjbGFzcyBFZFB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghKFwieFwiIGluIGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4OiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcgfSlcbl0sIEVkUHVibGljS2V5LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuRWRQdWJsaWNLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEVkUHVibGljS2V5KTtcblxubGV0IEN1cnZlUHJpdmF0ZUtleSA9IGNsYXNzIEN1cnZlUHJpdmF0ZUtleSB7XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBDdXJ2ZVByaXZhdGVLZXkucHJvdG90eXBlLCBcImRcIiwgdm9pZCAwKTtcbkN1cnZlUHJpdmF0ZUtleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgQ3VydmVQcml2YXRlS2V5KTtcblxuY29uc3QgaWRTZWNwMjU2cjEgPSBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIjtcbmNvbnN0IGlkRWxsaXB0aWNDdXJ2ZSA9IFwiMS4zLjEzMi4wXCI7XG5jb25zdCBpZFNlY3AzODRyMSA9IGAke2lkRWxsaXB0aWNDdXJ2ZX0uMzRgO1xuY29uc3QgaWRTZWNwNTIxcjEgPSBgJHtpZEVsbGlwdGljQ3VydmV9LjM1YDtcbmNvbnN0IGlkU2VjcDI1NmsxID0gYCR7aWRFbGxpcHRpY0N1cnZlfS4xMGA7XG5jb25zdCBpZFZlcnNpb25PbmUgPSBcIjEuMy4zNi4zLjMuMi44LjEuMVwiO1xuY29uc3QgaWRCcmFpbnBvb2xQMTYwcjEgPSBgJHtpZFZlcnNpb25PbmV9LjFgO1xuY29uc3QgaWRCcmFpbnBvb2xQMTYwdDEgPSBgJHtpZFZlcnNpb25PbmV9LjJgO1xuY29uc3QgaWRCcmFpbnBvb2xQMTkycjEgPSBgJHtpZFZlcnNpb25PbmV9LjNgO1xuY29uc3QgaWRCcmFpbnBvb2xQMTkydDEgPSBgJHtpZFZlcnNpb25PbmV9LjRgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjI0cjEgPSBgJHtpZFZlcnNpb25PbmV9LjVgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjI0dDEgPSBgJHtpZFZlcnNpb25PbmV9LjZgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjU2cjEgPSBgJHtpZFZlcnNpb25PbmV9LjdgO1xuY29uc3QgaWRCcmFpbnBvb2xQMjU2dDEgPSBgJHtpZFZlcnNpb25PbmV9LjhgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzIwcjEgPSBgJHtpZFZlcnNpb25PbmV9LjlgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzIwdDEgPSBgJHtpZFZlcnNpb25PbmV9LjEwYDtcbmNvbnN0IGlkQnJhaW5wb29sUDM4NHIxID0gYCR7aWRWZXJzaW9uT25lfS4xMWA7XG5jb25zdCBpZEJyYWlucG9vbFAzODR0MSA9IGAke2lkVmVyc2lvbk9uZX0uMTJgO1xuY29uc3QgaWRCcmFpbnBvb2xQNTEycjEgPSBgJHtpZFZlcnNpb25PbmV9LjEzYDtcbmNvbnN0IGlkQnJhaW5wb29sUDUxMnQxID0gYCR7aWRWZXJzaW9uT25lfS4xNGA7XG5jb25zdCBpZFgyNTUxOSA9IFwiMS4zLjEwMS4xMTBcIjtcbmNvbnN0IGlkWDQ0OCA9IFwiMS4zLjEwMS4xMTFcIjtcbmNvbnN0IGlkRWQyNTUxOSA9IFwiMS4zLjEwMS4xMTJcIjtcbmNvbnN0IGlkRWQ0NDggPSBcIjEuMy4xMDEuMTEzXCI7XG5cbnZhciBpbmRleCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFsZ29yaXRobUlkZW50aWZpZXI6IEFsZ29yaXRobUlkZW50aWZpZXIsXG4gIGdldCBDdXJ2ZVByaXZhdGVLZXkgKCkgeyByZXR1cm4gQ3VydmVQcml2YXRlS2V5OyB9LFxuICBFY0RzYVNpZ25hdHVyZTogRWNEc2FTaWduYXR1cmUsXG4gIEVjUHJpdmF0ZUtleTogRWNQcml2YXRlS2V5LFxuICBnZXQgRWNQdWJsaWNLZXkgKCkgeyByZXR1cm4gRWNQdWJsaWNLZXk7IH0sXG4gIGdldCBFZFByaXZhdGVLZXkgKCkgeyByZXR1cm4gRWRQcml2YXRlS2V5OyB9LFxuICBnZXQgRWRQdWJsaWNLZXkgKCkgeyByZXR1cm4gRWRQdWJsaWNLZXk7IH0sXG4gIGdldCBPYmplY3RJZGVudGlmaWVyICgpIHsgcmV0dXJuIE9iamVjdElkZW50aWZpZXI7IH0sXG4gIE9uZUFzeW1tZXRyaWNLZXk6IE9uZUFzeW1tZXRyaWNLZXksXG4gIFByaXZhdGVLZXlJbmZvOiBQcml2YXRlS2V5SW5mbyxcbiAgUHVibGljS2V5SW5mbzogUHVibGljS2V5SW5mbyxcbiAgUnNhUHJpdmF0ZUtleTogUnNhUHJpdmF0ZUtleSxcbiAgUnNhUHVibGljS2V5OiBSc2FQdWJsaWNLZXksXG4gIGNvbnZlcnRlcnM6IGluZGV4JDIsXG4gIGlkQnJhaW5wb29sUDE2MHIxOiBpZEJyYWlucG9vbFAxNjByMSxcbiAgaWRCcmFpbnBvb2xQMTYwdDE6IGlkQnJhaW5wb29sUDE2MHQxLFxuICBpZEJyYWlucG9vbFAxOTJyMTogaWRCcmFpbnBvb2xQMTkycjEsXG4gIGlkQnJhaW5wb29sUDE5MnQxOiBpZEJyYWlucG9vbFAxOTJ0MSxcbiAgaWRCcmFpbnBvb2xQMjI0cjE6IGlkQnJhaW5wb29sUDIyNHIxLFxuICBpZEJyYWlucG9vbFAyMjR0MTogaWRCcmFpbnBvb2xQMjI0dDEsXG4gIGlkQnJhaW5wb29sUDI1NnIxOiBpZEJyYWlucG9vbFAyNTZyMSxcbiAgaWRCcmFpbnBvb2xQMjU2dDE6IGlkQnJhaW5wb29sUDI1NnQxLFxuICBpZEJyYWlucG9vbFAzMjByMTogaWRCcmFpbnBvb2xQMzIwcjEsXG4gIGlkQnJhaW5wb29sUDMyMHQxOiBpZEJyYWlucG9vbFAzMjB0MSxcbiAgaWRCcmFpbnBvb2xQMzg0cjE6IGlkQnJhaW5wb29sUDM4NHIxLFxuICBpZEJyYWlucG9vbFAzODR0MTogaWRCcmFpbnBvb2xQMzg0dDEsXG4gIGlkQnJhaW5wb29sUDUxMnIxOiBpZEJyYWlucG9vbFA1MTJyMSxcbiAgaWRCcmFpbnBvb2xQNTEydDE6IGlkQnJhaW5wb29sUDUxMnQxLFxuICBpZEVkMjU1MTk6IGlkRWQyNTUxOSxcbiAgaWRFZDQ0ODogaWRFZDQ0OCxcbiAgaWRFbGxpcHRpY0N1cnZlOiBpZEVsbGlwdGljQ3VydmUsXG4gIGlkU2VjcDI1NmsxOiBpZFNlY3AyNTZrMSxcbiAgaWRTZWNwMjU2cjE6IGlkU2VjcDI1NnIxLFxuICBpZFNlY3AzODRyMTogaWRTZWNwMzg0cjEsXG4gIGlkU2VjcDUyMXIxOiBpZFNlY3A1MjFyMSxcbiAgaWRWZXJzaW9uT25lOiBpZFZlcnNpb25PbmUsXG4gIGlkWDI1NTE5OiBpZFgyNTUxOSxcbiAgaWRYNDQ4OiBpZFg0NDhcbn0pO1xuXG5jbGFzcyBFY0N1cnZlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICBzdGF0aWMgcmVnaXN0ZXIoaXRlbSkge1xuICAgICAgICBjb25zdCBvaWQgPSBuZXcgT2JqZWN0SWRlbnRpZmllcigpO1xuICAgICAgICBvaWQudmFsdWUgPSBpdGVtLmlkO1xuICAgICAgICBjb25zdCByYXcgPSBhc24xU2NoZW1hLkFzbkNvbnZlcnQuc2VyaWFsaXplKG9pZCk7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgcmF3LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lcy5wdXNoKGl0ZW0ubmFtZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kKG5hbWVPcklkKSB7XG4gICAgICAgIG5hbWVPcklkID0gbmFtZU9ySWQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gbmFtZU9ySWQgfHwgaXRlbS5pZC50b1VwcGVyQ2FzZSgpID09PSBuYW1lT3JJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5hbWVPcklkKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZmluZChuYW1lT3JJZCk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEVDIG5hbWVkIGN1cnZlICcke25hbWVPcklkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbkVjQ3VydmVzLml0ZW1zID0gW107XG5FY0N1cnZlcy5uYW1lcyA9IFtdO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIlAtMjU2XCIsIGlkOiBpZFNlY3AyNTZyMSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIlAtMzg0XCIsIGlkOiBpZFNlY3AzODRyMSwgc2l6ZTogMzg0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIlAtNTIxXCIsIGlkOiBpZFNlY3A1MjFyMSwgc2l6ZTogNTIxIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcIkstMjU2XCIsIGlkOiBpZFNlY3AyNTZrMSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxNjByMVwiLCBpZDogaWRCcmFpbnBvb2xQMTYwcjEsIHNpemU6IDE2MCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMTYwdDFcIiwgaWQ6IGlkQnJhaW5wb29sUDE2MHQxLCBzaXplOiAxNjAgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE5MnIxXCIsIGlkOiBpZEJyYWlucG9vbFAxOTJyMSwgc2l6ZTogMTkyIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxOTJ0MVwiLCBpZDogaWRCcmFpbnBvb2xQMTkydDEsIHNpemU6IDE5MiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjI0cjFcIiwgaWQ6IGlkQnJhaW5wb29sUDIyNHIxLCBzaXplOiAyMjQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDIyNHQxXCIsIGlkOiBpZEJyYWlucG9vbFAyMjR0MSwgc2l6ZTogMjI0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyNTZyMVwiLCBpZDogaWRCcmFpbnBvb2xQMjU2cjEsIHNpemU6IDI1NiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjU2dDFcIiwgaWQ6IGlkQnJhaW5wb29sUDI1NnQxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDMyMHIxXCIsIGlkOiBpZEJyYWlucG9vbFAzMjByMSwgc2l6ZTogMzIwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAzMjB0MVwiLCBpZDogaWRCcmFpbnBvb2xQMzIwdDEsIHNpemU6IDMyMCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzg0cjFcIiwgaWQ6IGlkQnJhaW5wb29sUDM4NHIxLCBzaXplOiAzODQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDM4NHQxXCIsIGlkOiBpZEJyYWlucG9vbFAzODR0MSwgc2l6ZTogMzg0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFA1MTJyMVwiLCBpZDogaWRCcmFpbnBvb2xQNTEycjEsIHNpemU6IDUxMiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQNTEydDFcIiwgaWQ6IGlkQnJhaW5wb29sUDUxMnQxLCBzaXplOiA1MTIgfSk7XG5cbmNsYXNzIEhtYWNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJITUFDXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJzaWduXCIsIFwidmVyaWZ5XCJdO1xuICAgIH1cbiAgICBnZXREZWZhdWx0TGVuZ3RoKGFsZ05hbWUpIHtcbiAgICAgICAgc3dpdGNoIChhbGdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiA1MTI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbGdvcml0aG0gbmFtZSAnJHthbGdOYW1lfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICBpZiAoXCJsZW5ndGhcIiBpbiBhbGdvcml0aG0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGdvcml0aG0ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibGVuZ3RoOiBOdW1iZXIgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgIH1cbn1cblxuY2xhc3MgUGJrZGYyUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUEJLREYyXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJkZXJpdmVCaXRzXCIsIFwiZGVyaXZlS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInNhbHRcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5zYWx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5zYWx0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdGVyYXRpb25zXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5pdGVyYXRpb25zICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9uczogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uaXRlcmF0aW9ucyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25zOiBJcyBsZXNzIHRoYW4gMVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICBzdXBlci5jaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIGlmIChleHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZXh0cmFjdGFibGU6IE11c3QgYmUgJ2ZhbHNlJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSGtkZlByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkhLREZcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImRlcml2ZUtleVwiLCBcImRlcml2ZUJpdHNcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwic2FsdFwiKTtcbiAgICAgICAgaWYgKCFwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGFsZ29yaXRobS5zYWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHQ6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImluZm9cIik7XG4gICAgICAgIGlmICghcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShhbGdvcml0aG0uaW5mbykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgaWYgKGV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJleHRyYWN0YWJsZTogTXVzdCBiZSAnZmFsc2UnXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSAwO1xuICAgIH1cbiAgICBkaWdlc3QoLi4uYXJncykge1xuICAgICAgICBhcmdzWzBdID0geyBsZW5ndGg6IHRoaXMuZGVmYXVsdExlbmd0aCwgLi4uYXJnc1swXSB9O1xuICAgICAgICByZXR1cm4gc3VwZXIuZGlnZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0RpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tEaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYWxnb3JpdGhtLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBuZWdhdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2hha2UxMjhQcm92aWRlciBleHRlbmRzIFNoYWtlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcInNoYWtlMTI4XCI7XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IDE2O1xuICAgIH1cbn1cblxuY2xhc3MgU2hha2UyNTZQcm92aWRlciBleHRlbmRzIFNoYWtlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcInNoYWtlMjU2XCI7XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IDMyO1xuICAgIH1cbn1cblxuY2xhc3MgQ3J5cHRvIHtcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkNyeXB0b1wiO1xuICAgIH1cbiAgICByYW5kb21VVUlEKCkge1xuICAgICAgICBjb25zdCBiID0gdGhpcy5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcbiAgICAgICAgYls2XSA9IChiWzZdICYgMHgwZikgfCAweDQwO1xuICAgICAgICBiWzhdID0gKGJbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgICAgIGNvbnN0IHV1aWQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0hleChiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7dXVpZC5zdWJzdHJpbmcoMCwgOCl9LSR7dXVpZC5zdWJzdHJpbmcoOCwgMTIpfS0ke3V1aWQuc3Vic3RyaW5nKDEyLCAxNil9LSR7dXVpZC5zdWJzdHJpbmcoMTYsIDIwKX0tJHt1dWlkLnN1YnN0cmluZygyMCl9YDtcbiAgICB9XG59XG5cbmNsYXNzIFByb3ZpZGVyU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB9XG4gICAgZ2V0KGFsZ29yaXRobU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbYWxnb3JpdGhtTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5pdGVtc1twcm92aWRlci5uYW1lLnRvTG93ZXJDYXNlKCldID0gcHJvdmlkZXI7XG4gICAgfVxuICAgIHJlbW92ZUF0KGFsZ29yaXRobU5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldChhbGdvcml0aG1OYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLml0ZW1zW2FsZ29yaXRobU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgaGFzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLml0ZW1zKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBhbGdvcml0aG1zKCkge1xuICAgICAgICBjb25zdCBhbGdvcml0aG1zID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5pdGVtc1trZXldO1xuICAgICAgICAgICAgYWxnb3JpdGhtcy5wdXNoKHByb3ZpZGVyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGdvcml0aG1zLnNvcnQoKTtcbiAgICB9XG59XG5cbmNsYXNzIFN1YnRsZUNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IFByb3ZpZGVyU3RvcmFnZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNIYXNoZWRBbGdvcml0aG0oZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICYmIFwibmFtZVwiIGluIGRhdGFcbiAgICAgICAgICAgICYmIFwiaGFzaFwiIGluIGRhdGFcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJTdWJ0bGVDcnlwdG9cIjtcbiAgICB9XG4gICAgYXN5bmMgZGlnZXN0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDIsIFwiZGlnZXN0XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmRpZ2VzdChwcmVwYXJlZEFsZ29yaXRobSwgcHJlcGFyZWREYXRhLCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImdlbmVyYXRlS2V5XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5nZW5lcmF0ZUtleSh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24oLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJzaWduXCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5zaWduKHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwga2V5LCBwcmVwYXJlZERhdGEsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCA0LCBcInZlcmlmeVwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRTaWduYXR1cmUgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci52ZXJpZnkoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkU2lnbmF0dXJlLCBwcmVwYXJlZERhdGEsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJlbmNyeXB0XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5lbmNyeXB0KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwga2V5LCBwcmVwYXJlZERhdGEsIHsga2V5VXNhZ2U6IHRydWUgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImRlY3J5cHRcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmRlY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogdHJ1ZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZXJpdmVCaXRzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZGVyaXZlQml0c1wiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShiYXNlS2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5kZXJpdmVCaXRzKHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgYmFzZUtleSwgbGVuZ3RoLCB7IGtleVVzYWdlOiB0cnVlIH0sIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCA1LCBcImRlcml2ZUtleVwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwgYmFzZUtleSwgZGVyaXZlZEtleVR5cGUsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERlcml2ZWRLZXlUeXBlID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGRlcml2ZWRLZXlUeXBlKTtcbiAgICAgICAgY29uc3QgaW1wb3J0UHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkRGVyaXZlZEtleVR5cGUubmFtZSk7XG4gICAgICAgIGltcG9ydFByb3ZpZGVyLmNoZWNrRGVyaXZlZEtleVBhcmFtcyhwcmVwYXJlZERlcml2ZWRLZXlUeXBlKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBwcm92aWRlci5jaGVja0NyeXB0b0tleShiYXNlS2V5LCBcImRlcml2ZUtleVwiKTtcbiAgICAgICAgY29uc3QgZGVyaXZlZEJpdHMgPSBhd2FpdCBwcm92aWRlci5kZXJpdmVCaXRzKHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgYmFzZUtleSwgZGVyaXZlZEtleVR5cGUubGVuZ3RoIHx8IDUxMiwgeyBrZXlVc2FnZTogZmFsc2UgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0S2V5KFwicmF3XCIsIGRlcml2ZWRCaXRzLCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDIsIFwiZXhwb3J0S2V5XCIpO1xuICAgICAgICBjb25zdCBbZm9ybWF0LCBrZXksIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihrZXkuYWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5leHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCA1LCBcImltcG9ydEtleVwiKTtcbiAgICAgICAgY29uc3QgW2Zvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBpZiAoW1wicGtjczhcIiwgXCJzcGtpXCIsIFwicmF3XCJdLmluZGV4T2YoZm9ybWF0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihrZXlEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5pbXBvcnRLZXkoZm9ybWF0LCBwcmVwYXJlZERhdGEsIHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgha2V5RGF0YS5rdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogSXMgbm90IEpTT05cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgd3JhcEtleShmb3JtYXQsIGtleSwgd3JhcHBpbmdLZXksIHdyYXBBbGdvcml0aG0sIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGtleURhdGEgPSBhd2FpdCB0aGlzLmV4cG9ydEtleShmb3JtYXQsIGtleSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShrZXlEYXRhKTtcbiAgICAgICAgICAgIGtleURhdGEgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tVXRmOFN0cmluZyhqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobSh3cmFwQWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGtleURhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5lbmNyeXB0KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgd3JhcHBpbmdLZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogZmFsc2UgfSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHVud3JhcEtleShmb3JtYXQsIHdyYXBwZWRLZXksIHVud3JhcHBpbmdLZXksIHVud3JhcEFsZ29yaXRobSwgdW53cmFwcGVkS2V5QWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKHVud3JhcEFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcih3cmFwcGVkS2V5KTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBsZXQga2V5RGF0YSA9IGF3YWl0IHByb3ZpZGVyLmRlY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCB1bndyYXBwaW5nS2V5LCBwcmVwYXJlZERhdGEsIHsga2V5VXNhZ2U6IGZhbHNlIH0sIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImp3a1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGtleURhdGEgPSBKU09OLnBhcnNlKHB2dHN1dGlscy5Db252ZXJ0LlRvVXRmOFN0cmluZyhrZXlEYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihcIndyYXBwZWRLZXk6IElzIG5vdCBhIEpTT05cIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuaW50ZXJuYWwgPSBlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHVud3JhcHBlZEtleUFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncyk7XG4gICAgfVxuICAgIGNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgc2l6ZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHttZXRob2ROYW1lfScgb24gJ1N1YnRsZUNyeXB0byc6ICR7c2l6ZX0gYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3MubGVuZ3RofSBwcmVzZW50YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWxnb3JpdGhtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3VidGxlQ3J5cHRvLmlzSGFzaGVkQWxnb3JpdGhtKGFsZ29yaXRobSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0geyAuLi5hbGdvcml0aG0gfTtcbiAgICAgICAgICAgIHByZXBhcmVkQWxnb3JpdGhtLmhhc2ggPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVkQWxnb3JpdGhtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmFsZ29yaXRobSB9O1xuICAgIH1cbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBLZXkgaXMgbm90IG9mIHR5cGUgJ0NyeXB0b0tleSdgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbnZlcnRlcnM6IGluZGV4JDNcbn0pO1xuXG5jb25zdCBSRVFVSVJFRF9GSUVMRFMgPSBbXCJjcnZcIiwgXCJlXCIsIFwia1wiLCBcImt0eVwiLCBcIm5cIiwgXCJ4XCIsIFwieVwiXTtcbmNsYXNzIEp3a1V0aWxzIHtcbiAgICBzdGF0aWMgYXN5bmMgdGh1bWJwcmludChoYXNoLCBqd2ssIGNyeXB0bykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5mb3JtYXQoandrLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGlnZXN0KGhhc2gsIHB2dHN1dGlscy5Db252ZXJ0LkZyb21CaW5hcnkoSlNPTi5zdHJpbmdpZnkoZGF0YSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZvcm1hdChqd2ssIHJlbW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXMgPSBPYmplY3QuZW50cmllcyhqd2spO1xuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICByZXMgPSByZXMuZmlsdGVyKG8gPT4gUkVRVUlSRURfRklFTERTLmluY2x1ZGVzKG9bMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSByZXMuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IGtleUEgPiBrZXlCID8gMSA6IGtleUEgPCBrZXlCID8gLTEgOiAwKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhyZXMpO1xuICAgIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCdWZmZXJTb3VyY2VDb252ZXJ0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlcjsgfVxufSk7XG5leHBvcnRzLkFlc0NiY1Byb3ZpZGVyID0gQWVzQ2JjUHJvdmlkZXI7XG5leHBvcnRzLkFlc0NtYWNQcm92aWRlciA9IEFlc0NtYWNQcm92aWRlcjtcbmV4cG9ydHMuQWVzQ3RyUHJvdmlkZXIgPSBBZXNDdHJQcm92aWRlcjtcbmV4cG9ydHMuQWVzRWNiUHJvdmlkZXIgPSBBZXNFY2JQcm92aWRlcjtcbmV4cG9ydHMuQWVzR2NtUHJvdmlkZXIgPSBBZXNHY21Qcm92aWRlcjtcbmV4cG9ydHMuQWVzS3dQcm92aWRlciA9IEFlc0t3UHJvdmlkZXI7XG5leHBvcnRzLkFlc1Byb3ZpZGVyID0gQWVzUHJvdmlkZXI7XG5leHBvcnRzLkFsZ29yaXRobUVycm9yID0gQWxnb3JpdGhtRXJyb3I7XG5leHBvcnRzLkNyeXB0byA9IENyeXB0bztcbmV4cG9ydHMuQ3J5cHRvRXJyb3IgPSBDcnlwdG9FcnJvcjtcbmV4cG9ydHMuQ3J5cHRvS2V5ID0gQ3J5cHRvS2V5O1xuZXhwb3J0cy5EZXNQcm92aWRlciA9IERlc1Byb3ZpZGVyO1xuZXhwb3J0cy5FY0N1cnZlcyA9IEVjQ3VydmVzO1xuZXhwb3J0cy5FY1V0aWxzID0gRWNVdGlscztcbmV4cG9ydHMuRWNkaEVzUHJvdmlkZXIgPSBFY2RoRXNQcm92aWRlcjtcbmV4cG9ydHMuRWNkaFByb3ZpZGVyID0gRWNkaFByb3ZpZGVyO1xuZXhwb3J0cy5FY2RzYVByb3ZpZGVyID0gRWNkc2FQcm92aWRlcjtcbmV4cG9ydHMuRWREc2FQcm92aWRlciA9IEVkRHNhUHJvdmlkZXI7XG5leHBvcnRzLkVsbGlwdGljUHJvdmlkZXIgPSBFbGxpcHRpY1Byb3ZpZGVyO1xuZXhwb3J0cy5Ia2RmUHJvdmlkZXIgPSBIa2RmUHJvdmlkZXI7XG5leHBvcnRzLkhtYWNQcm92aWRlciA9IEhtYWNQcm92aWRlcjtcbmV4cG9ydHMuSndrVXRpbHMgPSBKd2tVdGlscztcbmV4cG9ydHMuT3BlcmF0aW9uRXJyb3IgPSBPcGVyYXRpb25FcnJvcjtcbmV4cG9ydHMuUGJrZGYyUHJvdmlkZXIgPSBQYmtkZjJQcm92aWRlcjtcbmV4cG9ydHMuUGVtQ29udmVydGVyID0gUGVtQ29udmVydGVyO1xuZXhwb3J0cy5Qcm92aWRlckNyeXB0byA9IFByb3ZpZGVyQ3J5cHRvO1xuZXhwb3J0cy5Qcm92aWRlclN0b3JhZ2UgPSBQcm92aWRlclN0b3JhZ2U7XG5leHBvcnRzLlJlcXVpcmVkUHJvcGVydHlFcnJvciA9IFJlcXVpcmVkUHJvcGVydHlFcnJvcjtcbmV4cG9ydHMuUnNhT2FlcFByb3ZpZGVyID0gUnNhT2FlcFByb3ZpZGVyO1xuZXhwb3J0cy5Sc2FQcm92aWRlciA9IFJzYVByb3ZpZGVyO1xuZXhwb3J0cy5Sc2FQc3NQcm92aWRlciA9IFJzYVBzc1Byb3ZpZGVyO1xuZXhwb3J0cy5Sc2FTc2FQcm92aWRlciA9IFJzYVNzYVByb3ZpZGVyO1xuZXhwb3J0cy5TaGFrZTEyOFByb3ZpZGVyID0gU2hha2UxMjhQcm92aWRlcjtcbmV4cG9ydHMuU2hha2UyNTZQcm92aWRlciA9IFNoYWtlMjU2UHJvdmlkZXI7XG5leHBvcnRzLlNoYWtlUHJvdmlkZXIgPSBTaGFrZVByb3ZpZGVyO1xuZXhwb3J0cy5TdWJ0bGVDcnlwdG8gPSBTdWJ0bGVDcnlwdG87XG5leHBvcnRzLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IgPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yO1xuZXhwb3J0cy5hc24xID0gaW5kZXgkMTtcbmV4cG9ydHMuaXNKV0sgPSBpc0pXSztcbmV4cG9ydHMuanNvbiA9IGluZGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/webcrypto-core/build/webcrypto-core.js\n");

/***/ })

};
;